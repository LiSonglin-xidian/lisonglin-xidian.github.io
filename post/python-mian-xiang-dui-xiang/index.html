<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>Python 面向对象 | 想不想该不该</title>
<link rel="shortcut icon" href="/favicon.ico?v=1699601399034">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Python 面向对象" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>想不想该不该</span>
            </a>  
          
        </div>
        
          <p class="subtitle">现龙在田，天下文明</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">想不想该不该</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">27</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://lisonglin-xidian.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="">
              <i class="fa fa-globe" title=""></i>
            </a>
          
        
        
      </div>
    </div>
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B">面向对象技术简介</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%B1%BB">创建类</a>
<ul>
<li><a href="#self%E4%BB%A3%E8%A1%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E8%80%8C%E9%9D%9E%E7%B1%BB">self代表类的实例，而非类</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">创建实例对象</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7">访问属性</a></li>
<li><a href="#python%E5%86%85%E7%BD%AE%E7%B1%BB%E5%B1%9E%E6%80%A7">Python内置类属性</a></li>
<li><a href="#python%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">python对象销毁(垃圾回收)</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">类的继承</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95">基础重载方法</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
<li><a href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95">类属性与方法</a>
<ul>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">类的私有属性</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">类的方法</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">类的私有方法</a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%A4%B4%E5%B0%BE%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E8%AF%B4%E6%98%8E">单下划线、双下划线、头尾双下划线说明：</a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://lisonglin-xidian.github.io/post/python-mian-xiang-dui-xiang/"> Python 面向对象 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-03-21 16:04:43">2022-03-21</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >14<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >3380<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/post/python-mian-xiang-dui-xiang/"
      data-flag-title="Python 面向对象"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。<br>
如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。<br>
接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<!-- more -->
<h1 id="面向对象技术简介">面向对象技术简介</h1>
<p><strong>类(Class)</strong>:<br>
用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。<br>
<strong>类变量：</strong><br>
类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。<br>
<strong>数据成员：</strong><br>
类变量或者实例变量, 用于处理类及其实例对象的相关的数据。<br>
<strong>方法重写：</strong><br>
如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。<br>
<strong>局部变量：</strong><br>
定义在方法中的变量，只作用于当前实例的类。<br>
<strong>实例变量：</strong><br>
在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。<br>
<strong>继承：</strong><br>
即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。<br>
<strong>实例化：</strong><br>
创建一个类的实例，类的具体对象。<br>
<strong>方法：</strong><br>
类中定义的函数。<br>
<strong>对象：</strong><br>
通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
<h1 id="创建类">创建类</h1>
<p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p>
<pre><code>class ClassName:
   '类的帮助信息'   #类文档字符串           #通过ClassName.__doc__查看。
   class_suite  #类体
</code></pre>
<p>类的帮助信息可以通过<code>ClassName.__doc__</code>查看。<br>
class_suite 由类成员，方法，数据属性组成。<br>
例程：</p>
<pre><code>class Employee:
   '所有员工的基类'
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &quot;Total Employee %d&quot; % Employee.empCount
 
   def displayEmployee(self):
      print &quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary
</code></pre>
<p>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。<br>
第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法<br>
self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</p>
<h2 id="self代表类的实例而非类">self代表类的实例，而非类</h2>
<p><strong>类的方法</strong>与<strong>普通的函数</strong>只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照<strong>惯例它的名称是 self</strong>。</p>
<pre><code>class Test:
    def prt(self):
        print(self)
        print(self.__class__)
 
t = Test()
t.prt()
</code></pre>
<p>执行结果：</p>
<pre><code>&lt;__main__.Test instance at 0x10d066878&gt;
__main__.Test
</code></pre>
<p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 <code>self.__class__</code> 则指向类。self 不是 python 关键字，我们把他换成其他字符也是可以执行的，例如 runoob 也是可以正常执行的:</p>
<h1 id="创建实例对象">创建实例对象</h1>
<p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。<br>
以下使用类的名称 Employee 来实例化，并通过 <code>__init__ </code>方法接收参数。</p>
<pre><code>&quot;创建 Employee 类的第一个对象&quot;
emp1 = Employee(&quot;Zara&quot;, 2000)
&quot;创建 Employee 类的第二个对象&quot;
emp2 = Employee(&quot;Manni&quot;, 5000)
</code></pre>
<h1 id="访问属性">访问属性</h1>
<p>您可以使用点号 <code>.</code> 来访问对象的属性。使用如下类的名称访问类变量:</p>
<pre><code>emp1.displayEmployee()
emp2.displayEmployee()
print &quot;Total Employee %d&quot; % Employee.empCount
</code></pre>
<p>完整实例：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class Employee:
   '所有员工的基类'
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &quot;Total Employee %d&quot; % Employee.empCount
 
   def displayEmployee(self):
      print &quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary
 
&quot;创建 Employee 类的第一个对象&quot;
emp1 = Employee(&quot;Zara&quot;, 2000)
&quot;创建 Employee 类的第二个对象&quot;
emp2 = Employee(&quot;Manni&quot;, 5000)
emp1.displayEmployee()  #输出：Name :  Zara ,Salary:  2000
emp2.displayEmployee()  #输出：Name :  Manni ,Salary:  5000
print &quot;Total Employee %d&quot; % Employee.empCount   #输出：Total Employee 2
</code></pre>
<p>你可以添加，删除，修改类的属性，如下所示：</p>
<pre><code>emp1.age = 7  # 添加一个 'age' 属性
emp1.age = 8  # 修改 'age' 属性
del emp1.age  # 删除 'age' 属性
</code></pre>
<p>你也可以使用以下函数的方式来访问属性：<br>
getattr(obj, name[, default]) : 访问对象的属性。<br>
hasattr(obj,name) : 检查是否存在一个属性。<br>
setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。<br>
delattr(obj, name) : 删除属性。</p>
<pre><code>getattr(emp1, 'age')    # 返回 'age' 属性的值
hasattr(emp1, 'age')    # 如果存在 'age' 属性返回 True。
setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8
delattr(emp1, 'age')    # 删除属性 'age'
</code></pre>
<h1 id="python内置类属性">Python内置类属性</h1>
<p><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）<br>
<code>__doc__ </code>:类的文档字符串<br>
<code>__name__</code>: 类名<br>
<code>__module__</code>: 类定义所在的模块（类的全名是<code>'__main__.className'</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code> 等于 mymod）<br>
<code>__bases__ </code>: 类的所有父类构成元素（包含了一个由所有父类组成的元组）<br>
Python内置类属性调用实例如下：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class Employee:
   '所有员工的基类'
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &quot;Total Employee %d&quot; % Employee.empCount
 
   def displayEmployee(self):
      print &quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary
 
print &quot;Employee.__doc__:&quot;, Employee.__doc__
print &quot;Employee.__name__:&quot;, Employee.__name__
print &quot;Employee.__module__:&quot;, Employee.__module__
print &quot;Employee.__bases__:&quot;, Employee.__bases__
print &quot;Employee.__dict__:&quot;, Employee.__dict__
</code></pre>
<p>输出：</p>
<pre><code>Employee.__doc__: 所有员工的基类
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: ()
Employee.__dict__: {'__module__': '__main__', 'displayCount': &lt;function displayCount at 0x10a939c80&gt;, 'empCount': 0, 'displayEmployee': &lt;function displayEmployee at 0x10a93caa0&gt;, '__doc__': '\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb', '__init__': &lt;function __init__ at 0x10a939578&gt;}
</code></pre>
<h1 id="python对象销毁垃圾回收">python对象销毁(垃圾回收)</h1>
<p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。<br>
在 Python 内部记录着所有使用中的对象各有多少引用。<br>
一个内部跟踪变量，称为一个引用计数器。<br>
当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<pre><code>a = 40      # 创建对象  &lt;40&gt;
b = a       # 增加引用， &lt;40&gt; 的计数
c = [b]     # 增加引用.  &lt;40&gt; 的计数

del a       # 减少引用 &lt;40&gt; 的计数
b = 100     # 减少引用 &lt;40&gt; 的计数
c[0] = -1   # 减少引用 &lt;40&gt; 的计数
</code></pre>
<p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p>
<h1 id="类的继承">类的继承</h1>
<p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。<br>
通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。<br>
继承语法：</p>
<pre><code>class 派生类名(基类名)
    ...
</code></pre>
<p>在python中继承中的一些特点：<br>
1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。<br>
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br>
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>
如果在继承元组中列了一个以上的类，那么它就被称作&quot;多重继承&quot; 。<br>
语法：<br>
派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：</p>
<pre><code>class SubClassName (ParentClass1[, ParentClass2, ...]):
    ...
</code></pre>
<p>例程</p>
<pre><code>class Parent:        # 定义父类
   parentAttr = 100
   def __init__(self):
      print &quot;调用父类构造函数&quot;
 
   def parentMethod(self):
      print '调用父类方法'
 
   def setAttr(self, attr):
      Parent.parentAttr = attr
 
   def getAttr(self):
      print &quot;父类属性 :&quot;, Parent.parentAttr
 
class Child(Parent): # 定义子类
   def __init__(self):
      print &quot;调用子类构造方法&quot;
 
   def childMethod(self):
      print '调用子类方法'
 
c = Child()          # 实例化子类           #输出：调用子类构造方法
c.childMethod()      # 调用子类的方法           #输出：调用子类方法
c.parentMethod()     # 调用父类方法         #输出：调用父类方法
c.setAttr(200)       # 再次调用父类的方法 - 设置属性值          #设置父类属性值
c.getAttr()          # 再次调用父类的方法 - 获取属性值          #输出：父类属性 : 200
</code></pre>
<p>你可以继承多个类</p>
<pre><code>class A:        # 定义类 A
.....
class B:         # 定义类 B
.....
class C(A, B):   # 继承类 A 和 B
.....
</code></pre>
<p>你可以使用issubclass()或者isinstance()方法来检测。<br>
issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)<br>
isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。</p>
<h1 id="方法重写">方法重写</h1>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：<br>
实例：</p>
<pre><code>class Parent:        # 定义父类
   def myMethod(self):
      print '调用父类方法'
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print '调用子类方法'
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法         #输出：调用子类方法
</code></pre>
<h1 id="基础重载方法">基础重载方法</h1>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>简单的调用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__init__ ( self [,args...] )</code></td>
<td>构造函数</td>
<td><code>obj = className(args)</code></td>
</tr>
<tr>
<td><code>__del__( self )</code></td>
<td>析构方法, 删除一个对象</td>
<td><code>del obj</code></td>
</tr>
<tr>
<td><code>__repr__( self )</code></td>
<td>转化为供解释器读取的形式</td>
<td><code>repr(obj)</code></td>
</tr>
<tr>
<td><code>__str__( self )</code></td>
<td>用于将值转化为适于人阅读的形式</td>
<td><code>str(obj)</code></td>
</tr>
<tr>
<td><code>__cmp__ ( self, x )</code></td>
<td>对象比较</td>
<td><code>cmp(obj, x)</code></td>
</tr>
</tbody>
</table>
<h1 id="运算符重载">运算符重载</h1>
<p>例程：</p>
<pre><code>class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
 
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)
 
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)     #输出：Vector(7,8)
</code></pre>
<h1 id="类属性与方法">类属性与方法</h1>
<h2 id="类的私有属性">类的私有属性</h2>
<p><code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code>。</p>
<h2 id="类的方法">类的方法</h2>
<p>在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p>
<h2 id="类的私有方法">类的私有方法</h2>
<p><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 <code>self.__private_methods</code><br>
例程：</p>
<pre><code>class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
 
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print self.__secretCount
 
counter = JustCounter()
counter.count()
counter.count()
print counter.publicCount
print counter.__secretCount  # 报错，实例不能访问私有变量
</code></pre>
<p>Python 通过改变名称来包含类名:</p>
<pre><code>1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 17, in &lt;module&gt;
    print counter.__secretCount  # 报错，实例不能访问私有变量
AttributeError: JustCounter instance has no attribute '__secretCount'
</code></pre>
<p>Python不允许实例化的类访问私有数据，但你可以使用 <code>object._className__attrName（ 对象名._类名__私有属性名 ）</code>访问属性，参考以下实例：</p>
<pre><code>class Runoob:
    __site = &quot;www.runoob.com&quot;

runoob = Runoob()
print runoob._Runoob__site      #输出：www.runoob.com
</code></pre>
<h1 id="单下划线-双下划线-头尾双下划线说明">单下划线、双下划线、头尾双下划线说明：</h1>
<p><code>__foo__</code>: 定义的是特殊方法，一般是系统定义名字 ，类似<code>__init__()</code>之类的。<br>
<code>_foo</code>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于<code> from module import *</code><br>
<code>__foo</code>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行</p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      想不想该不该
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://lisonglin-xidian.github.io/post/python-mian-xiang-dui-xiang/" title="Python 面向对象">https://lisonglin-xidian.github.io/post/python-mian-xiang-dui-xiang/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="GoogleDrive+PoweredBy.cloud在Zotero笔记中使用图床" href="https://lisonglin-xidian.github.io/post/googledrivepoweredbycloud-zai-zotero-bi-ji-zhong-shi-yong-tu-chuang/">GoogleDrive+PoweredBy.cloud在Zotero笔记中使用图床</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="GoogleDrive+PoweredBy.cloud在Zotero笔记中使用图床" href="https://lisonglin-xidian.github.io/post/googledrivepoweredbycloud-zai-zotero-bi-ji-zhong-shi-yong-tu-chuang/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Python 入门笔记" href="https://lisonglin-xidian.github.io/post/python-ru-men-bi-ji/">Python 入门笔记</a>
        <a class="nav-mobile-next" title="Python 入门笔记" href="https://lisonglin-xidian.github.io/post/python-ru-men-bi-ji/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="/media/images/2022.jpg" />
              </div>
              
                
                  
                    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_music" id="musicButton"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
        <input name="live2dBGM" value="" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'histoire'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
                      
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/siesta-jiao-cheng-nerdalytics/"" data-c="
          &lt;p&gt;Youtube Siesta学习笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;electrode-电极计算&#34;&gt;electrode-电极计算&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SolutionMethod diagon&lt;/code&gt;&lt;br&gt;
SolutionMethod    计算方法&lt;br&gt;
diagon 必须在电极计算中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SystemName Bi electrode
SystemLabel elec_bi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SystemName和SystemLabel首选使用下划线而不是破折号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Number of species
NumberOfSpecies 1
%block ChemicalSpeciesLabel
  1  83 Bi
%endblock ChemicalSpeciesLabel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NumberOfSpecies 有多少个元素&lt;br&gt;
ChemicalSpeciesLabel 第一个是元素编号，第二个是原子序数，第三个是元素符号&lt;br&gt;
XC交换关联泛函相关参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PAO.BasisSize    DZP
PAO.EnergyShift  0.005 Ry
XC.functional   GGA
XC.authors      PBE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BasisSize 基组设置，这里是DZP基组，SIESTA典型&lt;br&gt;
EnergyShift是截止半径标准&lt;br&gt;
泛函为GGA-PBE&lt;br&gt;
K-points：计算时间等&lt;br&gt;
原子数，晶格矢量，晶格坐标信息&lt;br&gt;
&lt;code&gt;MD.NumCGsteps&lt;/code&gt;离子步，如果已经完成离子步优化，在电极计算中设置为0&lt;br&gt;
SCF-电子步设置参数&lt;br&gt;
MD-离子步设置参数&lt;br&gt;
Output 变量设置输出信息&lt;br&gt;
电极计算必须在其他选项中打开TS.HS.Save。&lt;br&gt;
赝势选择可以使用离子文件（.ion）需要添加参数&lt;code&gt;User.Basis .true.&lt;/code&gt;如果使用psf或者psml文件需要将这里设置为&lt;code&gt;.false.&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;scanttering-散射区域计算&#34;&gt;Scanttering-散射区域计算&lt;/h1&gt;
&lt;p&gt;求解方法&lt;br&gt;
&lt;code&gt;SolutionMethod diagon&lt;/code&gt;&lt;br&gt;
SolutionMethod    计算方法&lt;br&gt;
Transiesta 瞬态求解方法，已经集成在siesta中。&lt;br&gt;
系统名称以及系统标签&lt;br&gt;
材料物种，&lt;br&gt;
基组以及交换关联泛函相同&lt;br&gt;
K-points在散射计算中和电极计算相同。&lt;br&gt;
结构信息通过重复6次得到新的结构输出为xyz格式拷贝过来。&lt;br&gt;
下面信息相似，需要注意的是添加transiesta散射区域计算代码。从0电位计算开始，到左右电极定义，这里到TS.ChemPot.Right结束。&lt;br&gt;
必须从电极计算结果中复制TSHS格式的文件。&lt;br&gt;
used atomes不需要添加，有部分教程中添加该参数。&lt;br&gt;
其他选项是默认的，这里还通过TBT.DOS.A.ALL计算了态密度。&lt;br&gt;
TS.SolutionMethod 计算方法是btd&lt;br&gt;
TS.BTD.Pivot&lt;br&gt;
进行散射计算前推荐先运行analyze&lt;br&gt;
&lt;code&gt;siesta -fdf TS.Analyze RUN.fdf &amp;gt; analyze.out&lt;/code&gt;&lt;br&gt;
mpirun -np 16 transiesta &amp;lt;scat.fdf&amp;gt; Trans.out&lt;br&gt;
tbtrans &amp;lt;scat.fdf&amp;gt; TBT.out&lt;/p&gt;
&lt;h1 id=&#34;siesta-收敛性测试&#34;&gt;SIESTA 收敛性测试：&lt;/h1&gt;
&lt;p&gt;计算结果的精确性&lt;br&gt;
截断能，K-points，磁各项异性，超胞大小测试&lt;br&gt;
分子动力学，使用共轭梯度方式得到最小化能量。&lt;br&gt;
不同K点网格划分，MP mesh下得到晶格常数和自由能（Free Energy）。&lt;br&gt;
极化分子在不同晶胞尺寸（lattice constant）下的electric dipole的收敛情况&lt;/p&gt;
&lt;h1 id=&#34;结构优化&#34;&gt;结构优化&lt;/h1&gt;
&lt;p&gt;共轭梯度法：收敛快，内存小；但是计算复杂，容易得到局域最低点，不是全局最优点。&lt;br&gt;
分子动力学得到热稳定性。计算声子等&lt;br&gt;
分子动力学采用伯恩奥本海默近似得到。&lt;br&gt;
分态能带图，能带，&lt;br&gt;
** Basis set In siesta 😗*&lt;br&gt;
&lt;strong&gt;SZ&lt;/strong&gt;- single zeta is a minimal basis set for quick simulation but not accurate enough&lt;br&gt;
&lt;strong&gt;DZ&lt;/strong&gt; - Double zeta, considers the radial flexibility of an atomic orbitals, is more accurate&lt;br&gt;
&lt;strong&gt;DZP&lt;/strong&gt;- considers the angular flexibility of an atomic orbitals P stands for polarization (electron spin effect)&lt;br&gt;
&lt;strong&gt;Choosing DZP is accurate enough for any simulation&lt;/strong&gt;&lt;br&gt;
Larger mesh-cutoff ➡️  Smaller spacing ➡️  more dense 3D mesh ➡️  more accurate simulation ➡️  but longer computational time.&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1684571741313.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;optimization of XC and basis sets&lt;br&gt;
LDA and GGA for XC，SZ，DZ，and DZP for basis。DZP is found accurate enough for any simulation&lt;br&gt;
如何使用siesta优化。&lt;br&gt;
在研究材料或者纳米材料的不同特性之前需要优化所有系统。&lt;br&gt;
以碘化银为例，分别优化mesh-cutoff，KPOINTS，latt_opt，tot_opt。&lt;br&gt;
第一步：优化mesh-cutoff&lt;br&gt;
&lt;code&gt;sh script_cutoff.sh&lt;/code&gt;&lt;br&gt;
创建十个文件夹&lt;br&gt;
&lt;code&gt;sh get_EvsC_script.sh&lt;/code&gt;&lt;br&gt;
生成EvsC.dat文件并显示绘图，寻找最佳网格截止能量：mesh-cutoff&lt;br&gt;
第二步：kpoint 优化&lt;br&gt;
将kpoint_script.sh中的MeshCutoff值修改为上一步的结果，&lt;br&gt;
运行&lt;code&gt;sh kpoint_script.sh&lt;/code&gt;后得到不同文件夹下不同K值的siesta结果&lt;br&gt;
运行&lt;code&gt;sh get_EvsK_script.sh&lt;/code&gt;&lt;br&gt;
创建EvsK.dat文件并显示绘图，寻找最佳K点 （能量最低值）&lt;br&gt;
第三步：晶格常数优化&lt;br&gt;
替换脚本中的MeshCutoff以及K点&lt;br&gt;
运行&lt;code&gt;sh la_opt_script.sh&lt;/code&gt;将会在不同文件夹运行siesta&lt;br&gt;
运行&lt;code&gt;sh get_Evsa_script.sh&lt;/code&gt; 得到Evsa.dat文件并绘图，寻找最佳晶格常数（能量最低值）&lt;br&gt;
第四步：总能优化&lt;br&gt;
替换脚本中的截止能，K点，晶格常数然后运行脚本&lt;br&gt;
&lt;code&gt;sh script_final_opt.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mpi运行示例&#34;&gt;mpi运行示例&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;mpirun -np 16 siesta Bi.fdf &amp;gt; Bi.out&lt;/code&gt;&lt;br&gt;
&lt;code&gt;mpirun -np 16 siesta --electrode electrode.fdf &amp;gt; electrode.out&lt;/code&gt;&lt;br&gt;
作业脚本删除无用输出文件&lt;/p&gt;
&lt;h1 id=&#34;dos&#34;&gt;DOS&lt;/h1&gt;
&lt;p&gt;使用Utils下的Eig2DOS绘制DOS&lt;br&gt;
Eig2DOS -f -s 0.100 -n 1000 -e -30 -E 20 Li2FeP2O7-tri.EIG&amp;gt;dos.dat&lt;br&gt;
展宽越小，计算精度越高，DOS图就尖锐瘦长一些，但是收敛的时间要长一些。&lt;/p&gt;
&lt;p&gt;当体系的电子结构在Fermi 能级附近出现多个简并能级时，体系的自洽过程会相当慢，甚至不能收敛。这是由于能级简并，或能级之间相差不大，导致电子“不知道”应该在哪里分布，从而不断地在几个能级之间“跳来跳去”，但无论电子分布在哪个前线能级上整个体系都不能自洽。&lt;br&gt;
所谓拖尾，是指在前线轨道上，电子可以以分数分布，而不再要求一定要以整数分布，从而使电子可以一分为多地分布在能量相近的各个前线轨道，而不需要在各轨道之间“跳来跳去”，使体系更容易自洽。&lt;br&gt;
使用该办法时要对拖尾效应设定一个能量值，使电子在能量相差在该值之内的轨道进行分数分布。设定值越小，计算结果越精确，但亦更难自洽。（也叫展宽）&lt;/p&gt;
&lt;p&gt;态密度的展宽从算法上来说是为了获得更加清楚平滑的曲线，但是从物理意义上来说是借用了光谱学中的一个概念，当一个体系有了在一个能级以后，我们计算得到的结果是一个静态的，也就是说得到的是一个准确的数值，如果我们把这些数值画出来，在每一个K点得到是一个冲击函数(delta(t)).但是实际情况中，体系是有外部的扰动的，比如热扰动，这种热扰动在光谱学中得到的能级是有一定的波动，这样我们得到能级是有一定的展度宽。为了描述这个扰动带来的能级的展宽，我们在分析态密度时引入了展宽的概念，这是和实际情况可比的一种处理手段。&lt;/p&gt;
&lt;p&gt;使用Utils下的fmpdos和pdosxml绘制PDOS&lt;br&gt;
绘制PDOS需要添加block&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%block ProjectedDensityOfStates
-30 20 0.1 1000 eV
%endblock ProjectedDensityOfStates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中-30 20是能量范围&lt;br&gt;
0.1是展宽&lt;br&gt;
1000是绘制的点数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf CLOCK
rm -rf INPUT*
rm -rf MESSAGES
rm -rf fdf-*
rm -rf PARALLEL_DIST
rm -rf O_NORMAL_EXIT
rm -rf TIMES
rm -rf OCCS
&lt;/code&gt;&lt;/pre&gt;
">SIESTA 教程-Nerdalytics</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu-2004-intel-oneapi-bian-yi-siesta-max-131psml/"" data-c="
          &lt;p&gt;ubuntu 20.04编译安装siesta，TBtrans，siesta Max-1.3.1中的siesta已经包含transiesta。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-intel-onepai安装&#34;&gt;1. Intel Onepai安装&lt;/h1&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&#34;2-编译-siesta&#34;&gt;2. 编译 siesta&lt;/h1&gt;
&lt;p&gt;从siesta官网下载siesta-Max-1.3.1版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf siesta-MaX-1.3.1.tar.gz
cd siesta-MaX-1.3.1/Docs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置编译器安装netcdf，flook，psml和gribxc。这里一定要选择和后面编译siesta相同的环境，否则报错，安装成功后会提示编译参数复制保存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export FC=ifort 
export CC=icc 
export MPICC=mpiicc 
export MPIFC=mpiifort
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持psml赝势格式的siesta必须安装这两个内容：&lt;br&gt;
安装psml以及gribxc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./install_psml.bash
./install_gridxc.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装必要文件后才可以安装netcdf4以及flook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install m4
./install_netcdf4.bash
sudo apt-get install libreadline-dev 
./install_flook.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功后会在最后提示编译参数。复制保存后面使用&lt;br&gt;
进入程序主目录下Obj目录，准备初步编译文件&lt;br&gt;
&lt;code&gt;cd siesta-MaX-1.3.1/Obj&lt;/code&gt;&lt;br&gt;
执行 &lt;code&gt;bash ../Src/obj_setup.sh&lt;/code&gt;&lt;br&gt;
&lt;code&gt;cp intel.make arch.make&lt;/code&gt;&lt;br&gt;
以下为MPI并行编译，包含库BLAS，LAPACK，ScaLAPACK，fdict，NetCDF，ncdf，flook，psml，gribxc等，不包含Metis，ELPA，MUMPS，PEXSI。&lt;br&gt;
在&lt;code&gt;arch.make&lt;/code&gt;文件中修改CC为mpicc，修改FC为mpiifort，&lt;br&gt;
注释&lt;code&gt;COMP_LIBS = libsiestaLAPACK.a libsiestaBLAS.a&lt;/code&gt;和&lt;code&gt;#LIBS =&lt;/code&gt;这两行&lt;br&gt;
添加内容（添加位置在&lt;code&gt;# Dependency rules ---------&lt;/code&gt;这一行前面）&lt;br&gt;
将上面编译成功netcdf和flook后输出的编译参数复制到下方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#MPI
MPI_INTERFACE = libmpi_f90.a
MPI_INCLUDE = .
FPPFLAGS += -DMPI

#BLAS &amp;amp; LAPACK &amp;amp; SCALAPACK_LIBS
LDFLAGS += -L/opt/intel/oneapi/mkl/2022.0.2/lib/intel64
#LIBS += -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64 -lmkl_intel_lp64 -lmkl_core -openmp -lmkl_intel_thread
LIBS += -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64

#psml xmlf90
XMLF90_ROOT = /home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build
include $(XMLF90_ROOT)/share/org.siesta-project/xmlf90.mk
PSML_ROOT = /home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build
include $(PSML_ROOT)/share/org.siesta-project/psml.mk
LDFLAGS += -Wl,-rpath,/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/lib

#gridxc libxc
GRIDXC_ROOT = /home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build
include $(GRIDXC_ROOT)/share/org.siesta-project/gridxc_dp_mpi.mk
LDFLAGS += -Wl,-rpath,/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/lib

#NetCDF &amp;amp; fdict &amp;amp; hdf5 &amp;amp; zlib &amp;amp; ncdf
INCFLAGS += -I/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/include
LDFLAGS += -L/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/lib -Wl,-rpath,/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/lib
LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
COMP_LIBS += libncdf.a libfdict.a
FPPFLAGS += -DCDF -DNCDF -DNCDF_4

#flook
INCFLAGS += -I/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/include
LDFLAGS += -L/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/lib -Wl,-rpath,/home/mccc/software/siesta/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/lib
LIBS += -lflookall -ldl
COMP_LIBS += libfdict.a
FPPFLAGS += -DSIESTA__FLOOK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整的arch.make如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 
# Copyright (C) 1996-2016	The SIESTA group
#  This file is distributed under the terms of the
#  GNU General Public License: see COPYING in the top directory
#  or http://www.gnu.org/copyleft/gpl.txt.
# See Docs/Contributors.txt for a list of contributors.
#
#-------------------------------------------------------------------
# arch.make file for gfortran compiler.
# To use this arch.make file you should rename it to
#   arch.make
# or make a sym-link.
# For an explanation of the flags see DOCUMENTED-TEMPLATE.make

.SUFFIXES:
.SUFFIXES: .f .F .o .c .a .f90 .F90

SIESTA_ARCH = ubuntu-intel-oneapi

CC = mpicc
FPP = $(FC) -E -P
FC = mpiifort
FC_SERIAL = ifort

FFLAGS = -O2 -fPIC -fp-model source

AR = ar
RANLIB = ranlib

SYS = nag

SP_KIND = 4
DP_KIND = 8
KINDS = $(SP_KIND) $(DP_KIND)

LDFLAGS =

#COMP_LIBS = libsiestaLAPACK.a libsiestaBLAS.a

FPPFLAGS = $(DEFS_PREFIX)-DFC_HAVE_ABORT

#LIBS =

#MPI
MPI_INTERFACE = libmpi_f90.a
MPI_INCLUDE = .
FPPFLAGS += -DMPI

#BLAS &amp;amp; LAPACK &amp;amp; SCALAPACK_LIBS
LDFLAGS += -L/opt/intel/oneapi/mkl/2022.0.2/lib/intel64
#LIBS += -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64 -lmkl_intel_lp64 -lmkl_core -openmp -lmkl_intel_thread
LIBS += -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64

XMLF90_ROOT = /home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build
include $(XMLF90_ROOT)/share/org.siesta-project/xmlf90.mk
PSML_ROOT = /home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build
include $(PSML_ROOT)/share/org.siesta-project/psml.mk
LDFLAGS += -Wl,-rpath,/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/lib


GRIDXC_ROOT = /home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build
include $(GRIDXC_ROOT)/share/org.siesta-project/gridxc_dp_mpi.mk
LDFLAGS += -Wl,-rpath,/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/lib

INCFLAGS += -I/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/include
LDFLAGS += -L/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/lib
LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
COMP_LIBS += libncdf.a libfdict.a
FPPFLAGS += -DCDF -DNCDF -DNCDF_4

INCFLAGS += -I/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/include
LDFLAGS += -L/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-pdf/siesta-MaX-1.3.1/Docs/build/flook/0.8.1/lib
LIBS += -lflookall -ldl
COMP_LIBS += libfdict.a
FPPFLAGS += -DSIESTA__FLOOK

# Dependency rules ---------

FFLAGS_DEBUG = -g -O1 -fp-model source   # your appropriate flags here...

# The atom.f code is very vulnerable. Particularly the Intel compiler
# will make an erroneous compilation of atom.f with high optimization
# levels.
atom.o: atom.F
	$(FC) -c $(FFLAGS_DEBUG) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F) $&amp;lt; 
state_analysis.o: state_analysis.F
	$(FC) -c $(FFLAGS_DEBUG) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F) $&amp;lt; 

.c.o:
	$(CC) -c $(CFLAGS) $(INCFLAGS) $(CPPFLAGS) $&amp;lt; 
.F.o:
	$(FC) -c $(FFLAGS) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F)  $&amp;lt; 
.F90.o:
	$(FC) -c $(FFLAGS) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_free_F90) $&amp;lt; 
.f.o:
	$(FC) -c $(FFLAGS) $(INCFLAGS) $(FCFLAGS_fixed_f)  $&amp;lt;
.f90.o:
	$(FC) -c $(FFLAGS) $(INCFLAGS) $(FCFLAGS_free_f90)  $&amp;lt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意$(FC)的前面是tab符号不是空格。&lt;br&gt;
然后&lt;br&gt;
在&lt;code&gt;siesta-MaX-1.3.1/Obj&lt;/code&gt;文件夹下&lt;br&gt;
执行&lt;code&gt;make&lt;/code&gt;&lt;br&gt;
这里可以获得&lt;code&gt;siesta&lt;/code&gt;执行文件&lt;br&gt;
该目录运行&lt;code&gt;./siesta&lt;/code&gt;&lt;br&gt;
输出内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Siesta Version  : unreleased 8ef31a088 (2021-10-19)
Architecture    : ubuntu-intel-oneapi-Max
Compiler version: ifort (IFORT) 2021.5.0 20211109
Compiler flags  : mpiifort -O2 -fPIC -fp-model source
PP flags        : -DFC_HAVE_ABORT -DMPI -DCDF -DNCDF -DNCDF_4 -DSIESTA__FLOOK
Libraries       : libncdf.a libfdict.a libfdict.a -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64 -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz -lflookall -ldl
Parallelisations: MPI
NetCDF support
NetCDF-4 support
Lua support

Runtime information:
* Directory : /home/mccc/download/siesta
* Running in serial mode (only 1 MPI rank).
&amp;gt;&amp;gt; Start of run:  13-MAY-2023  15:03:20

                           ***********************
                           *  WELCOME TO SIESTA  *
                           ***********************

reinit: Reading from standard input
reinit: Dumping input in INPUT_TMP.22936
************************** Dump of input data file ****************************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择执行如下内容(Max-1.3.1版本的siesta已经包含transiesta)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接执行`make transiesta`会报错需要先
执行 `make clean-transiesta`
然后运行`make transiesta`
这里可以获得`transiesta`执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;code&gt;cd siesta-MaX-1.3.1/Util/TS/TBtrans&lt;/code&gt;&lt;br&gt;
这里直接执行&lt;code&gt;make&lt;/code&gt;&lt;br&gt;
获得&lt;code&gt;TBtrans&lt;/code&gt;执行文件&lt;br&gt;
在siesta-MaX-1.3.1文件夹下新建文件夹bin&lt;br&gt;
&lt;code&gt;cd siesta-MaX-1.3.1&lt;/code&gt;&lt;br&gt;
&lt;code&gt;mkdir bin&lt;/code&gt;&lt;br&gt;
将&lt;code&gt;siesta&lt;/code&gt;，&lt;code&gt;transiesta&lt;/code&gt;，&lt;code&gt;TBtrans&lt;/code&gt;拷贝到bin文件夹下&lt;br&gt;
在&lt;code&gt;~/.bashrc&lt;/code&gt; 中添加&lt;br&gt;
&lt;code&gt;export PATH=:XXX/siesta-MaX-1.3.1/bin:$PATH&lt;/code&gt;&lt;br&gt;
参考地址：&lt;br&gt;
&lt;a href=&#34;http://blog.chinaunix.net/uid-20339569-id-5846483.html&#34;&gt;CentOS7+ifort14+mkl+mpich2环境下编译并行siesta&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.pseudo-dojo.org/index.html&#34;&gt;psml格式赝势库&lt;/a&gt;&lt;/p&gt;
">ubuntu 20.04 Intel-Oneapi 编译 siesta-Max-1.3.1(psml)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu-intel-oneapi-bian-yi-siesta/"" data-c="
          &lt;p&gt;ubuntu 20.04编译安装siesta，transiesta，TBtrans，siesta 4.1.5中的siesta已经包含transiesta。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-intel-onepai安装&#34;&gt;1. Intel Onepai安装&lt;/h1&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&#34;2-编译-siesta&#34;&gt;2. 编译 siesta&lt;/h1&gt;
&lt;p&gt;从siesta官网下载4.1.5版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf siesta-4.1.5.tar.gz
cd siesta-4.1.5/Docs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手动下载安装包：&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1683508950537.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置编译器安装netcdf和flook，这里一定要选择和后面编译siesta相同的环境，否则报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CC=mpicc
export FC=mpiifort
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装必要文件后才可以安装netcdf4以及flook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install m4
./install_netcdf4.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装成功后会在最后提示编译参数，复制保存后面使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install libreadline-dev 
./install_flook.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功后会在最后提示编译参数。复制保存后面使用&lt;br&gt;
进入程序主目录下Obj目录，准备初步编译文件&lt;br&gt;
&lt;code&gt;cd siesta-4.1.5/Obj&lt;/code&gt;&lt;br&gt;
执行 &lt;code&gt;bash ../Src/obj_setup.sh&lt;/code&gt;&lt;br&gt;
&lt;code&gt;cp intel.make arch.make&lt;/code&gt;&lt;br&gt;
以下为MPI并行编译，包含库BLAS，LAPACK，ScaLAPACK，fdict，NetCDF，ncdf，flook，&lt;br&gt;
不包含Metis，ELPA，MUMPS，PEXSI。&lt;br&gt;
在&lt;code&gt;arch.make&lt;/code&gt;文件中修改CC为mpicc，修改FC为mpiifort，&lt;br&gt;
注释&lt;code&gt;COMP_LIBS = libsiestaLAPACK.a libsiestaBLAS.a&lt;/code&gt;和&lt;code&gt;#LIBS =&lt;/code&gt;这两行&lt;br&gt;
添加内容（添加位置在&lt;code&gt;# Dependency rules ---------&lt;/code&gt;这一行前面）&lt;br&gt;
将上面编译成功netcdf和flook后输出的编译参数复制到下方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#MPI
MPI_INTERFACE = libmpi_f90.a
MPI_INCLUDE = .
FPPFLAGS += -DMPI

#BLAS &amp;amp; LAPACK &amp;amp; SCALAPACK_LIBS
LDFLAGS += -L/opt/intel/oneapi/mkl/2022.0.2/lib/intel64
#LIBS += -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64 -lmkl_intel_lp64 -lmkl_core -openmp -lmkl_intel_thread
LIBS += -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64

#NetCDF &amp;amp; fdict &amp;amp; hdf5 &amp;amp; zlib &amp;amp; ncdf
INCFLAGS += -I/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/include
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib
LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
COMP_LIBS += libncdf.a libfdict.a
FPPFLAGS += -DCDF -DNCDF -DNCDF_4

#flook
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib
LIBS += -lflookall -ldl
COMP_LIBS += libfdict.a
FPPFLAGS += -DSIESTA__FLOOK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整的arch.make如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
# Copyright (C) 1996-2016       The SIESTA group
#  This file is distributed under the terms of the
#  GNU General Public License: see COPYING in the top directory
#  or http://www.gnu.org/copyleft/gpl.txt.
# See Docs/Contributors.txt for a list of contributors.
#
#-------------------------------------------------------------------
# arch.make file for gfortran compiler.
# To use this arch.make file you should rename it to
#   arch.make
# or make a sym-link.
# For an explanation of the flags see DOCUMENTED-TEMPLATE.make

.SUFFIXES:
.SUFFIXES: .f .F .o .c .a .f90 .F90

SIESTA_ARCH = unknown

CC = mpicc
FPP = $(FC) -E -P
FC = mpiifort
FC_SERIAL = ifort

FFLAGS = -O2 -fPIC -fp-model source

AR = ar
RANLIB = ranlib

SYS = nag

SP_KIND = 4
DP_KIND = 8
KINDS = $(SP_KIND) $(DP_KIND)

LDFLAGS =

#COMP_LIBS = libsiestaLAPACK.a libsiestaBLAS.a

FPPFLAGS = $(DEFS_PREFIX)-DFC_HAVE_ABORT

#LIBS =
#MPI
MPI_INTERFACE = libmpi_f90.a
MPI_INCLUDE = .
FPPFLAGS += -DMPI

#BLAS &amp;amp; LAPACK &amp;amp; SCALAPACK_LIBS
LDFLAGS += -L/opt/intel/oneapi/mkl/2022.0.2/lib/intel64
#LIBS += -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64 -lmkl_intel_lp64 -lmkl_core -openmp -lmkl_intel_thread
LIBS += -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64

#INCFLAGS += -I/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/include
#LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib
#LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib
#LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib
#LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
#COMP_LIBS += libncdf.a libfdict.a
#FPPFLAGS += -DCDF -DNCDF -DNCDF_4
#LIBS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib -lnetcdff -lnetcdf -lhdf5_fortran -lhdf5 -lz
#COMP_LIBS += libncdf.a libfdict.a
#FPPFLAGS += -DNCDF -DNCDF_4
#FPPFLAGS += -DNCDF_PARALLEL

INCFLAGS += -I/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/include
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/zlib/1.2.11/lib
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/hdf5/1.12.0/lib
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/netcdf/4.7.4/lib
LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
COMP_LIBS += libncdf.a libfdict.a
FPPFLAGS += -DCDF -DNCDF -DNCDF_4



INCFLAGS += -I/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/include
#LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib -Wl,-rpath,/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib
#LIBS += -lflookall -ldl
#COMP_LIBS += libfdict.a
#FPPFLAGS += -DSIESTA__FLOOK
LDFLAGS += -L/home/mccc/download/siesta/siesta-4.1.5/Docs/build/flook/0.8.1/lib
LIBS += -lflookall -ldl
COMP_LIBS += libfdict.a
FPPFLAGS += -DSIESTA__FLOOK



#NetCDF &amp;amp; fdict &amp;amp; hdf5 &amp;amp; zlib &amp;amp; ncdf
#INCFLAGS += -I/opt/lib/netcdf/4.7.4/include
#LDFLAGS += -L/opt/lib/zlib/1.2.11/lib -Wl,-rpath,/opt/lib/zlib/1.2.11/lib
#LDFLAGS += -L/opt/lib/hdf5/1.12.0/lib -Wl,-rpath,/opt/lib/hdf5/1.12.0/lib
#LDFLAGS += -L/opt/lib/netcdf/4.7.4/lib -Wl,-rpath,/opt/lib/netcdf/4.7.4/lib
#LIBS += -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz
#COMP_LIBS += libncdf.a libfdict.a
#FPPFLAGS += -DCDF -DNCDF -DNCDF_4

#flook
#INCFLAGS += -I/opt/lib/flook/0.8.1/include
#LDFLAGS += -L/opt/lib/flook/0.8.1/lib -Wl,-rpath,/opt/lib/flook/0.8.1/lib
#LIBS += -lflookall -ldl
#COMP_LIBS += libfdict.a
#FPPFLAGS += -DSIESTA__FLOOK

# Dependency rules ---------

FFLAGS_DEBUG = -g -O1 -fp-model source   # your appropriate flags here...

# The atom.f code is very vulnerable. Particularly the Intel compiler
# will make an erroneous compilation of atom.f with high optimization
# levels.
atom.o: atom.F
        $(FC) -c $(FFLAGS_DEBUG) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F) $&amp;lt;
state_analysis.o: state_analysis.F
        $(FC) -c $(FFLAGS_DEBUG) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F) $&amp;lt;

.c.o:
        $(CC) -c $(CFLAGS) $(INCFLAGS) $(CPPFLAGS) $&amp;lt;
.F.o:
        $(FC) -c $(FFLAGS) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_fixed_F)  $&amp;lt;
.F90.o:
        $(FC) -c $(FFLAGS) $(INCFLAGS) $(FPPFLAGS) $(FPPFLAGS_free_F90) $&amp;lt;
.f.o:
        $(FC) -c $(FFLAGS) $(INCFLAGS) $(FCFLAGS_fixed_f)  $&amp;lt;
.f90.o:
        $(FC) -c $(FFLAGS) $(INCFLAGS) $(FCFLAGS_free_f90)  $&amp;lt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;br&gt;
在&lt;code&gt;siesta-4.1.5/Obj&lt;/code&gt;文件夹下&lt;br&gt;
执行&lt;code&gt;make&lt;/code&gt;&lt;br&gt;
这里可以获得&lt;code&gt;siesta&lt;/code&gt;执行文件&lt;br&gt;
该目录运行&lt;code&gt;./siesta&lt;/code&gt;&lt;br&gt;
输出内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Siesta Version  : 4.1.5
Architecture    : ubuntu-intel-oneapi
Compiler version: ifort (IFORT) 2021.5.0 20211109
Compiler flags  : mpiifort -O2 -fPIC -fp-model source
PP flags        : -DFC_HAVE_ABORT -DMPI -DCDF -DNCDF -DNCDF_4 -DSIESTA__FLOOK
Libraries       : libncdf.a libfdict.a libfdict.a -lmkl_intel_lp64 -lmkl_sequential -lmkl_core  -lpthread -lmkl_blacs_intelmpi_lp64 -lmkl_scalapack_lp64 -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz -lflookall -ldl
PARALLEL version
NetCDF support
NetCDF-4 support
Lua support

* Running in serial mode with MPI
&amp;gt;&amp;gt; Start of run:   8-MAY-2023   9:33:51

                           ***********************
                           *  WELCOME TO SIESTA  *
                           ***********************

reinit: Reading from standard input
reinit: Dumped input in INPUT_TMP.93044
************************** Dump of input data file ****************************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择执行如下内容(4.1.5版本的siesta已经包含transiesta)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接执行`make transiesta`会报错需要先
执行 `make clean-transiesta`
然后运行`make transiesta`
这里可以获得`transiesta`执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;code&gt;cd siesta-4.1.5/Util/TS/TBtrans&lt;/code&gt;&lt;br&gt;
这里直接执行&lt;code&gt;make&lt;/code&gt;&lt;br&gt;
获得&lt;code&gt;TBtrans&lt;/code&gt;执行文件&lt;br&gt;
在siesta-4.1.5文件夹下新建文件夹bin&lt;br&gt;
&lt;code&gt;cd siesta-4.1.5&lt;/code&gt;&lt;br&gt;
&lt;code&gt;mkdir bin&lt;/code&gt;&lt;br&gt;
将&lt;code&gt;siesta&lt;/code&gt;，&lt;code&gt;transiesta&lt;/code&gt;，&lt;code&gt;TBtrans&lt;/code&gt;拷贝到bin文件夹下&lt;br&gt;
在&lt;code&gt;~/.bashrc&lt;/code&gt; 中添加&lt;br&gt;
&lt;code&gt;export PATH=:XXX/siesta-4.1.5/bin:$PATH&lt;/code&gt;&lt;br&gt;
参考地址：&lt;br&gt;
&lt;a href=&#34;http://blog.chinaunix.net/uid-20339569-id-5846483.html&#34;&gt;CentOS7+ifort14+mkl+mpich2环境下编译并行SIESTA-4.1.5&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.pseudo-dojo.org/index.html&#34;&gt;psml格式赝势库&lt;/a&gt;&lt;/p&gt;
">ubuntu 20.04 Intel Oneapi 编译 siesta-4.1.5</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/intel-oneapi-bian-yi-quantum-espresso-72/"" data-c="
          &lt;p&gt;Quantum ESPRESSO使用基于Intel Oneapi编译。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-ubuntu安装intel-oneapi-base-hpc-toolkit&#34;&gt;1. Ubuntu安装Intel® oneAPI Base &amp;amp; HPC Toolkit&lt;/h1&gt;
&lt;p&gt;基础版和HPC版都是免费的&lt;/p&gt;
&lt;h2 id=&#34;11-下载&#34;&gt;1.1. 下载&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/tools/oneapi/base-toolkit-download.html&#34;&gt;Download the Intel® oneAPI Base Toolkit&lt;/a&gt;页面，选择 Linux-网络和本地-脱机，并下载l_BaseKit_p_2021.4.0.3422_offline.sh文件。&lt;br&gt;
在&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/tools/oneapi/hpc-toolkit-download.html&#34;&gt;Download the Intel® oneAPI HPC Toolkit&lt;/a&gt;页面，选择 Linux-网络和本地-脱机，并下载l_HPCKit_p_2021.4.0.3347_offline.sh文件。&lt;/p&gt;
&lt;h2 id=&#34;12-安装&#34;&gt;1.2. 安装&lt;/h2&gt;
&lt;p&gt;cd进入，ls查看，而后安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sh l_BaseKit_p_xxxx.x.x.xxxx_offline.sh
sudo sh l_HPCKit_p_xxxx.x.x.xxxx_offline.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择合适的安装路径：By default, &amp;lt;install_dir&amp;gt; is:&lt;br&gt;
For root installations: /opt/intel/oneapi&lt;br&gt;
For non-root installations: $HOME/intel&lt;/p&gt;
&lt;h2 id=&#34;13-调用&#34;&gt;1.3. 调用&lt;/h2&gt;
&lt;p&gt;修改bashrc&lt;br&gt;
&lt;code&gt;vim ~/.bashrc&lt;/code&gt;&lt;br&gt;
添加如下&lt;br&gt;
&lt;code&gt;source /opt/intel/oneapi/setvars.sh intel64&lt;/code&gt;&lt;br&gt;
输出文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bashrc 
 
:: initializing oneAPI environment ...
   bash: BASH_VERSION = 5.0.17(1)-release
:: advisor -- latest
:: ccl -- latest
:: clck -- latest
:: compiler -- latest
:: dal -- latest
:: debugger -- latest
:: dev-utilities -- latest
:: dnnl -- latest
:: dpcpp-ct -- latest
:: dpl -- latest
:: inspector -- latest
:: intelpython -- latest
:: ipp -- latest
:: ippcp -- latest
:: ipp -- latest
:: itac -- latest
:: mkl -- latest
:: mpi -- latest
:: tbb -- latest
:: vpl -- latest
:: vtune -- latest
:: oneAPI environment initialized ::
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证是否调用成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ifort -V
Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.4.0 Build 20210910_000000
Copyright (C) 1985-2021 Intel Corporation.  All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-编译qe&#34;&gt;2 编译QE&lt;/h1&gt;
&lt;p&gt;官网下载QE安装包：&lt;a href=&#34;https://www.quantum-espresso.org/download-page/&#34;&gt;quantum-espresso&lt;/a&gt;&lt;br&gt;
tar -zxvf qe-7.2-ReleasePack.tar.gz&lt;br&gt;
解压安装包，QE如果将intel放入bashrc文件中，QE可以识别编译器。这里可以直接运行&lt;br&gt;
./configure&lt;br&gt;
配置成功后修改库文件&lt;br&gt;
vim make.inc&lt;br&gt;
检查是否使用intel编译器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MPIF90         = mpiifort
F90           = ifort
CC             = icc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据&lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-link-line-advisor.html#gs.vq9ljy&#34;&gt;intel动态链接库&lt;/a&gt;修改BLAS_LIBS，LAPACK_LIBS，SCALAPACK_LIBS&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1682394948598.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我这里BLAS_LIBS自动识别为&lt;code&gt;BLAS_LIBS      =   -lmkl_intel_lp64  -lmkl_sequential -lmkl_core&lt;/code&gt;&lt;br&gt;
修改LPACK_LIBS为&lt;code&gt;LAPACK_LIBS = -lmkl_blacs_intelmpi_lp64  -lpthread&lt;/code&gt;&lt;br&gt;
修改SCALPACK_LIBS为&lt;code&gt;SCALAPACK_LIBS = -lmkl_scalapack_lp64&lt;/code&gt;&lt;br&gt;
这里FFT_LIBS官方给的注释为 nothing needed here if the the internal copy of FFTW is compiled我们不做修改为空&lt;br&gt;
MPI_LIBS内容的注释为MPI libraries (should not be needed)我们依然不做修改&lt;br&gt;
最终make.inc文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# make.inc.  Generated from make.inc.in by configure.

# compilation rules

.SUFFIXES :
.SUFFIXES : .o .c .f90 .h .fh

# most fortran compilers can directly preprocess c-like directives: use
#       $(MPIF90) $(F90FLAGS) -c $&amp;lt;
# if explicit preprocessing by the C preprocessor is needed, use:
#       $(CPP) $(CPPFLAGS) $&amp;lt; -o $*.F90
#       $(MPIF90) $(F90FLAGS) -c $*.F90 -o $*.o
# remember the tabulator in the first column !!!

.f90.o:
        $(MPIF90) $(F90FLAGS) -c $&amp;lt;

.c.o:
        $(CC) $(CFLAGS)  -c $&amp;lt;

.h.fh:
        $(CPP) $(CPPFLAGS) $&amp;lt; -o $*.fh



# Top QE directory, useful for locating libraries,  linking QE with plugins
# The following syntax should always point to TOPDIR:
TOPDIR = $(dir $(abspath $(filter %make.inc,$(MAKEFILE_LIST))))
# if it doesn&#39;t work, uncomment the following line (edit if needed):

# TOPDIR = /home/lsl/software/quantum-espresso/qe-7.2

# DFLAGS  = precompilation options (possible arguments to -D and -U)
#           used by the C compiler and preprocessor
# To use libxc (v&amp;gt;=4.3.0), add -D__LIBXC to DFLAGS
# See include/defs.h.README for a list of options and their meaning
# With the exception of IBM xlf, FDFLAGS = $(DFLAGS)
# For IBM xlf, FDFLAGS is the same as DFLAGS with separating commas

# MANUAL_DFLAGS  = additional precompilation option(s), if desired
#                  BEWARE: it does not work for IBM xlf! Manually edit FDFLAGS
MANUAL_DFLAGS  =
DFLAGS         =  -D__DFTI -D__MPI
FDFLAGS        = $(DFLAGS) $(MANUAL_DFLAGS)

# IFLAGS = how to locate directories with *.h or *.f90 file to be included
#          typically -I$(TOPDIR)/include -I/some/other/directory/
#          the latter contains .e.g. files needed by FFT libraries
# for libxc add -I/path/to/libxc/include/

IFLAGS         = -I. -I$(TOPDIR)/include -I/opt/intel/oneapi/mkl/2022.0.2/include

# MOD_FLAG = flag used by f90 compiler to locate modules

MOD_FLAG      = -I

# BASEMOD_FLAGS points to directories containing basic modules,
# while BASEMODS points to the corresponding module libraries.
# More package-specific directories can be added in each Makefile
# and stored into MODFLAGS, and the same for module libraries in QEMODS

BASEMOD_FLAGS= $(MOD_FLAG)$(TOPDIR)/upflib \
               $(MOD_FLAG)$(TOPDIR)/XClib \
               $(MOD_FLAG)$(TOPDIR)/Modules \
               $(MOD_FLAG)$(TOPDIR)/FFTXlib/src \
               $(MOD_FLAG)$(TOPDIR)/LAXlib \
               $(MOD_FLAG)$(TOPDIR)/UtilXlib \
               $(MOD_FLAG)$(TOPDIR)/MBD \
               $(MOD_FLAG)$(TOPDIR)/KS_Solvers $(FOX_MOD)

# If A depends upon B, A should come before B in the list below
# (most compilers don&#39;t care but some don&#39;t resolve cross links)
BASEMODS= $(TOPDIR)/Modules/libqemod.a \
          $(TOPDIR)/upflib/libupf.a \
          $(TOPDIR)/XClib/xc_lib.a \
          $(TOPDIR)/FFTXlib/src/libqefft.a \
          $(TOPDIR)/LAXlib/libqela.a \
          $(TOPDIR)/UtilXlib/libutil.a \
          $(TOPDIR)/MBD/libmbd.a

# Compilers: fortran-90, fortran-77, C
# If a parallel compilation is desired, MPIF90 should be a fortran-90
# compiler that produces executables for parallel execution using MPI
# (such as for instance mpif90, mpf90, mpxlf90,...);
# otherwise, an ordinary fortran-90 compiler (f90, g95, xlf90, ifort,...)

MPIF90         = mpiifort
F90           = ifort
CC             = icc

# GPU architecture (Kepler: 35, Pascal: 60, Volta: 70 )
GPU_ARCH=

# CUDA runtime (Pascal: 8.0, Volta: 9.0)
CUDA_RUNTIME=

# CUDA F90 Flags
CUDA_F90FLAGS= $(MOD_FLAG)$(TOPDIR)/external/devxlib/src

# CUDA C Flags
CUDA_CFLAGS=

# C preprocessor and preprocessing flags - for explicit preprocessing,
# if needed (see the compilation rules above)
# preprocessing flags must include DFLAGS and IFLAGS

CPP            = cpp
CPPFLAGS       = -P -traditional -Uvector $(DFLAGS) $(IFLAGS)

# compiler flags: C, F90
# C flags must include DFLAGS and IFLAGS
# F90 flags must include MODFLAGS, IFLAGS, and FDFLAGS with appropriate syntax

CFLAGS         = -O3 $(DFLAGS) $(IFLAGS) $(CUDA_CFLAGS)
F90FLAGS       = $(FFLAGS) -nomodule -fpp -allow nofpp_comments $(FDFLAGS) $(CUDA_F90FLAGS) $(IFLAGS) $(MODFLAGS)

# compiler flags with and without optimization for fortran-77
# the latter is NEEDED to properly compile dlamch.f, used by lapack
FFLAGS         = -O2 -assume byterecl -g -traceback
FFLAGS_NOOPT   = -O0 -assume byterecl -g -traceback

# compiler flag needed by some compilers when the main program is not fortran
# Currently used for Yambo

FFLAGS_NOMAIN   = -nofor_main

# Linker, linker-specific flags (if any)
# Typically LD coincides with F90 or MPIF90, LD_LIBS is empty
# for libxc, set LD_LIBS=-L/path/to/libxc/lib/ -lxcf03 -lxc
# If libxc release is 5.0.0 replace -lxcf03 with -lxcf90

LD             = mpiifort
LDFLAGS        =
LD_LIBS        =

# External Libraries (if any) : blas, lapack, fft, MPI

# If you have nothing better, use the local copy
# BLAS_LIBS = $(TOPDIR)/external/lapack/libblas.a

BLAS_LIBS      =   -lmkl_intel_lp64  -lmkl_sequential -lmkl_core

# If you have nothing better, use the local copy
# LAPACK = liblapack
# LAPACK_LIBS = $(TOPDIR)/external/lapack/liblapack.a

LAPACK      =
LAPACK_LIBS = -lmkl_blacs_intelmpi_lp64  -lpthread

SCALAPACK_LIBS = -lmkl_scalapack_lp64

# nothing needed here if the the internal copy of FFTW is compiled
# (needs -D__FFTW in DFLAGS)

FFT_LIBS       =

# HDF5
HDF5_LIBS =

# FOX
FOX      =
FOX_MOD  =
FOX_LIB  =
FOX_FLAGS =

# ENVIRON
ENVIRON_LIBS =

# MPI libraries (should not be needed)

MPI_LIBS       =

# IBM-specific: MASS libraries, if available and if -D__MASS is defined in FDFLAGS

MASS_LIBS      =

# CUDA libraries
CUDA_LIBS= -L$(TOPDIR)/external/devxlib/src -ldevXlib
CUDA_EXTLIBS = devxlib

# ar command and flags - for most architectures: AR = ar, ARFLAGS = ruv

AR             = ar
ARFLAGS        = ruv

# ranlib command. If ranlib is not needed (it isn&#39;t in most cases) use
# RANLIB = echo

RANLIB         = ranlib

# all internal and external libraries - do not modify

FLIB_TARGETS   = all

LIBXC_LIBS     =
QELIBS         = $(LIBXC_LIBS) \
                 $(CUDA_LIBS) $(SCALAPACK_LIBS) $(LAPACK_LIBS) $(FOX_LIB) \
                                 $(FFT_LIBS) $(BLAS_LIBS) $(MPI_LIBS) $(MASS_LIBS) $(HDF5_LIBS) \
                                 $(ENVIRON_LIBS) $(LD_LIBS)

# wget or curl - useful to download from network
WGET = wget -O

# Install directory - &amp;quot;make install&amp;quot; copies *.x executables there
PREFIX = /usr/local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;make all&lt;/code&gt;安装QE&lt;br&gt;
安装成功后将QE添加到bashrc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Quantum Espresso
export PATH=/home/lsl/software/quantum-espresso/qe-7.2/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-测试qe&#34;&gt;3 测试QE&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;cd test-suite&lt;/code&gt;&lt;br&gt;
通过&lt;code&gt;make run-test&lt;/code&gt;测试所有内容&lt;br&gt;
或者通过&lt;code&gt;make run-test&lt;/code&gt;Tab按键查看想要测试的内容，例如&lt;code&gt;make run-tests-pw-parallel&lt;/code&gt;&lt;br&gt;
附录几个会用到的参考链接：&lt;br&gt;
ntel动态链接库：&lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-link-line-advisor.html#gs.vq9ljy&#34;&gt;Intel® oneAPI Math Kernel Library Link Line Advisor&lt;/a&gt;&lt;br&gt;
QE配置: &lt;a href=&#34;https://www.quantum-espresso.org/Doc/user_guide/node11.html&#34;&gt;Building Quantum ESPRESSO with make&lt;/a&gt;&lt;br&gt;
赝势文件：&lt;a href=&#34;https://www.materialscloud.org/discover/sssp/table/efficiency#sssp-license&#34;&gt;Standard solid-state pseudopotentials (SSSP)&lt;/a&gt;&lt;br&gt;
Quantum ESPRESSO理论计算课: &lt;a href=&#34;https://www.bilibili.com/video/BV12q4y1o7K3?p=2&amp;amp;vd_source=d1ee00ea8d763f289a421e68b278201e&#34;&gt;bilibili-42节Quantum Espresso理论计算课&lt;/a&gt;&lt;br&gt;
Quantum ESPRESSO 教程：&lt;a href=&#34;https://www.bilibili.com/video/BV1d4411r7c2?p=1&amp;amp;vd_source=d1ee00ea8d763f289a421e68b278201e&#34;&gt;Quantum ESPRESSO理论课&lt;/a&gt;&lt;/p&gt;
">Intel Oneapi编译Quantum ESPRESSO 7.2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu2004-an-zhuang-dan-ji-ban-slurmyou-jian-tong-zhi/"" data-c="
          &lt;p&gt;Slurm作业调度系统搭配s-nail实现作业启动以及运行完成邮件通知&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-安装和配置slurm&#34;&gt;1. 安装和配置Slurm&lt;/h1&gt;
&lt;h2 id=&#34;11安装&#34;&gt;1.1安装&lt;/h2&gt;
&lt;p&gt;使用Mobaxterm软件等终端，获取root用户权限，安装slurm软件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo su
sudo apt install slurm-wlm slurm-wlm-doc -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;slurmd --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;终端显示slurm-wlm 19.05.5&lt;/p&gt;
&lt;h2 id=&#34;12配置slurm&#34;&gt;1.2配置Slurm&lt;/h2&gt;
&lt;p&gt;配置文件在&lt;code&gt;/etc/slurm-llnl/&lt;/code&gt;下面；新建文件&lt;code&gt;slurm.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/slurm-llnl/slurm.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑slurm.conf文件；有点儿长但是修改的地方不多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClusterName=cool
ControlMachine=mcccnode1
#ControlAddr=
#BackupController=
#BackupAddr=
#
MailProg=/usr/bin/s-nail
SlurmUser=root
#SlurmdUser=root
SlurmctldPort=6817

SlurmdPort=6818
AuthType=auth/munge
#JobCredentialPrivateKey=
#JobCredentialPublicCertificate=
StateSaveLocation=/var/spool/slurmctld
SlurmdSpoolDir=/var/spool/slurmd
SwitchType=switch/none
MpiDefault=none
SlurmctldPidFile=/var/run/slurmctld.pid
SlurmdPidFile=/var/run/slurmd.pid
ProctrackType=proctrack/pgid
#PluginDir=
#FirstJobId=
ReturnToService=0
#MaxJobCount=
#PlugStackConfig=
#PropagatePrioProcess=
#PropagateResourceLimits=
#PropagateResourceLimitsExcept=
#Prolog=
#Epilog=
#SrunProlog=
#SrunEpilog=
#TaskProlog=
#TaskEpilog=
#TaskPlugin=
#TrackWCKey=no
#TreeWidth=50
#TmpFS=
#UsePAM=
#
# TIMERS
SlurmctldTimeout=300
SlurmdTimeout=300
InactiveLimit=0
MinJobAge=300
KillWait=30
Waittime=0
#
# SCHEDULING
SchedulerType=sched/backfill
#SchedulerAuth=

#SelectType=select/cons_tres
SelectType=select/cons_res
SelectTypeParameters=CR_Core
#SelectType=CR_CPU


#PriorityType=priority/multifactor
#PriorityDecayHalfLife=14-0
#PriorityUsageResetPeriod=14-0
#PriorityWeightFairshare=100000
#PriorityWeightAge=1000
#PriorityWeightPartition=10000
#PriorityWeightJobSize=1000
#PriorityMaxAge=1-0
#
# LOGGING

SlurmctldDebug=info
SlurmctldLogFile=/var/log/slurm-llnl/slurmctld.log
SlurmdDebug=info
SlurmdLogFile=/var/log/slurm-llnl/slurmd.log
JobCompType=jobcomp/none
#JobCompLoc=
#
# ACCOUNTING
#JobAcctGatherType=jobacct_gather/linux
#JobAcctGatherFrequency=30
#
#AccountingStorageType=accounting_storage/slurmdbd
#AccountingStorageHost=
#AccountingStorageLoc=
#AccountingStoragePass=
#AccountingStorageUser=
#
# COMPUTE NODES
GresTypes=gpu
PartitionName=mcccnode1 Nodes=mcccnode1 Default=NO MaxTime=INFINITE State=UP
#NodeName=mcccnode1 State=UNKNOWN
NodeName=mcccnode1 Sockets=2 CoresPerSocket=32 ThreadsPerCore=1 Gres=gpu:2 State=UNKNOWN

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中需要修改的地方：&lt;/p&gt;
&lt;p&gt;ControlMachine=&lt;font color=#FF0000 &gt;master&lt;/font&gt;&lt;br&gt;
PartitionName=&lt;font color=#FF0000 &gt;master&lt;/font&gt; Nodes=&lt;font color=#FF0000 &gt;master&lt;/font&gt; Default=NO MaxTime=INFINITE State=UP&lt;br&gt;
#NodeName=&lt;font color=#FF0000 &gt;master&lt;/font&gt; State=UNKNOWN&lt;br&gt;
NodeName=&lt;font color=#FF0000 &gt;master&lt;/font&gt; Sockets=&lt;font color=#008000 &gt;2&lt;/font&gt; CoresPerSocket=&lt;font color=#008000 &gt;16&lt;/font&gt; ThreadsPerCore=&lt;font color=#008000 &gt;1&lt;/font&gt; State=UNKNOWN&lt;/p&gt;
&lt;p&gt;&lt;font color=#FF0000 &gt;红色部分修改为hostname：&lt;/font&gt;&lt;br&gt;
终端通过命令&lt;code&gt;hostname&lt;/code&gt;得到的结果&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000 &gt;绿色部分修改：&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Gres=gpu:2&lt;/code&gt; 这里本机有两个GPU用来计算所以数目为2；这个内容可以删除不影响CPU使用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GresTypes=gpu&lt;/code&gt;添加支持GPU必备，同理这个内容删除不影响CPU使用；&lt;/li&gt;
&lt;li&gt;运行GPU任务还需要再slurm.conf相同目录下新建gres.conf文件，其中hostname和CPU中内容相同，内容如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;NodeName=hostname Name=gpu File=/dev/nvidia-caps/nvidia-cap1
NodeName=hostname Name=gpu File=/dev/nvidia-caps/nvidia-cap2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;这里的内容允许单节点运行多个任务，例如一共有20个核心，可以提交5个运行4核心的任务；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;SelectType=select/cons_res 
SelectTypeParameters=CR_Core
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Sockets&lt;/strong&gt; 代表你服务器cpu的个数如果是通常情况普通电脑为1，双路服务器的为2；4路服务器的为4；&lt;br&gt;
查看CPU个数的命令：&lt;code&gt;cat /proc/cpuinfo| grep &amp;quot;physical id&amp;quot;| sort| uniq| wc -l&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CoresPerSocket&lt;/strong&gt;代表每个cpu的核数，&lt;br&gt;
查看CPU核数的命令：&lt;code&gt;cat /proc/cpuinfo| grep &amp;quot;cpu cores&amp;quot;| uniq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ThreadsPerCore&lt;/strong&gt;代表是否开启超线程；如果开启了这个结果为2；没有开启结果为1&lt;br&gt;
测试超线程的脚本：&lt;br&gt;
&lt;code&gt;vim cxc.sh&lt;/code&gt;&lt;br&gt;
添加脚本内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
cpuhx=`cat /proc/cpuinfo | grep &amp;quot;cores&amp;quot; | uniq | awk -F&amp;quot;:&amp;quot; &#39;{print $2}&#39;`
echo &amp;quot;CPU 核心数：$cpuhx&amp;quot; ;
cpuxc=`cat /proc/cpuinfo | grep &amp;quot;processor&amp;quot; | wc -l`
echo &amp;quot;CPU 线程数：$cpuxc&amp;quot; ;
echo &amp;quot;如果线程数是核心数的两倍，为开启了超线程&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=#FF0000 &gt;&lt;strong&gt;如果是双路服务器关闭超线程情况下得到结果如果是两倍就没有开启超线程如果是4倍才是开启了超线程！！！&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-启动slurm&#34;&gt;1.3 启动Slurm&lt;/h2&gt;
&lt;p&gt;终端运行以下代码启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl enable slurmctld --now
sudo systemctl enable slurmd --now
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-配置邮件提醒&#34;&gt;2. 配置邮件提醒&lt;/h1&gt;
&lt;h2 id=&#34;21-安装s-nail&#34;&gt;2.1 安装s-nail&lt;/h2&gt;
&lt;p&gt;终端输入&lt;code&gt;sudo apt install s-nail&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-配置s-nail&#34;&gt;2.2 配置s-nail&lt;/h2&gt;
&lt;p&gt;使用vim打开配置文件:&lt;code&gt;vim /etc/s-nail.rc&lt;/code&gt;&lt;br&gt;
s-nail.rc末尾添加一下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set from=&amp;quot;你的qq邮箱&amp;quot;
set smtp=&amp;quot;smtps://smtp.qq.com:465&amp;quot; 
set smtp-auth-user=&amp;quot;你的qq邮箱&amp;quot;
set smtp-auth-password=&amp;quot;qq邮箱授权码&amp;quot; 
set smtp-auth=login
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;amp;id=28&amp;amp;no=1001256&#34;&gt;qq邮箱授权码教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-测试&#34;&gt;2.3 测试&lt;/h2&gt;
&lt;p&gt;在含有vasp文件（INCAR、KPOINTS、POSCAR、POTCAR）的文件夹内新建脚本vasp.slurm&lt;br&gt;
vasp脚本内容：-N为节点数量；-n为提交的核数或者线程数；-J为作业名称；-p为上面提到的hostname；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
#SBATCH -J VASP-m2690
#SBATCH -p mccc-Virtual-Machine
#SBATCH -N 1
#SBATCH -n 24
#SBATCH --mail-user=290462572@qq.com
#SBATCH --mail-type=ALL
mpirun -n 24 vasp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/356415669&#34;&gt;Slurm 作业调度系统使用指南&lt;/a&gt;&lt;br&gt;
查看QQ邮箱是否有邮件提醒&lt;br&gt;
还可以通过&lt;a href=&#34;https://jingyan.baidu.com/article/37bce2be4ef2601002f3a21c.html&#34;&gt;微信添加QQ邮箱提醒&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-配置accounting&#34;&gt;3. 配置accounting&lt;/h1&gt;
&lt;h2 id=&#34;31-修改etcslurmslurmconf文件添加如下信息并重启服务&#34;&gt;3.1 修改etc/slurm/slurm.conf文件添加如下信息并重启服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# ACCOUNTING
AccountingStorageEnforce=1

AccountingStorageType=accounting_storage/filetxt
AccountingStorageLoc=/opt/slurm/acct

JobCompType=jobcomp/filetxt
JobCompLoc=/opt/slurm/jobcomp

JobAcctGatherType=jobacct_gather/linux
JobAcctGatherFrequency=30
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-新建文件夹&#34;&gt;3.2 新建文件夹：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir -p /opt/slurm
sudo chmod -Rf 777 /opt/slurm
cd /opt/slurm
touch acct
touch jobcomp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33-重启服务&#34;&gt;3.3 重启服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart slurmd
sudo systemctl restart slurmctld
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-查看历史作业&#34;&gt;3.4 查看历史作业：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sacct
获取历史作业信息
grep WorkDir /opt/slurm/jobcomp | grep Jobid
获取历史作业工作目录
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-常用slurm命令&#34;&gt;4. 常用Slurm命令&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;scontrol suspend job_id&lt;/code&gt; 可以暂停正在运行的任务，并且停止在当前执行的step上，以便恢复。&lt;br&gt;
&lt;code&gt;scontrol resume job_id&lt;/code&gt;来恢复上述暂停的任务&lt;br&gt;
&lt;code&gt;sbatch vasp.slurm&lt;/code&gt;提交vasp计算任务&lt;br&gt;
&lt;code&gt;sinfo&lt;/code&gt;查看队列信息&lt;br&gt;
&lt;code&gt;squeue&lt;/code&gt;查看作业队列&lt;br&gt;
&lt;code&gt;scancel JOBID&lt;/code&gt;取消作业&lt;br&gt;
&lt;code&gt;sbatch vasp.slurm&lt;/code&gt;提交作业&lt;br&gt;
&lt;code&gt;scontrol show job JOBID&lt;/code&gt;查看作业详细信息&lt;br&gt;
&lt;code&gt;scontrol hold job_list&lt;/code&gt;挂起排队中尚未运行的作业&lt;br&gt;
&lt;code&gt;scontrol release job_list&lt;/code&gt;继续排队被挂起的尚未运行作业&lt;br&gt;
&lt;code&gt;scontrol requeue job_list&lt;/code&gt;重新运行作业&lt;br&gt;
&lt;code&gt;scontrol top job_list&lt;/code&gt;最优先等待运行作业&lt;br&gt;
&lt;code&gt;scontrol wait_job job_id&lt;/code&gt;等待某个作业运行完，一般在脚本中使用&lt;br&gt;
&lt;code&gt;scontrol update SPECIFICATION&lt;/code&gt;更新作业信息&lt;br&gt;
&lt;code&gt;SPECIFICATION&lt;/code&gt;格式为&lt;code&gt;scontaol show job&lt;/code&gt;显示出的，如下面命令将更新作业号为7的作业名&lt;br&gt;
&lt;code&gt;scontrol update JobId=7 JobName=NewJobName&lt;/code&gt;为NewJobName&lt;br&gt;
参考地址：&lt;br&gt;
&lt;a href=&#34;http://bbs.keinsci.com/thread-32750-1-1.html&#34;&gt;Ubuntu20.04 安装单机slurm教程&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/356415669&#34;&gt;Slurm 作业调度系统使用指南&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;amp;id=28&amp;amp;no=1001256&#34;&gt;百度-微信添加QQ邮箱提醒&lt;/a&gt;&lt;/p&gt;
">Ubuntu20.04安装单机版slurm+邮件通知</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu-2004-lts-an-zhuang-docker-yi-ji-quantum-espresso-gnu-ban-ben/"" data-c="
          &lt;p&gt;使用Docker一键安装支持GPU的Quantum Espresso&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;在-ubuntu-上安装-docker-desktop&#34;&gt;在 Ubuntu 上安装 Docker Desktop&lt;/h1&gt;
&lt;h2 id=&#34;卸载其他版本docker&#34;&gt;卸载其他版本docker&lt;/h2&gt;
&lt;p&gt;参考链接：&lt;a href=&#34;https://docs.docker.com/desktop/install/ubuntu/&#34;&gt;在 Ubuntu 上安装 Docker Desktop&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;安装-docker-桌面&#34;&gt;安装 Docker 桌面&lt;/h2&gt;
&lt;p&gt;设置 Docker 的包存储库。参考链接：&lt;a href=&#34;https://docs.docker.com/engine/install/ubuntu/#set-up-the-repository&#34;&gt;Install using the repository: Set up the repository&lt;/a&gt;&lt;br&gt;
验证安装   &lt;code&gt; sudo docker run hello-world&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;普通用户启动问题&#34;&gt;普通用户启动问题：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Nick_666/article/details/80972332&#34;&gt;参考地址1&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# groupadd docker
[root@localhost ~]# groups
root
[root@localhost ~]# usermod -a -G docker simon 
[root@localhost ~]# grep docker /etc/group
dockerroot:x:994:
docker:x:1001:simon
[root@localhost ~]# service docker restart
Redirecting to /bin/systemctl restart docker.service
[root@localhost ~]# sudo simon
[simon@localhost ~]$ docker image ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1912506&#34;&gt;参考地址2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;把普通用户加入到docker组中 
这里的普通用户是huali，组docker在安装docker的时候，就已经添加了，所以只需要执行两个操作即可：
# sudo gpasswd -a $USER docker 
# newgrp docker
将huali用户加入docker组之后，发现使用docker ps或者docker images不会提示权限不足了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nvidia-docker-安装&#34;&gt;nvidia-docker 安装&lt;/h1&gt;
&lt;p&gt;nvidia-docker安装参考链接：&lt;a href=&#34;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker&#34;&gt; nvidia-docker安装指南&lt;/a&gt;&lt;br&gt;
设置默认运行时后，重新启动 Docker 守护程序以完成安装：&lt;br&gt;
&lt;code&gt;sudo systemctl restart docker&lt;/code&gt;&lt;br&gt;
此时，可以通过运行基本 CUDA 容器来测试工作设置：&lt;br&gt;
&lt;code&gt;sudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;docker-拉取镜像速度慢怎么破&#34;&gt;Docker 拉取镜像速度慢怎么破？&lt;/h1&gt;
&lt;p&gt;修改Docker镜像服务器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑 /etc/docker/daemon.json 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;创建配置文件目录
$ sudo mkdir /etc/docker
编辑配置文件，如果文件不存在，以下命令会自动创建。
$ sudo nano /etc/docker/daemon.json
将配置信息粘贴到配置文件中，配置信息为 json 格式，可以根据实际需要设置多个国内的镜像服务器。(第一个为国内镜像地址；第二个大括号内时NVIDIA-docker配置)
{
      &amp;quot;registry-mirrors&amp;quot;: [
                    &amp;quot;https://fy707np5.mirror.aliyuncs.com&amp;quot;,
                    &amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;,
                    &amp;quot;https://hub-mirror.c.163.com&amp;quot;,
                    &amp;quot;https://mirror.baidubce.com&amp;quot;,
                    &amp;quot;https://yxzrazem.mirror.aliyuncs.com&amp;quot;
            ]
},
{   &amp;quot;runtimes&amp;quot;: {
        &amp;quot;nvidia&amp;quot;: {
            &amp;quot;path&amp;quot;: &amp;quot;nvidia-container-runtime&amp;quot;,
            &amp;quot;runtimeArgs&amp;quot;: []
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;重新加载并重启 Docker 服务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl daemon-reload 
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;检查设置是否生效&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo docker info
结果中显示了我们设置的镜像服务器地址，则说明设置已经生效，返回的信息类似下面这样：
 Registry Mirrors:
  https://fy707np5.mirror.aliyuncs.com/
  https://docker.mirrors.ustc.edu.cn/
  https://hub-mirror.c.163.com/
  https://mirror.baidubce.com/
  https://yxzrazem.mirror.aliyuncs.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;quantum-espresso安装&#34;&gt;Quantum ESPRESSO安装&lt;/h1&gt;
&lt;p&gt;根据&lt;a href=&#34;https://catalog.ngc.nvidia.com/orgs/hpc/containers/quantum_espresso&#34;&gt;Quantum ESPRESSO-NGC安装&lt;/a&gt;操作。&lt;br&gt;
注意：&lt;code&gt;export QE_TAG={TAG}&lt;/code&gt;对Quantum Espresso的版本进行指定&lt;/p&gt;
&lt;h1 id=&#34;quantum-espresso脚本&#34;&gt;Quantum ESPRESSO脚本&lt;/h1&gt;
&lt;p&gt;QEtoolkit-2.sh 可以实现快速生成QE输入文件，需要安装Multiwfn，&lt;a href=&#34;http://sobereva.com/multiwfn/&#34;&gt;Multiwfn下载链接&lt;/a&gt;&lt;br&gt;
Quantum ESPRSSO输入文件&lt;a href=&#34;https://www.materialscloud.org/work/tools/qeinputgenerator?structure=tmprcavxfbm.xsf-ase&#34;&gt;在线生成链接&lt;/a&gt;&lt;br&gt;
pwgui可以生成输入文件以及可视化pw.x输入输出文件中的原子结构：&lt;a href=&#34;http://www-k3.ijs.si/kokalj/pwgui/&#34;&gt;下载链接&lt;/a&gt;&lt;br&gt;
XCrySDen是一个晶体和分子结构可视化程序，旨在显示等值面和轮廓，可以叠加在晶体结构上，并以交互方式旋转和操纵。&lt;a href=&#34;http://www.xcrysden.org/&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
">Ubuntu 20.04 LTS安装Docker以及Quantum Espresso-GNU版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/jia-mi-wen-zhang-ce-shi/"" data-c="
          &lt;p&gt;加密测试：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;script language = JavaScript&gt;
 function password() {
    var testV = 1;
    var pass1 = prompt(&#39;please input the password&#39;,&#39;&#39;);
    var passwordforthisarticle = &#34;123&#34;;
    var inputtimemax = 19960319;
    while (testV &lt; inputtimemax) {
    if (!pass1)
    history.go(-1);
    if (pass1 == passwordforthisarticle) {
    break;
    }
    testV+=1;
    var pass1 =
    prompt(&#39;Password error!&#39;);
    }
    if (pass1!= passwordforthisarticle &amp; testV == inputtimemax)  
    history.go(-1);
    return &#34; &#34;;
    }
    document.write(password());
&lt;/script&gt;
&lt;p&gt;给你看见了~~&lt;br&gt;
进阶密码：&lt;a href=&#34;http://www.jshaman.com/#free&#34;&gt;jshaman&lt;/a&gt;&lt;/p&gt;
">加密文章测试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/mccc-shi-yan-shi-yuan-cheng-shi-yong-fu-wu-qi/"" data-c="
          &lt;p&gt;方式1：安装Zerotier分配IP并远程连接，内网穿透不知道公网IP也可以实现异地连接&lt;br&gt;
方式2：通过ddns服务器cloudflare更新设备IP地址到固定域名（自动更新DNS解析到本机IP地址）没有公网IP地址的话只支持内网使用&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;方式1-zerotier&#34;&gt;方式1-zerotier&lt;/h1&gt;
&lt;h2 id=&#34;11-windows&#34;&gt;1.1 Windows:&lt;/h2&gt;
&lt;p&gt;双击ZeroTier One.msi安装，&lt;a href=&#34;https://www.zerotier.com/&#34;&gt;官网&lt;/a&gt;以及&lt;a href=&#34;https://download.zerotier.com/dist/ZeroTier%20One.msi&#34;&gt;安装包下载&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-linux&#34;&gt;1.2 Linux&lt;/h2&gt;
&lt;p&gt;下载ZeroTier One并安装&lt;br&gt;
&lt;code&gt;curl -s https://install.zerotier.com | sudo bash&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-添加网络&#34;&gt;1.3 添加网络&lt;/h2&gt;
&lt;h3 id=&#34;131windows-方式1&#34;&gt;1.3.1Windows-方式1&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;右键单击复制My address&lt;/li&gt;
&lt;li&gt;将10位地址发送给管理员并等待管理员通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;132windows-方式2&#34;&gt;1.3.2Windows-方式2&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;右键然后点击Join Network&lt;/li&gt;
&lt;li&gt;输入号码&lt;code&gt;a0cbf4b62a3bd002&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单击join完成并等待管理员通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;133linux&#34;&gt;1.3.3Linux&lt;/h3&gt;
&lt;p&gt;终端输入：&lt;br&gt;
&lt;code&gt;sudo zerotier-cli join a0cbf4b62a3bd002&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;14连接使用&#34;&gt;1.4连接使用&lt;/h2&gt;
&lt;p&gt;等待ip分配完成后，ubuntu（8370Cx2+3090Tix2）服务器通过ssh连接，windows（5218x2+2080Tix5）server 2019通过远程桌面连接。&lt;/p&gt;
&lt;h2 id=&#34;15连接软件&#34;&gt;1.5连接软件&lt;/h2&gt;
&lt;p&gt;ubuntu远程用的SSH连接：&lt;a href=&#34;https://mobaxterm.mobatek.net/&#34;&gt;mobaxterm&lt;/a&gt;官网，以及&lt;a href=&#34;https://mobaxterm.mobatek.net/download-home-edition.html&#34;&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;方式2-ddns&#34;&gt;方式2-DDNS&lt;/h1&gt;
&lt;p&gt;前期准备：freenom或者其他地方注册的域名；注册Cloudflare用来解析域名到具体IP地址&lt;/p&gt;
&lt;h2 id=&#34;21windows服务器端-被控制端&#34;&gt;2.1Windows（服务器端、被控制端）&lt;/h2&gt;
&lt;h3 id=&#34;下载ddnsexe-configjson-create-taskbat到本地文件夹&#34;&gt;下载ddns.exe、config.json、create-task.bat到本地文件夹&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/LiSonglin-xidian/DDNS&#34;&gt;单击下载&lt;/a&gt;&lt;br&gt;
ddns.exe为二进制版文件其他方式未测试&lt;br&gt;
根据详细配置修改config.json文件为（其中index4为只更新名称为10.170.起始的IP地址到cloudflare域名）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;id&amp;quot;: &amp;quot;cloudflare登陆邮箱&amp;quot;,
    &amp;quot;token&amp;quot;: &amp;quot;cloudflare产生的秘钥&amp;quot;,
    &amp;quot;dns&amp;quot;: &amp;quot;cloudflare&amp;quot;,
    &amp;quot;ipv4&amp;quot;: [&amp;quot;cloudflare中的前置信息.freenom申请的域名&amp;quot;],
    &amp;quot;index4&amp;quot;: &amp;quot;regex:10.170.*&amp;quot;,
    &amp;quot;proxy&amp;quot;: &amp;quot;DIRECT&amp;quot;,
    &amp;quot;debug&amp;quot;: false
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create-task.bat为创建windows定时任务&lt;/p&gt;
&lt;h3 id=&#34;调试测试过程&#34;&gt;调试测试过程：&lt;/h3&gt;
&lt;p&gt;1.在脚本的当前文件夹下运行cmd&lt;br&gt;
2.在cmd窗口中运行./ddns.exe -c config.json&lt;br&gt;
3.查看服务器端是否产生run.log文件&lt;br&gt;
4.控制端使用cmd，对域名进行ping测试&lt;br&gt;
5.测试完成双击运行create-task.bat脚本添加定时任务（推荐右键使用管理员方式运行否则会有cmd弹窗）&lt;/p&gt;
&lt;h2 id=&#34;22linux被控制端服务器端&#34;&gt;2.2linux(被控制端，服务器端)&lt;/h2&gt;
&lt;h3 id=&#34;下载ddns-create-tasksh-configjson文件&#34;&gt;下载ddns、create-task.sh、config.json文件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/LiSonglin-xidian/DDNS&#34;&gt;单击下载&lt;/a&gt;&lt;br&gt;
config.json配置和windows相同&lt;br&gt;
ddns为二进制版文件其他方式未测试&lt;br&gt;
create-task.sh为创建Ubuntu定时任务&lt;/p&gt;
&lt;h3 id=&#34;调试测试过程-2&#34;&gt;调试测试过程：&lt;/h3&gt;
&lt;p&gt;1.在ddns脚本的当前文件夹下打开终端&lt;br&gt;
2.在终端中运行./ddns -c config.json&lt;br&gt;
3.查看当前文件夹下是否产生run.log文件&lt;br&gt;
4.控制端使用cmd等对域名进行ping测试&lt;br&gt;
5.当前用户运行bash create-task.sh  或者root运行：sudo bash create-task.sh&lt;br&gt;
如果没有权限使用chmod a+x create-task.sh后运行&lt;/p&gt;
&lt;h2 id=&#34;23定时清理本地dns缓存本机控制端&#34;&gt;2.3定时清理本地DNS缓存（本机，控制端）&lt;/h2&gt;
&lt;h3 id=&#34;方式1下载create-task-clean-dnsbat到本地文件夹&#34;&gt;方式1：下载create-task-clean-dns.bat到本地文件夹&lt;/h3&gt;
&lt;p&gt;双击create-task-clean-dns.bat创建定时清理dns缓存命令，否则当ip地址在本地不会更新ping 域名只会到缓存的dns的IP地址上。&lt;/p&gt;
&lt;h3 id=&#34;方式2-cmd窗口运行命令&#34;&gt;方式2: cmd窗口运行命令&lt;/h3&gt;
&lt;p&gt;命令：&lt;code&gt;ipconfig /flushdns&lt;/code&gt;&lt;/p&gt;
">MCCC实验室远程使用服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ssh-mi-ma-lian-jie/"" data-c="
          &lt;p&gt;新用户以及添加SSH连接&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;1.&lt;a href=&#34;https://blog.csdn.net/u013187057/article/details/80533249&#34;&gt;添加新用户&lt;/a&gt;&lt;br&gt;
&lt;code&gt;adduser xxx&lt;/code&gt;&lt;br&gt;
设置密码等信息&lt;br&gt;
&lt;code&gt;su xxx&lt;/code&gt;&lt;br&gt;
切换到xxx用户&lt;br&gt;
给用户添加sudo权限：&lt;br&gt;
&lt;code&gt;sudo usermod -a -G sudo xxx&lt;/code&gt;（xxx为新添加的用户名）&lt;br&gt;
修改后的结果可以查看/etc/group，可以看到sudo这一栏中包含xxx&lt;br&gt;
用户删除sudo权限&lt;br&gt;
&lt;code&gt;sudo deluser xxx sudo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.添加ssh连接&lt;br&gt;
修改配置文件/etc/ssh/sshd_config&lt;br&gt;
&lt;code&gt;sudo vim /etc/ssh/sshd_config&lt;/code&gt;&lt;br&gt;
末尾添加&lt;code&gt;AllowUsers master@192.168.0.1 user1 user2 user3 user4 user5&lt;/code&gt;&lt;br&gt;
重启ssh&lt;br&gt;
&lt;code&gt;sudo service sshd restart&lt;/code&gt;&lt;br&gt;
通过常用ssh工具进行连接使用。&lt;/p&gt;
">新建ubuntu用户+SSH密码连接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/gridea-markdown-zi-ti-yan-se/"" data-c="
          &lt;p&gt;文本颜色，字号，背景颜色等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;font face=&amp;quot;微软雅黑&amp;quot; &amp;gt;微软雅黑-想不想该不该&amp;lt;/font&amp;gt;
&amp;lt;font face=&amp;quot;黑体&amp;quot; &amp;gt;黑体-想不想该不该&amp;lt;/font&amp;gt;
&amp;lt;font size=3 &amp;gt;3号字&amp;lt;/font&amp;gt;
&amp;lt;font size=4 &amp;gt;4号字&amp;lt;/font&amp;gt;
&amp;lt;font color=#FF0000 &amp;gt;红色&amp;lt;/font&amp;gt;
&amp;lt;font color=#008000 &amp;gt;绿色&amp;lt;/font&amp;gt;
&amp;lt;font color=#0000FF &amp;gt;蓝色&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font face=&#34;微软雅黑&#34; &gt;微软雅黑-想不想该不该&lt;/font&gt;&lt;br&gt;
&lt;font face=&#34;黑体&#34; &gt;黑体-想不想该不该&lt;/font&gt;&lt;br&gt;
&lt;font size=3 &gt;3号字&lt;/font&gt;&lt;br&gt;
&lt;font size=4 &gt;4号字&lt;/font&gt;&lt;br&gt;
&lt;font color=#FF0000 &gt;红色&lt;/font&gt;&lt;br&gt;
&lt;font color=#008000 &gt;绿色&lt;/font&gt;&lt;br&gt;
&lt;font color=#0000FF &gt;蓝色&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;设置字体为微软雅黑；字号为6；颜色为红色；内容为微软雅黑字体&lt;br&gt;
&lt;code&gt;&amp;lt;font face=&amp;quot;微软雅黑&amp;quot; size=6 color=#FF0000 &amp;gt;微软雅黑字体&amp;lt;/font&amp;gt;&lt;/code&gt;&lt;br&gt;
&lt;font face=&#34;微软雅黑&#34; size=6 color=#FF0000 &gt;微软雅黑字体&lt;/font&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。
&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td bgcolor=orange&amp;gt; 背景色是 1 orange&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;
&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td bgcolor= BlueViolet &amp;gt; 背景色2 BlueViolet &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt; 背景色是 1 orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= BlueViolet &gt; 背景色2 BlueViolet &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
">Gridea-Markdown字体颜色</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/dft-ji-suan-lao-si-ji-xue-xi/"" data-c="
          &lt;p&gt;Bilibili计算老司机DFT学习总结&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1vasp中能量震荡&#34;&gt;1.vasp中能量震荡&lt;/h1&gt;
&lt;p&gt;尽量晶胞和原子坐标分开优化&lt;br&gt;
推荐：先用单点能就散优化晶胞参数，然后使用ISIF=2优化坐标&lt;br&gt;
IBRION=1，如果初始结构较好，使用表现好&lt;br&gt;
IBRION=2，相对慢，但是一般都收敛；可以先用2然后用1&lt;br&gt;
ALGO也会影响这个IBRION；&lt;br&gt;
POTIM；默认取值为0.5；就是离子位置移动的大小；如果初期收敛了可以改小了POTIM；&lt;br&gt;
应该首先检查结构然后检查参数。&lt;/p&gt;
&lt;h1 id=&#34;2是否添加表面极化设置8&#34;&gt;2.是否添加表面极化设置（8）&lt;/h1&gt;
&lt;p&gt;单个电子步能量波动太大，说明波函数没有优化，可以关闭极化后重新计算。&lt;br&gt;
几何优化完毕后添加极化能量差别不大。&lt;/p&gt;
&lt;h1 id=&#34;3超氧自由基13&#34;&gt;3.超氧自由基（13）&lt;/h1&gt;
&lt;p&gt;氧气分子带电（正电负电）&lt;br&gt;
1.体系带负电，因为无法指定具体原子。&lt;br&gt;
2.键长需要按照情况具体大一些。&lt;br&gt;
3.初始磁矩；自旋极化打开；&lt;br&gt;
4.最后看两个氧是否真的带电，带电才是超氧自由基&lt;/p&gt;
&lt;h1 id=&#34;4vasp如何设置收敛参数&#34;&gt;4.vasp如何设置收敛参数&lt;/h1&gt;
&lt;p&gt;电子：EDIFF；步数：NELM&lt;br&gt;
离子：EDIFFG；步数：NSW&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649901840394.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5vasp计算d-band-center&#34;&gt;5.vasp计算d-band center&lt;/h1&gt;
&lt;p&gt;箭头所示相近认为合理&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649904237528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6vasp-dftu是如何设置amix和bmix提高收敛速度&#34;&gt;6.vasp DFT+U是如何设置AMIX和BMIX提高收敛速度&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649909102156.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;7vasp-dftu的u值如何来&#34;&gt;7.vasp DFT+U的U值如何来&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649909212649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;8vasp-dftu的提醒&#34;&gt;8.vasp DFT+U的提醒&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649909333631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;9液固模型&#34;&gt;9.液固模型&lt;/h1&gt;
&lt;p&gt;观察固体界面处的分子排列的界面模型&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649921107731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;10手册&#34;&gt;10.手册&lt;/h1&gt;
&lt;p&gt;键长、热力学、键能&lt;br&gt;
键能数据&lt;br&gt;
键长、无机、有机光谱数据&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649921302024.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;11isym对称性设置&#34;&gt;11.ISYM对称性设置&lt;/h1&gt;
&lt;p&gt;预优化采用默认！！&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649923331009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;12悬挂键的磁矩设置&#34;&gt;12.悬挂键的磁矩设置&lt;/h1&gt;
&lt;p&gt;有多少个悬挂键磁矩设置为多少&lt;br&gt;
低精度的预优化非常重要！！获得较好的电子函数CHGCAR和波函数WAVECAR以及结构；&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649924152755.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;13初始磁矩的猜测与测试&#34;&gt;13.初始磁矩的猜测与测试&lt;/h1&gt;
&lt;p&gt;选用的POTCAR的价电子数&lt;br&gt;
Fe在赝势中有8个电子，与4个N成键，8-4=4个电子，Fe的自旋为0（组成两对） 2（2个配对两个不配对） 4（4个电子完全不配对）&lt;br&gt;
得到磁矩与能量；进而得到基态与激发态的磁矩的关系。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649925102027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;14梯度收敛技术&#34;&gt;14.梯度收敛技术&lt;/h1&gt;
&lt;p&gt;磁矩设置不合理会发生显著变化。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649925429499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;15磁矩测试&#34;&gt;15.磁矩测试&lt;/h1&gt;
&lt;p&gt;预优化查看磁矩设置是否合理，&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649925736310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;16dft-行业黑话&#34;&gt;16.&lt;a href=&#34;https://www.bilibili.com/video/BV1ig411V7Mg/?spm_id_from=pageDriver&#34;&gt;DFT 行业黑话&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Hatree：电子与外场（原子核这个外场）&lt;br&gt;
交换关联泛函&lt;br&gt;
哈密顿作用，针对波函数的作用(能量算符作用到波函数)&lt;br&gt;
哈密顿作用在波函数上对应的能量对波函数的结果&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649927398827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649928098443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;17oszicar-信息&#34;&gt;17.&lt;a href=&#34;https://www.bilibili.com/video/BV1g34y1Q7ah/?spm_id_from=pageDriver&#34;&gt;OSZICAR 信息&lt;/a&gt;&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649928281587.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;18截断能&#34;&gt;18.截断能&lt;/h1&gt;
&lt;p&gt;截断能与傅里叶级数展开实空间到倒空间（倒空间的大小截断能，截断能越大对应于傅里叶级数的n越大，越能表示原函数）的准确度有关即傅里叶级数的n的取值&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1649929743672.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;181截断能测试矫正1&#34;&gt;18.1截断能测试矫正1&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650509509638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;182截断能测试矫正2&#34;&gt;18.2截断能测试矫正2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650509760506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
具体问题吸附能等作为判据&lt;/p&gt;
&lt;h1 id=&#34;19k点问题&#34;&gt;19K点问题&lt;/h1&gt;
&lt;p&gt;k空间采样方法即K点&lt;br&gt;
K空间的周期性采点。以原点为中心的Gamma点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全自动写法&lt;/li&gt;
&lt;li&gt;半自动，Gamma点为中心&lt;/li&gt;
&lt;li&gt;高对称点设置，而不是整个布里渊区；常用来能带色散关系&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650510666489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;20表面悬挂键&#34;&gt;20.表面悬挂键&lt;/h1&gt;
&lt;p&gt;表面能计算看那个表面更稳定（块体内的减去表面现有的就是悬挂键数量）&lt;br&gt;
悬挂键与磁矩之间没有必然联系&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650513897901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
悬挂键与磁矩之间没有必然联系&lt;/p&gt;
&lt;h1 id=&#34;21单团簇稳定性-内聚能&#34;&gt;21.单团簇稳定性-内聚能&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650594754682.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;22团簇在表面载体上的稳定性&#34;&gt;22.团簇在表面载体上的稳定性&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650594887039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;23界面作用-催化剂和载体之间的强作用&#34;&gt;23.界面作用-催化剂和载体之间的强作用&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650597657722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;24表面能初级计算以及换算&#34;&gt;24.表面能初级计算以及换算&lt;/h1&gt;
&lt;p&gt;极性表面必须加极性校正。例如金属氧化物，上下表面不对称，一个是金属端，一个是氧端，就会构成一个垂直表面的偶极矩，这是建模导致的，需要进行偶极校正。&lt;br&gt;
材料的导电性：从有效质量和费米能附近的DOS定性讨论&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650598464885.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;25能带&#34;&gt;25.能带&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650609517708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
宽窗口分布，电子有效质量轻，导电性好&lt;br&gt;
越陡有效质量越小&lt;br&gt;
同一个方法对磁性、结构、能带都计算正确：&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650609966849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
能带与态密度关系&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650610358528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
费米能级处有大量未占据态，一般导电性好，&lt;/p&gt;
&lt;h1 id=&#34;26ibzkpt错误&#34;&gt;26.IBZKPT错误&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;KPOINTS设置时候选用的gamma点使用奇数点，否则回找不到对称点，增加计算时间&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650612366212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;27vasp超算串行运行多个任务&#34;&gt;27.vasp超算串行运行多个任务&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650618114065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;28vasp快速获取优化进展&#34;&gt;28.VASP快速获取优化进展&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;grep TOTEN OUTCAR
电子步一个空格
grep &#39;free energy&#39; OUTCAR
离子步两个空格
grep &#39;free  energy&#39; OUTCAR
单独检查离子步
grep F= OSZICAR
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650618240125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;29vasp的自洽与非自洽&#34;&gt;29.vasp的自洽与非自洽&lt;/h1&gt;
&lt;p&gt;自洽与非自洽都是静态计算，原子坐标都保持不变&lt;br&gt;
非自洽，不优化电子密度，读入CHGCAR直接计算性质（能带DOS等）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650619024440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;30自洽与非自洽态密度区别&#34;&gt;30.自洽与非自洽态密度区别&lt;/h1&gt;
&lt;p&gt;非自洽保持电子分布&lt;br&gt;
自洽后在进行非自洽可以增加精度等设置&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650619418433.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;31能带与非自洽&#34;&gt;31.能带与非自洽&lt;/h1&gt;
&lt;p&gt;能带计算必须先准备好CHGCAR&lt;br&gt;
能带的K点使用了高对称点来计算（特殊点）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1650619557889.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;32表面吸附&#34;&gt;32.表面吸附&lt;/h1&gt;
&lt;p&gt;表面原子配位与悬挂键，上表面为反应表面，通过广义酸碱理论解释&lt;br&gt;
酸（碱）可以接受（给出）电子对的分子、基团或者离子&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1684911885000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
物理吸附与化学吸附的判断不能单单依靠吸附能来判断&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1684911934587.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">计算老司机学习汇总</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu-an-zhuang-intelr-oneapi-base-and-hpc-toolkit-bian-yi-vasp610/"" data-c="
          &lt;p&gt;安装Intel最新免费的oneAPI，安装好后添加环境，配置系统最后安装VASP6.1.0。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-ubuntu安装intel-oneapi-base-hpc-toolkit&#34;&gt;1. Ubuntu安装Intel® oneAPI Base &amp;amp; HPC Toolkit&lt;/h1&gt;
&lt;p&gt;基础版和HPC版都是免费的&lt;/p&gt;
&lt;h2 id=&#34;11-下载&#34;&gt;1.1. 下载&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/tools/oneapi/base-toolkit-download.html&#34;&gt;Download the Intel® oneAPI Base Toolkit&lt;/a&gt;页面，选择 Linux-网络和本地-脱机，并下载l_BaseKit_p_2021.4.0.3422_offline.sh文件。&lt;br&gt;
在&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/tools/oneapi/hpc-toolkit-download.html&#34;&gt;Download the Intel® oneAPI HPC Toolkit&lt;/a&gt;页面，选择 Linux-网络和本地-脱机，并下载l_HPCKit_p_2021.4.0.3347_offline.sh文件。&lt;/p&gt;
&lt;h2 id=&#34;12-安装&#34;&gt;1.2. 安装&lt;/h2&gt;
&lt;p&gt;cd进入，ls查看，而后安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sh l_BaseKit_p_xxxx.x.x.xxxx_offline.sh
sudo sh l_HPCKit_p_xxxx.x.x.xxxx_offline.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择合适的安装路径：By default, &amp;lt;install_dir&amp;gt; is:&lt;br&gt;
For root installations: /opt/intel/oneapi&lt;br&gt;
For non-root installations: $HOME/intel&lt;/p&gt;
&lt;h2 id=&#34;13-调用&#34;&gt;1.3. 调用&lt;/h2&gt;
&lt;p&gt;修改bashrc&lt;br&gt;
&lt;code&gt;gedit ~/.bashrc&lt;/code&gt;&lt;br&gt;
添加如下&lt;br&gt;
&lt;code&gt;source /opt/intel/oneapi/setvars.sh intel64&lt;/code&gt;&lt;br&gt;
输出文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bashrc 
 
:: initializing oneAPI environment ...
   bash: BASH_VERSION = 5.0.17(1)-release
:: advisor -- latest
:: ccl -- latest
:: clck -- latest
:: compiler -- latest
:: dal -- latest
:: debugger -- latest
:: dev-utilities -- latest
:: dnnl -- latest
:: dpcpp-ct -- latest
:: dpl -- latest
:: inspector -- latest
:: intelpython -- latest
:: ipp -- latest
:: ippcp -- latest
:: ipp -- latest
:: itac -- latest
:: mkl -- latest
:: mpi -- latest
:: tbb -- latest
:: vpl -- latest
:: vtune -- latest
:: oneAPI environment initialized ::
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证是否调用成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ifort -V
Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.4.0 Build 20210910_000000
Copyright (C) 1985-2021 Intel Corporation.  All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-配置系统&#34;&gt;1.4. 配置系统&lt;/h2&gt;
&lt;p&gt;To install CMake, pkg-config, and the GNU development tools on your Linux system, open a terminal session and enter the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt -y install cmake pkg-config build-essential
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Verify the installation by displaying the installation location with this command:&lt;br&gt;
&lt;code&gt;which cmake pkg-config make gcc g++&lt;/code&gt;&lt;br&gt;
输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/bin/cmake
/usr/bin/pkg-config
/usr/bin/make
/usr/bin/gcc
/usr/bin/g++
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-vtst&#34;&gt;2. VTST&lt;/h1&gt;
&lt;p&gt;VTST官网上说的非常清楚，这里加一些注意事项。&lt;/p&gt;
&lt;h2 id=&#34;21-首先解压vasp和vtstcode&#34;&gt;2.1. 首先，解压vasp和vtstcode&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://theory.cm.utexas.edu/vtsttools/download.html&#34;&gt;vtst下载&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd到你下载vasp和vtst的地方
$ tar -xvf vasp.6.1.0.tar.gz
$ tar -xvf vtstcode-184
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-复制替换f文件&#34;&gt;2.2. 复制替换.F文件&lt;/h2&gt;
&lt;p&gt;For vasp.6.2.1 you will need vtstcode 4.1 (revision 182). A version of the vtstcode that will work with vasp.6.1.x - vasp.6.2.0 has been saved in the vtstcode6.1 directory.&lt;br&gt;
拷贝vtstcode6.1下的所有文件到VASP6.1.0目录src文件夹下（复制替换）：（The file chain.F is replaced,其余的文件neb.F, dynmat.F, dimer.F, lanczos.F, sd.F, cg.F, qm.F, lbfgs.F, bfgs.F, fire.F, and opt.F直接复制过来。）&lt;/p&gt;
&lt;h2 id=&#34;23-添加参数tsif&#34;&gt;2.3. 添加参数TSIF&lt;/h2&gt;
&lt;p&gt;然后用vim或者nano或者其他其他editor打开main.F文件加入一个参数TSIF。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CALL CHAIN_FORCE(T_INFO%NIONS,DYN%POSION,TOTEN,TIFOR, &amp;amp;
    LATT_CUR%A,LATT_CUR%B,IO%IU6)
# 加入TSIF，变成下面的，注意使用空格
CALL CHAIN_FORCE(T_INFO%NIONS,DYN%POSION,TOTEN,TIFOR, &amp;amp;
    TSIF,LATT_CUR%A,LATT_CUR%B,IO%IU6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vasp6.2还要多改一个地方，具体看官网。&lt;/p&gt;
&lt;h2 id=&#34;24-修改source参数&#34;&gt;2.4. 修改SOURCE参数&lt;/h2&gt;
&lt;p&gt;在VASP6.1.0的src目录里面的.objects文件（隐藏文件）。打开它并在chain.o前插入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bfgs.o dynmat.o instanton.o lbfgs.o sd.o cg.o dimer.o bbm.o \
fire.o lanczos.o neb.o qm.o opt.o \
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加后的效果：&lt;br&gt;
&lt;strong&gt;记得不要用tab，打空格，不然会编译错误。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     elf.o \
     hamil_rot.o \
     bfgs.o dynmat.o instanton.o lbfgs.o sd.o cg.o dimer.o bbm.o \
     fire.o lanczos.o neb.o qm.o opt.o \
     chain.o \
     dyna.o \
     fileio.o \
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-vasp-编译&#34;&gt;3. VASP 编译&lt;/h1&gt;
&lt;h2 id=&#34;31-build-libfftw3xf_intela&#34;&gt;3.1. Build libfftw3xf_intel.a&lt;/h2&gt;
&lt;p&gt;编译参数建议直接阅读README.md文件不需要修改该文件，但是这里参考Intel的&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/articles/technical/building-vasp-with-intel-mkl-and-intel-compilers.html?wapkw=VASP&#34;&gt;Building VASP* with Intel® oneAPI Base and HPC Toolkits&lt;/a&gt;编译libfftw3xf_intel.a（官网描述：This is a highly optimized performance library of fftw that can speed up the fftw part of VASP.&lt;br&gt;
Change directory to Intel® oneAPI Math Kernel Library (oneMKL) fftw3xf library.）&lt;br&gt;
拷贝oneapi目录下的mkl/latest/interfaces/fftw3xf到home路径下否则可能造成编译出错。&lt;br&gt;
Build fftw3xf in the oneMKL directory.&lt;br&gt;
到拷贝后的文件夹下。&lt;br&gt;
&lt;code&gt;make libintel64&lt;/code&gt;&lt;br&gt;
After a successful compilation, libfftw3xf_intel.a will be built in the same directory.&lt;br&gt;
这里需要记住libfftw3xf_intel.a的文件路径。&lt;/p&gt;
&lt;h2 id=&#34;33-building-vasp&#34;&gt;3.3. Building VASP&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cd vasp.6.1.0&lt;/code&gt;&lt;br&gt;
&lt;code&gt;cp arch/makefile.include.linux_intel ./makefile.include&lt;/code&gt;&lt;br&gt;
建议用的makefile.include文件是:&lt;br&gt;
makefile.include.linux_intel （intel编译器，mpi-only版）&lt;br&gt;
或 makefile.include.linux_intel_omp（intel编译器，mpi和openmp混编版）&lt;br&gt;
如果是单节点机器，建议用mpi-only版就行了，&lt;br&gt;
如果是想大规模多节点并行，用mpi和openmp混编版，此时如果在提交任务的时候用-x OMP_NUM_THREADS=1和mpi-only版效果是一样的。（这里我并不确定，请大家指正）&lt;br&gt;
Edit the makefile.linux to link with oneMKL fftw library, such as bellow.&lt;br&gt;
这里将OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o后面添加libfftw3xf_intel.a的文件路径。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o  /opt/intel/oneAPI/2021.2/mkl/latest/interfaces/fftw3xf/libfftw3xf_intel.a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后添加到上一步的makefile.include中，具体位置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BLACS      = -lmkl_blacs_intelmpi_lp64
SCALAPACK  = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS)

# 这里将OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o后面添加libfftw3xf_intel.a的文件路径
OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o /home/mccc/software/mkl/fftw3xf/libfftw3xf_intel.a

INCS       =-I$(MKLROOT)/include/fftw

LLIBS      = $(SCALAPACK) $(LAPACK) $(BLAS)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改FFLAGS：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FFLAGS     = -assume byterecl -w -xHOST
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您在同一平台上构建和运行 VASP，请使用 -xHOST 启用最高可用的 SIMD 指令。&lt;/p&gt;
&lt;p&gt;其他文件默认就行。或者参考&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/articles/technical/building-vasp-with-intel-mkl-and-intel-compilers.html?wapkw=VASP&#34;&gt;Intel网址&lt;/a&gt;确认compiler。&lt;/p&gt;
&lt;h2 id=&#34;34-编译make&#34;&gt;3.4. 编译make&lt;/h2&gt;
&lt;p&gt;到VASP6.1.0文件夹下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make gam
make ncl
make std
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;make all 容易出错但是应该可以使用。&lt;br&gt;
使用&lt;code&gt;ldd bin/vasp_std&lt;/code&gt;检查是否与oneMKL连接；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[vasp.6.2.0]$ ldd bin/vasp_std
        inux-vdso.so.1 =&amp;gt;  (0x00007ffff3bd2000)
        libmkl_intel_lp64.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_intel_lp64.so.1 (0x00002ac6f2a46000)
        libmkl_cdft_core.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_cdft_core.so.1 (0x00002ac6f37ab000)
        libmkl_scalapack_lp64.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_scalapack_lp64.so.1 (0x00002ac6f39d3000)
        libmkl_blacs_intelmpi_lp64.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_blacs_intelmpi_lp64.so.1 (0x00002ac6f42fe000)
        libmkl_sequential.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_sequential.so.1 (0x00002ac6f4544000)
        libmkl_core.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mkl/2021.2.0/lib/intel64/libmkl_core.so.1 (0x00002ac6f6142000)
        libiomp5.so =&amp;gt; /opt/intel/oneAPI/2021.2/compiler/2021.2.0/linux/compiler/lib/intel64_lin/libiomp5.so (0x00002ac6ff6dd000)
        ……
        libmpifort.so.12 =&amp;gt; /opt/intel/oneAPI/2021.2/mpi/2021.2.0//lib/libmpifort.so.12 (0x00002ac6ffdfb000)
        libmpi.so.12 =&amp;gt; /opt/intel/oneAPI/2021.2/mpi/2021.2.0//lib/release/libmpi.so.12 (0x00002ac7001b9000)
        ……
        ……
        libfabric.so.1 =&amp;gt; /opt/intel/oneAPI/2021.2/mpi/2021.2.0//libfabric/lib/libfabric.so.1 (0x00002ac70238d000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;make test&lt;/code&gt;进行测试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 最后就把编译好的vasp改改名字加到envirnment-varialbe里就可以随处call了
mv bin/vasp_std bin/vasp
 
# 打开 ~/.bash 加下面这一句到最后
export PATH=&amp;quot;&amp;lt;path to vasp&amp;gt;/vasp.6.1.0/bin:$PATH&amp;quot;
 
# 重load一下
$ source ~/.bash
 
# 使用vasp
# cd 到你有INCAR KPOINTS POSCAR POTCAR的文件夹, 然后
$ mpirun -np 4 vasp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考网址：&lt;br&gt;
&lt;a href=&#34;https://theory.cm.utexas.edu/vtsttools/installation.html&#34;&gt;VTST Installation&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://bbs.keinsci.com/thread-16191-1-1.html&#34;&gt;vasp.6.1.0 更新介绍/安装/测试&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://codeleading.com/article/22316005302/&#34;&gt;VASP 6.1.0 + VTST + intel新OneAPI 安装编译&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.xiaoledeng.com/2021/11/22/ubuntu-install-intel-oneapi/&#34;&gt;Ubuntu安装Intel® oneAPI Base &amp;amp; HPC Toolkit&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.intel.com/content/www/us/en/develop/documentation/get-started-with-intel-oneapi-hpc-linux/top/before-you-begin.html#before-you-begin&#34;&gt;Get Started with the Intel® oneAPI HPC Toolkit for Linux*&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.intel.cn/content/www/cn/zh/developer/articles/technical/building-vasp-with-intel-mkl-and-intel-compilers.html?wapkw=VASP&#34;&gt;Building VASP* with Intel® oneAPI Base and HPC Toolkits&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.vasp.at/wiki/index.php/Installing_VASP.6.X.X#Requirements&#34;&gt;Installing VASP.6.X.X-vaspwiki&lt;/a&gt;&lt;/p&gt;
">Ubuntu安装Intel® oneAPI Base & HPC Toolkit编译VASP6.1.0+VTST</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/biao-mian-jie-mian-jian-mo-yao-dian-jing-yan-xiao-jie/"" data-c="
          &lt;p&gt;概括性列举出需要考虑的要点并列举一些经验。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;表面和界面的类型进行分析归类：对表面来说，主要包括a). 2d材料的表面模型; b) 3d材料的表面模型。对界面来说，主要包括a). 2d/2d材料的界面模型；b). 2d/3d材料的界面模型；c). 3d/3d材料的界面模型。（注意，3d材料模型是指切面前材料就是3d，切面并在c方向加上真空组成surface slab或者interface slab后，在概念上是属于2d，即只有ab方向是无限延伸）2d材料的表面界面模型比较简单直接，放到最后面来讲。因为界面是由两种材料的surface slab构成，所以可以把表面建模中需要考虑的因素并规到界面建模需要考虑的因素之内。&lt;br&gt;
对于3d材料的界面模型，首先要分两大类：A.有真空，单一界面模型；B.无真空，双界面模型。前者模型从上往下分别为：真空层/材料A/材料B，视情况在B的底端有额外的钝化原子层，即在周期性边界条件下只有一个材料A/材料B的界面；后者从上往下分别为：材料A/材料B，或者材料A/材料B/材料A，无真空无钝化原子层，即在周期性边界条件下有两个材料A/材料B的界面。&lt;/p&gt;
&lt;h1 id=&#34;对a有真空单一界面模型模型包括原子层和真空层-所以要考虑&#34;&gt;对A.有真空单一界面模型，模型包括原子层和真空层。所以要考虑：&lt;/h1&gt;
&lt;h2 id=&#34;1考虑原子层的厚度&#34;&gt;1.考虑原子层的厚度。&lt;/h2&gt;
&lt;p&gt;厚度太薄不足以充分体现出材料的表面性质，厚度太厚是会造成额外的计算资源浪费。合理的模型厚度是指既包括体现表面材料surface性质的原子层，又包括体现体材料bulk性质的原子层。至于如何确定原子层厚度，可以考虑：a. Layer-projected DOS (LDOS)判断, b. 根据averaged potential即功函数判断, c.根据quantum confinement判断，d.根据论文中取几层判断（&lt;a href=&#34;https://pubs.acs.org/doi/10.1021/am507287f&#34;&gt;厚度增加，表面态消失，VBM，CBM能量位置趋于稳定&lt;/a&gt;）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648115154150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
论文HfO2/GaN界面模型为例[&lt;a href=&#34;https://pubs.acs.org/doi/10.1021/am507287f&#34;&gt;1&lt;/a&gt;] 介绍。建立一个很厚的GaN表面slab，然后直接算DOS即可。然后做出每一层的LDOS画在一起，会发现最表面几层原子是存在表面态，以及因为quantum confinement表面几层的bandgap会比较大。随着层数厚度加深会发现surface state消失且VBM CBM的能量位置趋于稳定。所以就可以以趋于稳定的层数来确定一个适合的层数厚度。&lt;br&gt;
一些论文中也有介绍其他的判断方法，包括：&lt;strong&gt;功函数&lt;/strong&gt;判据（建立不同层数的表面模型计算功函数，看看多少层功函数稳定）和&lt;strong&gt;quantum confinement&lt;/strong&gt;判据（PBE会低估Eg，但是因为quantum confinement材料的Eg会变大，会存在某个&lt;strong&gt;层数&lt;/strong&gt;使得算出来的&lt;strong&gt;Eg等于或者接近实验值&lt;/strong&gt;），这里不详细讲解了。&lt;/p&gt;
&lt;h2 id=&#34;2考虑真空层的厚度&#34;&gt;2.考虑真空层的厚度。&lt;/h2&gt;
&lt;p&gt;由于主流的计算软件(VASP CASTEP等) 都是基于周期性边界条件, 所以实际的计算模型在c方向是原子层/真空层/原子层/真空层/…无限重复模型。所以当真空层较薄时候，原子层会跟它的image structure镜像结构存在interaction造成误差；但是真空层太厚又会导致计算量增大。测试真空层厚度常用的方法是averaged potential即功函数方法：做出averaged potential曲线，看真空区域是否是平的。 经验性的数据是：&lt;strong&gt;真空一定不能小于10A，15-20A为宜，20-30A更好&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3考虑终端钝化即bulk-termination&#34;&gt;3.考虑终端钝化即bulk termination。&lt;/h2&gt;
&lt;p&gt;切出来的slab模型通常(注)在最上层和最下层存在悬挂键（dangling bonds, DB）。在表面或者界面处的悬挂键是真实存在的，对他们的不同处理可以反应表面界面的不同属性。但是最下层的悬挂键却不应该存在，因为这部分的原子层在模拟体相bulk properties，所以需要进行合理的钝化处理。最常见的方式是加氢（或者赝氢）钝化，具体方式为：计算出来悬挂键的电子数目N，然后选择2-N个电子的赝氢即可。以III-V为例，可以参考文章[1-3]中均有提及：对于Ga，每一个DB有0.75e，所以需要1.25e的赝氢钝化；对于N，每一个DB有1.25e，所以需要0.75e的赝氢钝化。&lt;br&gt;
&lt;strong&gt;对于加赝氢的位置&lt;/strong&gt;：通常选DB切开之前的键的中点位置加赝氢。&lt;br&gt;
另外，对于离子型金属氧化物，除了加H钝化外，还可以选择均匀去掉半层O来钝化，可以参考[&lt;a href=&#34;https://pubs.acs.org/doi/10.1021/am507287f&#34;&gt;1&lt;/a&gt;]中对HfO2的处理。&lt;br&gt;
注：对non-polar surface（非极性表面）是不存在悬挂键，比如cubic（立方体）材料的 (110)面；2d材料的情况切出来单层也通常没有悬挂键。&lt;/p&gt;
&lt;h2 id=&#34;4切出来晶格匹配lattice-matched表面slab&#34;&gt;4.切出来晶格匹配（lattice matched）表面（slab）。&lt;/h2&gt;
&lt;p&gt;晶格匹配即包括ab晶格常数匹配，也包括ab夹角相等。对于semiconductor/semiconductor or insulator/semiconductor，建议mismatch不要超过5%。对于metal/semiconductor or metal/insulator来说，考虑到金属有较好的延展性，形变并不太会影响金属的性质（比如功函数）所以mismatch tolerance 可以大一些，但是最好不要超过10%。&lt;br&gt;
如何确定matched的界面呢，可以考虑如下的旋转方案：先对模型做很大的扩胞，只看一层原子，找出某个晶格参数下俩surface slab的晶格参数是matched，然后就可以根据根号建模方案切割表面即可。cleave surface的细节可以网上参考前人分享的根号建模经验帖，这里就不展开讲了。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648115546495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另外注意，在拼接界面的时候要确定界面的晶格常数，通常是要选择基底材料（下层材料）的晶格常数做为界面材料的晶格常数，即&lt;strong&gt;保持下层材料晶格常数不变&lt;/strong&gt;，改变上层金属或者介质层的晶格常数，以此来模拟实验中材料生长的细节性质。&lt;/p&gt;
&lt;h2 id=&#34;5初始构型的确定&#34;&gt;5.初始构型的确定。&lt;/h2&gt;
&lt;p&gt;由于界面模型是人工直接build layer产生，界面成键细节不同会很大程度上影响系统总能；对于初始层间距的选择也是如此：合理的初始层间距可以很大的减小计算量。并且，DFT在做结构优化的时候，有可能陷入local energy minimum而不是 global energy minimum。为了尽量找到一个较为合理的初始构型，可以做movement test.&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648115652078.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
论文HfO2/GaN界面模型为例[&lt;a href=&#34;https://pubs.acs.org/doi/10.1021/am507287f&#34;&gt;1&lt;/a&gt;] 介绍。Firstly, fix HfO2 (001) surface, move GaN (001) surface in z direction step by step, perform self-consistently calculation, and find the lowest energy position along z direction (see Figure S5(a)). Starting from the point with lowest energy, move GaN along x-(see Figure S5(c)) and y-(see Figure S5(b)) direction and locate the lowest energy before a full structure relaxation.&lt;br&gt;
（首先，固定HfO2（001）面，逐步沿z方向移动GaN（001）面，进行自洽计算，找到沿z方向的最低能量位置（见图S5（a））。从具有最低能量的点开始，沿 x-（参见图 S5(c)）和 y-（参见图 S5(b)）方向移动 GaN，并在完全结构弛豫之前找到最低能量。）&lt;/p&gt;
&lt;h2 id=&#34;6固定优化&#34;&gt;6.固定优化。&lt;/h2&gt;
&lt;p&gt;这里包括两个固定：&lt;strong&gt;固定晶格常数&lt;/strong&gt;，即不改变晶胞仅优化原子结构；通常选择&lt;strong&gt;固定最底层赝氢（以及靠近赝氢的一层或者几层bulk layers)来更好的模拟bulk properties&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;对b无真空双界面模型模型无真空是由两层界面组成-要考虑&#34;&gt;对B.无真空，双界面模型，模型无真空，是由两层界面组成。要考虑：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;考虑原子层的厚度。基本同A.1。因为模型不包含真空，每一个界面两侧都是原子层，受screening effect的影响，原子层厚度其实可以比单界面模型稍薄一些。但是依然最好先做layer thickness test。&lt;/li&gt;
&lt;li&gt;不需要考虑真空层。由于双界面模型是存在两个完全相同的界面，没有真空层，计算量也就可以略小一些。&lt;/li&gt;
&lt;li&gt;不需要考虑终端钝化即bulk termination。由于双界面模型是存在两个完全相同的界面，一样的bonding characteristics, 所以不存在不合理的悬挂键，不需要考虑终端钝化/悬挂键处理。&lt;/li&gt;
&lt;li&gt;切出来晶格匹配lattice matched表面slab。基本同A4。&lt;/li&gt;
&lt;li&gt;初始构型的确定。基本同A5。&lt;/li&gt;
&lt;li&gt;固定优化。无真空模型，但是因为存在interfacial bonding and interfacial interaction是会造成键长（层间距）改变，所以可以用固定ab方向、开放c方向晶格常数方案来做结构优化。并且固定基底材料的中间原子层即可。&lt;br&gt;
通过以上对比&lt;strong&gt;A.有真空单一界面模型,&lt;/strong&gt;，&lt;strong&gt;B.无真空双界面模型&lt;/strong&gt;的建模要点，可以发现，B.无真空双界面模型计算量可以小一些，但是它要求必须是对称的模型，保证两个界面在建模时候完全相同。所以对于一些材料不适合这个建模方案。&lt;br&gt;
注意：上述内容仅围绕表面界面建模的要点进行描述。对于表面材料，通常在表面存在surface reconstruction（表面重构）；对于界面材料，需要考虑electron counting rule（电子数量）。这些更复杂的考虑是要具体情况具体分析，这里不展开详细描述。关于界面考虑electron counting rule的例子，可以参考论文[&lt;a href=&#34;https://pubs.acs.org/doi/full/10.1021/acsami.8b01286&#34;&gt;2&lt;/a&gt;]以及更多其他的论文[&lt;a href=&#34;https://aip.scitation.org/doi/10.1063/1.5097567&#34;&gt;3&lt;/a&gt;]。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648127325694.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;对于2d材料的表面界面模型&#34;&gt;对于2d材料的表面界面模型，&lt;/h1&gt;
&lt;p&gt;2d材料的表面界面模型，相对来说比较简单，通常来说只需要考虑真空厚度/固定优化即可。&lt;br&gt;
在2d/2d 异质结中，两侧的surface slab就具有很高的对称性。这样的对称性很高的异质结界面材料，如何确定一个合适的初始结构，以MoS2/GaN 2d/3d 异质结[&lt;a href=&#34;https://pubs.acs.org/doi/full/10.1021/acsami.8b01286&#34;&gt;2&lt;/a&gt;]为例讲一下。(虽然体系是2d/3d界面，但是方法是一样的)&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648128105336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
界面两侧的材料本身就具有高对称性，且基本上是以vdW相互作用连接。可以：首先根据高对称性原则，得到几个不同的初始结构（上图的6个type）；然后对每一个type调整其层间距，算静态能量，找到他们的能量最低层间距，即为这个type的最佳初始构型；再从6个最佳初始构型中选择能量最低的来做系统研究即可。&lt;br&gt;
参考博客：&lt;a href=&#34;https://blog.sciencenet.cn/blog-2686986-1175883.html&#34;&gt;zhangfrank的个人博客(张召富)&lt;/a&gt;&lt;br&gt;
[1]. &lt;a href=&#34;https://pubs.acs.org/doi/10.1021/am507287f&#34;&gt;Zhaofu Zhang, et al, ACS Appl. Mater. Interfaces 2015, 7, 5141−5149&lt;/a&gt;&lt;br&gt;
[2]. &lt;a href=&#34;https://pubs.acs.org/doi/full/10.1021/acsami.8b01286&#34;&gt;Zhaofu Zhang, et al, ACS Appl. Mater. Interfaces 2018, 10, 17419−17426&lt;/a&gt;&lt;br&gt;
[3]. &lt;a href=&#34;https://aip.scitation.org/doi/10.1063/1.5097567&#34;&gt;Zhaofu Zhang et al, Appl. Phys. Lett. 2019, 114, 161601&lt;/a&gt;&lt;/p&gt;
">表面界面建模要点/经验小结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/googledrivepoweredbycloud-zai-zotero-bi-ji-zhong-shi-yong-tu-chuang/"" data-c="
          &lt;p&gt;Zotero 6.0版本的笔记使用markdown不方便，图片无法上传云，可以借助图床功能在笔记中使用链接，这样既可以上传Zotero云，又可以在笔记中显示图片。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://poweredby.cloud/&#34;&gt;PoweredBy.cloud&lt;/a&gt;是一个免费图床工具，网页内上传提交后生成链接直接查看。&lt;/p&gt;
&lt;h1 id=&#34;1-打开poweredbycloud官网&#34;&gt;1. 打开&lt;a href=&#34;https://poweredby.cloud/&#34;&gt;PoweredBy.cloud&lt;/a&gt;官网&lt;/h1&gt;
&lt;p&gt;注册过程需要填写邮箱号，然后地址会发送到注册邮箱中&lt;/p&gt;
&lt;h1 id=&#34;2-在poweredbycloud添加site&#34;&gt;2. 在&lt;a href=&#34;https://poweredby.cloud/&#34;&gt;PoweredBy.cloud&lt;/a&gt;添加site&lt;/h1&gt;
&lt;p&gt;site名称不能重复例如：xxxxx.stdcdn.com，选择GoogleDrive或者Onedrive作为存储空间。PoweredBy.cloud会在网盘中创建一个xxxxx.stdcdn.com文件夹用来保存上传的图片。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648104756769.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-上传图片&#34;&gt;3. 上传图片&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648104896746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-复制链接地址&#34;&gt;4. 复制链接地址&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648104972352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;5-将地址拷贝到zotero笔记中即可直接显示图片&#34;&gt;5. 将&lt;a href=&#34;https://lsl-demon.stdcdn.com/%E6%97%A0%E6%A0%87%E9%A2%98.png&#34;&gt;地址&lt;/a&gt;拷贝到Zotero笔记中即可直接显示图片&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1648105038948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">GoogleDrive+PoweredBy.cloud在Zotero笔记中使用图床</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/python-mian-xiang-dui-xiang/"" data-c="
          &lt;p&gt;Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。&lt;br&gt;
如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。&lt;br&gt;
接下来我们先来简单的了解下面向对象的一些基本特征。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;面向对象技术简介&#34;&gt;面向对象技术简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;类(Class)&lt;/strong&gt;:&lt;br&gt;
用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。&lt;br&gt;
&lt;strong&gt;类变量：&lt;/strong&gt;&lt;br&gt;
类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。&lt;br&gt;
&lt;strong&gt;数据成员：&lt;/strong&gt;&lt;br&gt;
类变量或者实例变量, 用于处理类及其实例对象的相关的数据。&lt;br&gt;
&lt;strong&gt;方法重写：&lt;/strong&gt;&lt;br&gt;
如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。&lt;br&gt;
&lt;strong&gt;局部变量：&lt;/strong&gt;&lt;br&gt;
定义在方法中的变量，只作用于当前实例的类。&lt;br&gt;
&lt;strong&gt;实例变量：&lt;/strong&gt;&lt;br&gt;
在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。&lt;br&gt;
&lt;strong&gt;继承：&lt;/strong&gt;&lt;br&gt;
即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&amp;quot;是一个（is-a）&amp;quot;关系（例图，Dog是一个Animal）。&lt;br&gt;
&lt;strong&gt;实例化：&lt;/strong&gt;&lt;br&gt;
创建一个类的实例，类的具体对象。&lt;br&gt;
&lt;strong&gt;方法：&lt;/strong&gt;&lt;br&gt;
类中定义的函数。&lt;br&gt;
&lt;strong&gt;对象：&lt;/strong&gt;&lt;br&gt;
通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。&lt;/p&gt;
&lt;h1 id=&#34;创建类&#34;&gt;创建类&lt;/h1&gt;
&lt;p&gt;使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName:
   &#39;类的帮助信息&#39;   #类文档字符串           #通过ClassName.__doc__查看。
   class_suite  #类体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的帮助信息可以通过&lt;code&gt;ClassName.__doc__&lt;/code&gt;查看。&lt;br&gt;
class_suite 由类成员，方法，数据属性组成。&lt;br&gt;
例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Employee:
   &#39;所有员工的基类&#39;
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount
 
   def displayEmployee(self):
      print &amp;quot;Name : &amp;quot;, self.name,  &amp;quot;, Salary: &amp;quot;, self.salary
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。&lt;br&gt;
第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法&lt;br&gt;
self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。&lt;/p&gt;
&lt;h2 id=&#34;self代表类的实例而非类&#34;&gt;self代表类的实例，而非类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;类的方法&lt;/strong&gt;与&lt;strong&gt;普通的函数&lt;/strong&gt;只有一个特别的区别——它们必须有一个额外的&lt;strong&gt;第一个参数名称&lt;/strong&gt;, 按照&lt;strong&gt;惯例它的名称是 self&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Test:
    def prt(self):
        print(self)
        print(self.__class__)
 
t = Test()
t.prt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;__main__.Test instance at 0x10d066878&amp;gt;
__main__.Test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 &lt;code&gt;self.__class__&lt;/code&gt; 则指向类。self 不是 python 关键字，我们把他换成其他字符也是可以执行的，例如 runoob 也是可以正常执行的:&lt;/p&gt;
&lt;h1 id=&#34;创建实例对象&#34;&gt;创建实例对象&lt;/h1&gt;
&lt;p&gt;实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。&lt;br&gt;
以下使用类的名称 Employee 来实例化，并通过 &lt;code&gt;__init__ &lt;/code&gt;方法接收参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;创建 Employee 类的第一个对象&amp;quot;
emp1 = Employee(&amp;quot;Zara&amp;quot;, 2000)
&amp;quot;创建 Employee 类的第二个对象&amp;quot;
emp2 = Employee(&amp;quot;Manni&amp;quot;, 5000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;访问属性&#34;&gt;访问属性&lt;/h1&gt;
&lt;p&gt;您可以使用点号 &lt;code&gt;.&lt;/code&gt; 来访问对象的属性。使用如下类的名称访问类变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emp1.displayEmployee()
emp2.displayEmployee()
print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class Employee:
   &#39;所有员工的基类&#39;
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount
 
   def displayEmployee(self):
      print &amp;quot;Name : &amp;quot;, self.name,  &amp;quot;, Salary: &amp;quot;, self.salary
 
&amp;quot;创建 Employee 类的第一个对象&amp;quot;
emp1 = Employee(&amp;quot;Zara&amp;quot;, 2000)
&amp;quot;创建 Employee 类的第二个对象&amp;quot;
emp2 = Employee(&amp;quot;Manni&amp;quot;, 5000)
emp1.displayEmployee()  #输出：Name :  Zara ,Salary:  2000
emp2.displayEmployee()  #输出：Name :  Manni ,Salary:  5000
print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount   #输出：Total Employee 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以添加，删除，修改类的属性，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emp1.age = 7  # 添加一个 &#39;age&#39; 属性
emp1.age = 8  # 修改 &#39;age&#39; 属性
del emp1.age  # 删除 &#39;age&#39; 属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以使用以下函数的方式来访问属性：&lt;br&gt;
getattr(obj, name[, default]) : 访问对象的属性。&lt;br&gt;
hasattr(obj,name) : 检查是否存在一个属性。&lt;br&gt;
setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。&lt;br&gt;
delattr(obj, name) : 删除属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getattr(emp1, &#39;age&#39;)    # 返回 &#39;age&#39; 属性的值
hasattr(emp1, &#39;age&#39;)    # 如果存在 &#39;age&#39; 属性返回 True。
setattr(emp1, &#39;age&#39;, 8) # 添加属性 &#39;age&#39; 值为 8
delattr(emp1, &#39;age&#39;)    # 删除属性 &#39;age&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python内置类属性&#34;&gt;Python内置类属性&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;__dict__&lt;/code&gt; : 类的属性（包含一个字典，由类的数据属性组成）&lt;br&gt;
&lt;code&gt;__doc__ &lt;/code&gt;:类的文档字符串&lt;br&gt;
&lt;code&gt;__name__&lt;/code&gt;: 类名&lt;br&gt;
&lt;code&gt;__module__&lt;/code&gt;: 类定义所在的模块（类的全名是&lt;code&gt;&#39;__main__.className&#39;&lt;/code&gt;，如果类位于一个导入模块mymod中，那么&lt;code&gt;className.__module__&lt;/code&gt; 等于 mymod）&lt;br&gt;
&lt;code&gt;__bases__ &lt;/code&gt;: 类的所有父类构成元素（包含了一个由所有父类组成的元组）&lt;br&gt;
Python内置类属性调用实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class Employee:
   &#39;所有员工的基类&#39;
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount
 
   def displayEmployee(self):
      print &amp;quot;Name : &amp;quot;, self.name,  &amp;quot;, Salary: &amp;quot;, self.salary
 
print &amp;quot;Employee.__doc__:&amp;quot;, Employee.__doc__
print &amp;quot;Employee.__name__:&amp;quot;, Employee.__name__
print &amp;quot;Employee.__module__:&amp;quot;, Employee.__module__
print &amp;quot;Employee.__bases__:&amp;quot;, Employee.__bases__
print &amp;quot;Employee.__dict__:&amp;quot;, Employee.__dict__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Employee.__doc__: 所有员工的基类
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: ()
Employee.__dict__: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;displayCount&#39;: &amp;lt;function displayCount at 0x10a939c80&amp;gt;, &#39;empCount&#39;: 0, &#39;displayEmployee&#39;: &amp;lt;function displayEmployee at 0x10a93caa0&amp;gt;, &#39;__doc__&#39;: &#39;\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb&#39;, &#39;__init__&#39;: &amp;lt;function __init__ at 0x10a939578&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python对象销毁垃圾回收&#34;&gt;python对象销毁(垃圾回收)&lt;/h1&gt;
&lt;p&gt;Python 使用了引用计数这一简单技术来跟踪和回收垃圾。&lt;br&gt;
在 Python 内部记录着所有使用中的对象各有多少引用。&lt;br&gt;
一个内部跟踪变量，称为一个引用计数器。&lt;br&gt;
当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&amp;quot;立即&amp;quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 40      # 创建对象  &amp;lt;40&amp;gt;
b = a       # 增加引用， &amp;lt;40&amp;gt; 的计数
c = [b]     # 增加引用.  &amp;lt;40&amp;gt; 的计数

del a       # 减少引用 &amp;lt;40&amp;gt; 的计数
b = 100     # 减少引用 &amp;lt;40&amp;gt; 的计数
c[0] = -1   # 减少引用 &amp;lt;40&amp;gt; 的计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。&lt;/p&gt;
&lt;h1 id=&#34;类的继承&#34;&gt;类的继承&lt;/h1&gt;
&lt;p&gt;面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。&lt;br&gt;
通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。&lt;br&gt;
继承语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class 派生类名(基类名)
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在python中继承中的一些特点：&lt;br&gt;
1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。&lt;br&gt;
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数&lt;br&gt;
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。&lt;br&gt;
如果在继承元组中列了一个以上的类，那么它就被称作&amp;quot;多重继承&amp;quot; 。&lt;br&gt;
语法：&lt;br&gt;
派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SubClassName (ParentClass1[, ParentClass2, ...]):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent:        # 定义父类
   parentAttr = 100
   def __init__(self):
      print &amp;quot;调用父类构造函数&amp;quot;
 
   def parentMethod(self):
      print &#39;调用父类方法&#39;
 
   def setAttr(self, attr):
      Parent.parentAttr = attr
 
   def getAttr(self):
      print &amp;quot;父类属性 :&amp;quot;, Parent.parentAttr
 
class Child(Parent): # 定义子类
   def __init__(self):
      print &amp;quot;调用子类构造方法&amp;quot;
 
   def childMethod(self):
      print &#39;调用子类方法&#39;
 
c = Child()          # 实例化子类           #输出：调用子类构造方法
c.childMethod()      # 调用子类的方法           #输出：调用子类方法
c.parentMethod()     # 调用父类方法         #输出：调用父类方法
c.setAttr(200)       # 再次调用父类的方法 - 设置属性值          #设置父类属性值
c.getAttr()          # 再次调用父类的方法 - 获取属性值          #输出：父类属性 : 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以继承多个类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A:        # 定义类 A
.....
class B:         # 定义类 B
.....
class C(A, B):   # 继承类 A 和 B
.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以使用issubclass()或者isinstance()方法来检测。&lt;br&gt;
issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)&lt;br&gt;
isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。&lt;/p&gt;
&lt;h1 id=&#34;方法重写&#34;&gt;方法重写&lt;/h1&gt;
&lt;p&gt;如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：&lt;br&gt;
实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent:        # 定义父类
   def myMethod(self):
      print &#39;调用父类方法&#39;
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print &#39;调用子类方法&#39;
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法         #输出：调用子类方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;基础重载方法&#34;&gt;基础重载方法&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;简单的调用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__init__ ( self [,args...] )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;构造函数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;obj = className(args)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__del__( self )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;析构方法, 删除一个对象&lt;/td&gt;
&lt;td&gt;&lt;code&gt;del obj&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__repr__( self )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转化为供解释器读取的形式&lt;/td&gt;
&lt;td&gt;&lt;code&gt;repr(obj)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__str__( self )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于将值转化为适于人阅读的形式&lt;/td&gt;
&lt;td&gt;&lt;code&gt;str(obj)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cmp__ ( self, x )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象比较&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cmp(obj, x)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;运算符重载&#34;&gt;运算符重载&lt;/h1&gt;
&lt;p&gt;例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
 
   def __str__(self):
      return &#39;Vector (%d, %d)&#39; % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)
 
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)     #输出：Vector(7,8)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;类属性与方法&#34;&gt;类属性与方法&lt;/h1&gt;
&lt;h2 id=&#34;类的私有属性&#34;&gt;类的私有属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__private_attrs&lt;/code&gt;：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 &lt;code&gt;self.__private_attrs&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;类的方法&#34;&gt;类的方法&lt;/h2&gt;
&lt;p&gt;在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数&lt;/p&gt;
&lt;h2 id=&#34;类的私有方法&#34;&gt;类的私有方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__private_method&lt;/code&gt;：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 &lt;code&gt;self.__private_methods&lt;/code&gt;&lt;br&gt;
例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
 
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print self.__secretCount
 
counter = JustCounter()
counter.count()
counter.count()
print counter.publicCount
print counter.__secretCount  # 报错，实例不能访问私有变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python 通过改变名称来包含类名:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
2
Traceback (most recent call last):
  File &amp;quot;test.py&amp;quot;, line 17, in &amp;lt;module&amp;gt;
    print counter.__secretCount  # 报错，实例不能访问私有变量
AttributeError: JustCounter instance has no attribute &#39;__secretCount&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python不允许实例化的类访问私有数据，但你可以使用 &lt;code&gt;object._className__attrName（ 对象名._类名__私有属性名 ）&lt;/code&gt;访问属性，参考以下实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Runoob:
    __site = &amp;quot;www.runoob.com&amp;quot;

runoob = Runoob()
print runoob._Runoob__site      #输出：www.runoob.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;单下划线-双下划线-头尾双下划线说明&#34;&gt;单下划线、双下划线、头尾双下划线说明：&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;__foo__&lt;/code&gt;: 定义的是特殊方法，一般是系统定义名字 ，类似&lt;code&gt;__init__()&lt;/code&gt;之类的。&lt;br&gt;
&lt;code&gt;_foo&lt;/code&gt;: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于&lt;code&gt; from module import *&lt;/code&gt;&lt;br&gt;
&lt;code&gt;__foo&lt;/code&gt;: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行&lt;/p&gt;
">Python 面向对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/python-ru-men-bi-ji/"" data-c="
          &lt;p&gt;Python 简单笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;变量&#34;&gt;变量&lt;/h1&gt;
&lt;h2 id=&#34;标准数据类型&#34;&gt;标准数据类型&lt;/h2&gt;
&lt;p&gt;Numbers（数字）；String（字符串）；List（列表）；Tuple（元组）；Dictionary（字典）&lt;/p&gt;
&lt;h3 id=&#34;number数字&#34;&gt;Number数字&lt;/h3&gt;
&lt;p&gt;int：Python3中直接使用int即可&lt;br&gt;
float：浮点型&lt;br&gt;
complex：复数&lt;code&gt;complex(a,b)&lt;/code&gt;a,b均为浮点型数据&lt;/p&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;p&gt;可以索引的字符串&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;P&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Y&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;T&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;H&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;O&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;N&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;正向索引&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;反向索引&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;例程：&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;print str           # 输出完整字符串
print str[0]        # 输出字符串中的第一个字符
print str[2:5]      # 输出字符串中第三个至第六个之间的字符串
print str[2:]       # 输出从第三个字符开始的字符串
print str * 2       # 输出字符串两次
print str + &amp;quot;TEST&amp;quot;  # 输出连接的字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;列表&#34;&gt;列表&lt;/h3&gt;
&lt;p&gt;List（列表） 是 Python 中使用最频繁的数据类型。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。&lt;strong&gt;列表用&lt;code&gt;[ ]&lt;/code&gt;标识&lt;/strong&gt;，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量 &lt;code&gt;[起始位置:结束位置]&lt;/code&gt;；&lt;strong&gt;注意：结束位置前一位结束输出&lt;/strong&gt;就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list = [ &#39;runoob&#39;, 786 , 2.23, &#39;john&#39;, 70.2 ]
list[1:100:2] #表示从1开始递增2到100截止
其他同字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;元组&#34;&gt;元组&lt;/h3&gt;
&lt;p&gt;元组是另一个数据类型，类似于 List（列表）。&lt;strong&gt;元组用&lt;code&gt;()&lt;/code&gt;标识&lt;/strong&gt;，内部元素用逗号隔开。但是&lt;strong&gt;元组不能二次赋值&lt;/strong&gt;，相当于只读列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tinytuple = (123, &#39;john&#39;)
print tuple               # 输出完整元组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字典&#34;&gt;字典&lt;/h3&gt;
&lt;p&gt;字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，&lt;strong&gt;字典是无序的对象集合&lt;/strong&gt;。两者之间的区别在于：&lt;strong&gt;字典当中的元素是通过键来存取&lt;/strong&gt;的，而不是通过偏移存取。字典用&lt;code&gt;{ }&lt;/code&gt;标识。字典由&lt;strong&gt;索引(key)&lt;strong&gt;和它对应的&lt;/strong&gt;值value&lt;/strong&gt;组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
 dict = {}
dict[&#39;one&#39;] = &amp;quot;This is one&amp;quot;
dict[2] = &amp;quot;This is two&amp;quot;
 tinydict = {&#39;name&#39;: &#39;runoob&#39;,&#39;code&#39;:6734, &#39;dept&#39;: &#39;sales&#39;}
  
print dict[&#39;one&#39;]          # 输出键为&#39;one&#39; 的值   输出：This is one
print dict[2]              # 输出键为 2 的值      输出：This is two
print tinydict             # 输出完整的字典       输出：{&#39;dept&#39;: &#39;sales&#39;, &#39;code&#39;: 6734, &#39;name&#39;: &#39;runoob&#39;}
print tinydict.keys()      # 输出所有键           输出：[&#39;dept&#39;, &#39;code&#39;, &#39;name&#39;]
print tinydict.values()    # 输出所有值           输出：[&#39;sales&#39;, 6734, &#39;runoob&#39;]
print (tinydict[&#39;name&#39;])   #输出键为name的值，结果为runoob
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;python数据类型转换&#34;&gt;Python数据类型转换&lt;/h3&gt;
&lt;p&gt;有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int(x [,base])&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将x转换为一个整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long(x [,base] )&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将x转换为一个长整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将x转换到一个浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;complex(real [,imag])&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;创建一个复数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;str(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将对象 x 转换为字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;repr(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将对象 x 转换为表达式字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;eval(str)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来计算在字符串中的有效Python表达式,并返回一个对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tuple(s)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将序列 s 转换为一个元组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;list(s)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将序列 s 转换为一个列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;set(s)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;转换为可变集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dict(d)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;创建一个字典。d 必须是一个序列 (key,value)元组。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;frozenset(s)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;转换为不可变集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;chr(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个整数转换为一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unichr(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个整数转换为Unicode字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ord(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个字符转换为它的整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;hex(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个整数转换为一个十六进制字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;oct(x)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个整数转换为一个八进制字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;运算符&#34;&gt;运算符&lt;/h1&gt;
&lt;h2 id=&#34;运算符种类&#34;&gt;运算符种类&lt;/h2&gt;
&lt;p&gt;算术运算符；比较（关系）运算符；赋值运算符；逻辑运算符；位运算符；成员运算符；身份运算符；运算符优先级&lt;/p&gt;
&lt;h3 id=&#34;算术运算符&#34;&gt;算术运算符&lt;/h3&gt;
&lt;p&gt;加减乘除：&lt;code&gt;+ - * / &lt;/code&gt;&lt;br&gt;
取模：&lt;code&gt;%&lt;/code&gt;返回余数&lt;br&gt;
幂运算：&lt;code&gt;**&lt;/code&gt;；&lt;code&gt;a**b&lt;/code&gt;为a的b次方&lt;br&gt;
取整：&lt;code&gt;//&lt;/code&gt;；向下取整&lt;/p&gt;
&lt;h3 id=&#34;比较运算符&#34;&gt;比较运算符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;等于：==；不等于：!=或者&amp;lt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;赋值运算符&#34;&gt;赋值运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;例程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;乘法赋值运算符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c *= a 等效于 c = c * a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;/=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;除法赋值运算符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c /= a 等效于 c = c / a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;取模赋值运算符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c %= a 等效于 c = c % a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;**=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;幂赋值运算符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c **= a 等效于 c = c ** a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;//=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;取整除赋值运算符&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c //= a 等效于 c = c // a&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;位运算符&#34;&gt;位运算符&lt;/h3&gt;
&lt;p&gt;按位与，或，非，异或运算：&lt;code&gt;&amp;amp;,|,~,^&lt;/code&gt;；左移，右移运算：&lt;code&gt;&amp;lt;&amp;lt;,&amp;gt;&amp;gt;&lt;/code&gt;高位丢弃，低位补0。&lt;/p&gt;
&lt;h3 id=&#34;逻辑运算符&#34;&gt;逻辑运算符&lt;/h3&gt;
&lt;p&gt;Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;逻辑表达式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;and&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x and y&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔&amp;quot;与&amp;quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(a and b) 返回 20。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;or&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x or y&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔&amp;quot;或&amp;quot; - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(a or b) 返回 10。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not x&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔&amp;quot;非&amp;quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not(a and b) 返回 False&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;成员运算符&#34;&gt;成员运算符&lt;/h3&gt;
&lt;p&gt;成员运算符，测试实例中包含了一系列的成员，包括&lt;strong&gt;字符串，列表或元组&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果在指定的序列中找到值返回 True，否则返回 False。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x in y  , 如果 x 在 y 序列中返回 True。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果在指定的序列中没有找到值返回 True，否则返回 False。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x not in y  , 如果 x 不在 y 序列中返回 True。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;身份运算符&#34;&gt;身份运算符&lt;/h3&gt;
&lt;p&gt;身份运算符用于比较两个对象的存储单元&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;is&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;is 是判断两个标识符是不是引用自一个对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;is not&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;is not 是判断两个标识符是不是引用自不同对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;注： &lt;code&gt;id()&lt;/code&gt; 函数用于获取对象内存地址。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;**&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指数 (最高优先级)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;~ + -&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;* / % //&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;乘，除，取模和取整除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;+ -&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加法减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;gt;&amp;gt; &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;右移，左移运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位 &#39;AND&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`^&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;= &amp;lt; &amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;比较运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;&amp;gt; == !=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;等于运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;= %= /= //= -= += *= **=&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;赋值运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;is is not&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;身份运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in not in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;成员运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not and or&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;条件语句&#34;&gt;条件语句&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;if 判断条件：
    执行语句……
else：
    执行语句……
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;循环语句&#34;&gt;循环语句&lt;/h1&gt;
&lt;p&gt;while；for；嵌套&lt;br&gt;
循环控制语句&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;控制语句&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;break 语句&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在语句块执行过程中终止循环，并且跳出整个循环&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;continue 语句&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pass 语句&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pass是空语句，是为了保持程序结构的完整性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;while&#34;&gt;while&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;while 判断条件(condition)：
    执行语句(statements)……
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环使用 else 语句：在 python 中，while … else 在**循环条件为 false 时执行 else **语句块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
count = 0
while count &amp;lt; 5:
   print count, &amp;quot; is  less than 5&amp;quot;
   count = count + 1
else:
   print count, &amp;quot; is not less than 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;for&#34;&gt;for&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;for iterating_var in sequence:
   statements(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
for letter in &#39;Python&#39;:     # 第一个实例
   print(&amp;quot;当前字母: %s&amp;quot; % letter)

输出
当前字母: P
当前字母: y
当前字母: t
当前字母: h
当前字母: o
当前字母: n

fruits = [&#39;banana&#39;, &#39;apple&#39;,  &#39;mango&#39;]
for fruit in fruits:        # 第二个实例
   print (&#39;当前水果: %s&#39;% fruit)
print (&amp;quot;Good bye!&amp;quot;)

输出
当前水果: banana
当前水果: apple
当前水果: mango
Good bye!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 else 语句&lt;br&gt;
在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，&lt;strong&gt;else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
for num in range(10,20):  # 迭代 10 到 20 之间的数字
   for i in range(2,num): # 根据因子迭代
      if num%i == 0:      # 确定第一个因子
         j=num/i          # 计算第二个因子
         print (&#39;%d 等于 %d * %d&#39; % (num,i,j))
         break            # 跳出当前循环
   else:                  # 循环的 else 部分
      print (&#39;%d 是一个质数&#39; % num)

输出：
10 等于 2 * 5
11 是一个质数
12 等于 2 * 6
13 是一个质数
14 等于 2 * 7
15 等于 3 * 5
16 等于 2 * 8
17 是一个质数
18 等于 2 * 9
19 是一个质数
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;continue-语句&#34;&gt;continue 语句&lt;/h1&gt;
&lt;p&gt;Python continue 语句跳出本次循环，而break跳出整个循环。&lt;br&gt;
continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。&lt;br&gt;
continue语句用在while和for循环中。具有删除效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for letter in &#39;Python&#39;:     # 第一个实例
   if letter == &#39;h&#39;:
      continue
   print &#39;当前字母 :&#39;, letter

输出h字母以外的字母
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pass-语句&#34;&gt;pass 语句&lt;/h1&gt;
&lt;p&gt;Python pass 是空语句，是为了保持程序结构的完整性。&lt;br&gt;
pass 不做任何事情，一般用做占位语句。&lt;/p&gt;
&lt;h1 id=&#34;数字数学运算&#34;&gt;数字，数学运算&lt;/h1&gt;
&lt;p&gt;Python math 模块、cmath 模块&lt;br&gt;
Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。&lt;br&gt;
Python math 模块提供了许多对浮点数的数学运算函数。&lt;br&gt;
Python cmath 模块包含了一些用于复数运算的函数。&lt;br&gt;
cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。&lt;br&gt;
要使用 math 或 cmath 函数必须先导入：&lt;code&gt;import math&lt;/code&gt;；&lt;code&gt;import cmath&lt;/code&gt;；&lt;br&gt;
显示名称&lt;code&gt;dir(math)&lt;/code&gt; 输出math中的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cmath.sqrt(-1)
1j
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;字符串-2&#34;&gt;字符串&lt;/h1&gt;
&lt;p&gt;字符串是 Python 中最常用的数据类型。我们可以使用单引号、双引号&lt;code&gt;&#39;或&amp;quot;&lt;/code&gt;来创建字符串。&lt;/p&gt;
&lt;h2 id=&#34;访问字符串中的值&#34;&gt;访问字符串中的值&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var1 = &#39;Hello World!&#39;
print &amp;quot;var1[0]: &amp;quot;, var1[0]

输出为H
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串连接&#34;&gt;字符串连接&lt;/h2&gt;
&lt;p&gt;使用加号连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print &amp;quot;输出 :- &amp;quot;, var1[:6] + &#39;Runoob!&#39;

输出为：Hello Runoob！
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;转义字符&#34;&gt;转义字符&lt;/h2&gt;
&lt;p&gt;在字符中使用特殊字符时，python 用反斜杠 \ 转义字符。如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;转义字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;\(在行尾时)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;续行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;反斜杠符号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;\&#39;	&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单引号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;\&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双引号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;字符串运算符&#34;&gt;字符串运算符&lt;/h2&gt;
&lt;p&gt;a 值为字符串 &amp;quot;Hello&amp;quot;，b 变量值为 &amp;quot;Python&amp;quot;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;字符串连接&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;a + b &lt;br&gt; &#39;HelloPython&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;重复输出字符串&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;a * 2  &lt;br&gt; &#39;HelloHello&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;通过索引获取字符串中字符&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;a[1] &lt;br&gt;  &#39;e&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[ : ]&lt;/td&gt;
&lt;td&gt;截取字符串中的一部分&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;a[1:4]  &lt;br&gt; &#39;ell&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;成员运算符 - 如果字符串中包含给定的字符返回 True&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;H&amp;quot; in a  &lt;br&gt; True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;not in&lt;/td&gt;
&lt;td&gt;成员运算符 - 如果字符串中不包含给定的字符返回 True&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;M&amp;quot; not in a    &lt;br&gt; True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r/R&lt;/td&gt;
&lt;td&gt;原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母&amp;quot;r&amp;quot;（可以大小写）以外，与普通字符串有着几乎完全相同的语法。&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt;&amp;gt;print r&#39;\n&#39; &lt;br&gt;     \n   &lt;br&gt;   &amp;gt;&amp;gt;&amp;gt; print R&#39;\n&#39;  &lt;br&gt;  \n&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;字符串格式化&#34;&gt;字符串格式化&lt;/h2&gt;
&lt;p&gt;类似于C语言中的sprinf函数，%d为整数等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符   号&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;格式化字符及其ASCII码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;格式化字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%d&lt;/td&gt;
&lt;td&gt;格式化整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;格式化无符号整型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%o&lt;/td&gt;
&lt;td&gt;格式化无符号八进制数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%x&lt;/td&gt;
&lt;td&gt;格式化无符号十六进制数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%X&lt;/td&gt;
&lt;td&gt;格式化无符号十六进制数（大写）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%f&lt;/td&gt;
&lt;td&gt;格式化浮点数字，可指定小数点后的精度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%e&lt;/td&gt;
&lt;td&gt;用科学计数法格式化浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%E&lt;/td&gt;
&lt;td&gt;作用同%e，用科学计数法格式化浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%g&lt;/td&gt;
&lt;td&gt;%f和%e的简写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%G&lt;/td&gt;
&lt;td&gt;%F 和 %E 的简写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%p&lt;/td&gt;
&lt;td&gt;用十六进制数格式化变量的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;格式化操作符辅助指令:&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;符号&lt;/td&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;-----&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;定义宽度或者小数点精度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;用做左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在正数前面显示加号( + )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在正数前面显示空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;在八进制数前面显示零(&#39;0&#39;)，在十六进制前面显示&#39;0x&#39;或者&#39;0X&#39;(取决于用的是&#39;x&#39;还是&#39;X&#39;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;显示的数字前面填充&#39;0&#39;而不是默认的空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;&#39;%%&#39;输出一个单一的&#39;%&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(var)&lt;/td&gt;
&lt;td&gt;映射变量(字典参数)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m.n.&lt;/td&gt;
&lt;td&gt;m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;字符串内建函数&#34;&gt;字符串内建函数&lt;/h2&gt;
&lt;p&gt;字符串函数&lt;code&gt;string.xxxxx&lt;/code&gt;对字符串大写、空格等。&lt;/p&gt;
&lt;h1 id=&#34;列表list&#34;&gt;列表（list）&lt;/h1&gt;
&lt;p&gt;序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。&lt;br&gt;
Python有6个序列的内置类型，但最常见的是列表和元组。&lt;br&gt;
序列都可以进行的操作包括&lt;strong&gt;索引，切片，加，乘，检查成员&lt;/strong&gt;。&lt;br&gt;
此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。&lt;br&gt;
列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。&lt;br&gt;
列表的数据项不需要具有相同的类型&lt;br&gt;
创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：&lt;br&gt;
&lt;code&gt;list1 = [&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000] &lt;/code&gt;&lt;br&gt;
list1[0]:访问列表中的值&lt;br&gt;
&lt;code&gt;list1[0]= physics  &lt;/code&gt;&lt;br&gt;
使用append()添加列表项&lt;br&gt;
&lt;code&gt;list1.append(&#39;Google&#39;)&lt;/code&gt;&lt;br&gt;
使用del 语句来删除列表的元素，如下实例：&lt;br&gt;
&lt;code&gt;del list1[2]  删除后为：[&#39;physics&#39;, &#39;chemistry&#39;,  2000]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;列表脚本操作符&#34;&gt;列表脚本操作符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Python 表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len([1, 2, 3])&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[1, 2, 3] + [4, 5, 6]&lt;/td&gt;
&lt;td&gt;[1, 2, 3, 4, 5, 6]&lt;/td&gt;
&lt;td&gt;组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&#39;Hi!&#39;] * 4&lt;/td&gt;
&lt;td&gt;[&#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;]&lt;/td&gt;
&lt;td&gt;重复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3 in [1, 2, 3]&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;元素是否存在于列表中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;for x in [1, 2, 3]: print x,&lt;/td&gt;
&lt;td&gt;1 2 3&lt;/td&gt;
&lt;td&gt;迭代&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;列表函数方法&#34;&gt;列表函数&amp;amp;方法&lt;/h2&gt;
&lt;p&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmp(list1, list2)：比较两个列表的元素
len(list)：列表元素个数
max(list)：返回列表元素最大值
min(list)：返回列表元素最小值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list(seq)：将元组转换为列表
list.append(obj)：在列表末尾添加新的对象
list.count(obj)：统计某个元素在列表中出现的次数
list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
list.index(obj)：从列表中找出某个值第一个匹配项的索引位置
list.insert(index, obj)：将对象插入列表
list.pop([index=-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
list.remove(obj)：移除列表中某个值的第一个匹配项
list.reverse()：反向列表中元素
list.sort(cmp=None, key=None, reverse=False)：对原列表进行排序
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;元组-2&#34;&gt;元组&lt;/h1&gt;
&lt;p&gt;Python 的元组与列表类似，不同之处在于元组的元素不能修改。&lt;br&gt;
元组使用小括号，列表使用方括号。&lt;br&gt;
元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。&lt;br&gt;
&lt;code&gt; tup1 = (&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000)&lt;/code&gt;&lt;br&gt;
访问元组：&lt;code&gt; tup1[0]=physics&lt;/code&gt;&lt;br&gt;
修改元组：元组中的元素值是不允许修改的，但我们可以对元组进行连接组合（&lt;code&gt;tup3 = tup1 + tup2&lt;/code&gt;）&lt;br&gt;
删除元组：元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组（&lt;code&gt;del tup1&lt;/code&gt;）&lt;/p&gt;
&lt;h2 id=&#34;元组运算符&#34;&gt;元组运算符&lt;/h2&gt;
&lt;p&gt;元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Python 表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len((1, 2, 3))&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;计算元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(1, 2, 3) + (4, 5, 6)&lt;/td&gt;
&lt;td&gt;(1, 2, 3, 4, 5, 6)&lt;/td&gt;
&lt;td&gt;连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(&#39;Hi!&#39;,) * 4&lt;/td&gt;
&lt;td&gt;(&#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;)&lt;/td&gt;
&lt;td&gt;复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3 in (1, 2, 3)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;元素是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;for x in (1, 2, 3): print x,&lt;/td&gt;
&lt;td&gt;1 2 3&lt;/td&gt;
&lt;td&gt;迭代&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;元组内置函数&#34;&gt;元组内置函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cmp(tuple1, tuple2) 比较两个元组元素。
len(tuple)  计算元组元素个数。
max(tuple)  返回元组中元素最大值。
min(tuple)  返回元组中元素最小值。
tuple(seq)  将列表转换为元组。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;字典-2&#34;&gt;字典&lt;/h1&gt;
&lt;p&gt;字典是另一种可变容器模型，且可存储任意类型对象。(&lt;strong&gt;字典是无序的&lt;/strong&gt;)&lt;br&gt;
字典的每个键值 &lt;code&gt;key=&amp;gt;value&lt;/code&gt;对用冒号 &lt;code&gt;: &lt;/code&gt;分割，每个键值对之间用逗号 &lt;code&gt;, &lt;/code&gt;分割，整个字典包括在花括号 &lt;code&gt;{}&lt;/code&gt; 中 ,格式如下所示：&lt;br&gt;
&lt;code&gt;d = {key1 : value1, key2 : value2 } &lt;/code&gt;&lt;br&gt;
注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict。&lt;br&gt;
键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。&lt;br&gt;
值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。&lt;/p&gt;
&lt;h2 id=&#34;访问字典里的值&#34;&gt;访问字典里的值&lt;/h2&gt;
&lt;p&gt;把相应的键放入熟悉的方括弧，如下实例:&lt;br&gt;
&lt;code&gt;tinydict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} &lt;/code&gt;&lt;br&gt;
&lt;code&gt;tinydict[&#39;Name&#39;]=Zara&lt;/code&gt;&lt;br&gt;
向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:&lt;br&gt;
更新字典：&lt;code&gt;tinydict[&#39;Age&#39;] = 8&lt;/code&gt;&lt;br&gt;
添加字典：&lt;code&gt;tinydict[&#39;School&#39;] = &amp;quot;RUNOOB&amp;quot; &lt;/code&gt;&lt;br&gt;
删除字典元素：能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用del命令，如下实例：&lt;br&gt;
删除键是&#39;Name&#39;的条目：&lt;code&gt;del tinydict[&#39;Name&#39;]&lt;/code&gt;&lt;br&gt;
清空字典所有条目：&lt;code&gt;tinydict.clear() &lt;/code&gt;&lt;br&gt;
删除字典：&lt;code&gt;del tinydict&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;字典键的特性&#34;&gt;字典键的特性&lt;/h2&gt;
&lt;p&gt;字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。&lt;br&gt;
两个重要的点需要记住：&lt;br&gt;
1）&lt;strong&gt;不允许同一个键出现两次&lt;/strong&gt;。创建时如果同一个键被赋值两次，后一个值会被记住。&lt;br&gt;
2）&lt;strong&gt;键必须不可变&lt;/strong&gt;，所以可以用数字，字符串或元组充当，所以用&lt;strong&gt;列表就不行&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;字典内置函数方法&#34;&gt;字典内置函数&amp;amp;方法&lt;/h2&gt;
&lt;p&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmp(dict1, dict2)比较两个字典元素。
len(dict)计算字典元素个数，即键的总数。
str(dict)输出字典可打印的字符串表示。
type(variable)返回输入的变量类型，如果变量是字典就返回字典类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict.clear()删除字典内所有元素
dict.copy()返回一个字典的浅复制
dict.fromkeys(seq[, val])创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值
dict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值
dict.has_key(key)如果键在字典dict里返回true，否则返回false
dict.items()以列表返回可遍历的(键, 值) 元组数组
dict.keys()以列表返回一个字典所有的键
dict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
dict.update(dict2)把字典dict2的键/值对更新到dict里
dict.values()以列表返回字典中的所有值
pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。
popitem()返回并删除字典中的最后一对键和值。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;时间和日期&#34;&gt;时间和日期&lt;/h1&gt;
&lt;p&gt;Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。&lt;br&gt;
Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。&lt;br&gt;
时间间隔是以秒为单位的浮点小数。&lt;br&gt;
每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。&lt;br&gt;
Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 如下实例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time  # 引入time模块
ticks = time.time()
ticks=1459994552.51
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;时间元组&#34;&gt;时间元组&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4位数年&lt;/td&gt;
&lt;td&gt;tm_year&lt;/td&gt;
&lt;td&gt;2008&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;月&lt;/td&gt;
&lt;td&gt;tm_mon&lt;/td&gt;
&lt;td&gt;1 到 12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;日&lt;/td&gt;
&lt;td&gt;tm_mday&lt;/td&gt;
&lt;td&gt;1到31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;小时&lt;/td&gt;
&lt;td&gt;tm_hour&lt;/td&gt;
&lt;td&gt;0到23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;分钟&lt;/td&gt;
&lt;td&gt;tm_min&lt;/td&gt;
&lt;td&gt;0到59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;td&gt;tm_sec&lt;/td&gt;
&lt;td&gt;0到61 (60或61 是闰秒)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;一周的第几日&lt;/td&gt;
&lt;td&gt;tm_wday&lt;/td&gt;
&lt;td&gt;0到6 (0是周一)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;一年的第几日&lt;/td&gt;
&lt;td&gt;tm_yday&lt;/td&gt;
&lt;td&gt;1到366 (儒略历)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;夏令时&lt;/td&gt;
&lt;td&gt;tm_isdst&lt;/td&gt;
&lt;td&gt;-1, 0, 1, -1是决定是否为夏令时的旗帜&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;获取当前时间&#34;&gt;获取当前时间&lt;/h2&gt;
&lt;p&gt;从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
localtime = time.localtime(time.time())
localtime=time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取格式化时间&#34;&gt;获取格式化时间&lt;/h2&gt;
&lt;p&gt;最简单的获取可读的时间模式的函数是asctime():&lt;br&gt;
&lt;code&gt;localtime = time.asctime( time.localtime(time.time()) )&lt;/code&gt;&lt;br&gt;
输出为：localtime=Thu Apr  7 10:05:21 2016&lt;/p&gt;
&lt;h2 id=&#34;格式化日期&#34;&gt;格式化日期&lt;/h2&gt;
&lt;p&gt;使用 time 模块的 strftime 方法来格式化日期&lt;br&gt;
&lt;code&gt;time.strftime(format[, t])&lt;/code&gt;&lt;br&gt;
格式化成2016-03-20 11:45:39形式：&lt;br&gt;
&lt;code&gt;print time.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;, time.localtime()) &lt;/code&gt;&lt;br&gt;
输出为：&lt;code&gt;2016-04-07 10:25:09&lt;/code&gt;&lt;br&gt;
格式化成Sat Mar 28 22:24:24 2016形式&lt;br&gt;
&lt;code&gt;print time.strftime(&amp;quot;%a %b %d %H:%M:%S %Y&amp;quot;, time.localtime()) &lt;/code&gt;&lt;br&gt;
输出为：&lt;code&gt;Thu Apr 07 10:25:09 2016&lt;/code&gt;&lt;br&gt;
将格式字符串转换为时间戳&lt;br&gt;
&lt;code&gt;a = &amp;quot;Sat Mar 28 22:24:24 2016&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;print time.mktime(time.strptime(a,&amp;quot;%a %b %d %H:%M:%S %Y&amp;quot;))&lt;/code&gt;&lt;br&gt;
输出为：&lt;code&gt;1459175064.0&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/python/python-date-time.html&#34;&gt;更多内容参考&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;h2 id=&#34;定义一个函数&#34;&gt;定义一个函数&lt;/h2&gt;
&lt;p&gt;函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。&lt;code&gt;def functionname( parameters ):&lt;/code&gt;&lt;br&gt;
任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。&lt;br&gt;
函数的&lt;strong&gt;第一行&lt;/strong&gt;语句可以选择性地使用文档字符串—用于存放&lt;strong&gt;函数说明&lt;/strong&gt;。&lt;br&gt;
函数内容以&lt;strong&gt;冒号起始，并且缩进&lt;/strong&gt;。&lt;br&gt;
return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def functionname( parameters ):
   &amp;quot;函数_文档字符串&amp;quot;
   function_suite
   return [expression]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数调用&#34;&gt;函数调用&lt;/h2&gt;
&lt;p&gt;定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。&lt;br&gt;
这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 定义函数
def printme( str ):
   &amp;quot;打印任何传入的字符串&amp;quot;
   print str
   return
 # 调用函数
printme(&amp;quot;我要调用用户自定义函数!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数传递&#34;&gt;参数传递&lt;/h2&gt;
&lt;p&gt;在 python 中，类型属于对象，变量是没有类型的：&lt;br&gt;
&lt;code&gt;a=[1,2,3]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;a=&amp;quot;Runoob&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;[1,2,3]&lt;/code&gt; 是 List 类型，&lt;code&gt;&amp;quot;Runoob&amp;quot;&lt;/code&gt; 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。&lt;/p&gt;
&lt;h3 id=&#34;可更改mutable与不可更改immutable对象&#34;&gt;可更改(mutable)与不可更改(immutable)对象&lt;/h3&gt;
&lt;p&gt;在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。&lt;br&gt;
**不可变类型：**变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。&lt;br&gt;
**可变类型：**变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。&lt;br&gt;
python 函数的参数传递：&lt;br&gt;
**不可变类型：**类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。&lt;br&gt;
**可变类型：**类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响&lt;br&gt;
python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;p&gt;必备参数；关键字参数；默认参数；不定长参数&lt;/p&gt;
&lt;h3 id=&#34;必备参数&#34;&gt;必备参数&lt;/h3&gt;
&lt;p&gt;必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。&lt;br&gt;
调用printme()函数，你必须传入一个参数，不然会出现语法错误：&lt;/p&gt;
&lt;h3 id=&#34;关键字参数&#34;&gt;关键字参数&lt;/h3&gt;
&lt;p&gt;关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。&lt;br&gt;
使用&lt;strong&gt;关键字参数&lt;/strong&gt;允许函数&lt;strong&gt;调用时参数的顺序与声明时不一致&lt;/strong&gt;，因为 Python 解释器能够用参数名匹配参数值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def printinfo( name, age ):
   &amp;quot;打印任何传入的字符串&amp;quot;
   print &amp;quot;Name: &amp;quot;, name
   print &amp;quot;Age &amp;quot;, age
   return
 #调用printinfo函数
printinfo( age=50, name=&amp;quot;miki&amp;quot; )
输出：Name:  miki      Age  50
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;默认参数&#34;&gt;默认参数&lt;/h3&gt;
&lt;p&gt;调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：函数定义中对参数赋值&lt;/p&gt;
&lt;h3 id=&#34;不定长参数&#34;&gt;不定长参数&lt;/h3&gt;
&lt;p&gt;你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def functionname([formal_args,] *var_args_tuple ):
   &amp;quot;函数_文档字符串&amp;quot;
   function_suite
   return [expression]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def printinfo( arg1, *vartuple ):
   &amp;quot;打印任何传入的参数&amp;quot;
   print &amp;quot;输出: &amp;quot;
   print arg1
   for var in vartuple:
      print var
   return
 # 调用printinfo 函数
printinfo( 10 )     #输出 10
printinfo( 70, 60, 50 ) #输出 70 60 50
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;匿名函数&#34;&gt;匿名函数&lt;/h3&gt;
&lt;p&gt;python 使用 lambda 来创建匿名函数。&lt;br&gt;
lambda只是一个表达式，函数体比def简单很多。&lt;br&gt;
lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。&lt;br&gt;
lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。&lt;br&gt;
虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。&lt;br&gt;
&lt;code&gt;lambda [arg1 [,arg2,.....argn]]:expression&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum = lambda arg1, arg2: arg1 + arg2
 # 调用sum函数
print &amp;quot;相加后的值为 : &amp;quot;, sum( 10, 20 )  #输出为&amp;gt;&amp;gt;&amp;gt;相加后的值为 : 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;return语句&#34;&gt;return语句&lt;/h3&gt;
&lt;p&gt;return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。&lt;/p&gt;
&lt;h3 id=&#34;全局变量和局部变量&#34;&gt;全局变量和局部变量&lt;/h3&gt;
&lt;p&gt;定义在&lt;strong&gt;函数内部的变量拥有一个局部作用域&lt;/strong&gt;，定义在&lt;strong&gt;函数外的拥有全局作用域&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;局部变量只能在其被声明的函数内部&lt;/strong&gt;访问，而&lt;strong&gt;全局变量可以在整个程序范围内&lt;/strong&gt;访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。&lt;/p&gt;
&lt;h1 id=&#34;python-模块&#34;&gt;python 模块&lt;/h1&gt;
&lt;p&gt;Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。&lt;br&gt;
模块让你能够有逻辑地组织你的 Python 代码段。&lt;br&gt;
把相关的代码分配到一个模块里能让你的代码更好用，更易懂。&lt;br&gt;
模块能定义函数，类和变量，模块里也能包含可执行的代码。&lt;/p&gt;
&lt;h2 id=&#34;import-语句&#34;&gt;import 语句&lt;/h2&gt;
&lt;p&gt;模块定义好后，我们可以使用 import 语句来引入模块，语法如下：&lt;br&gt;
&lt;code&gt;import module1[, module2[,... moduleN]]&lt;/code&gt;&lt;br&gt;
比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：&lt;br&gt;
&lt;code&gt;模块名.函数名&lt;/code&gt;&lt;br&gt;
当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。&lt;br&gt;
搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：&lt;br&gt;
一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。&lt;/p&gt;
&lt;h2 id=&#34;fromimport-语句&#34;&gt;from...import 语句&lt;/h2&gt;
&lt;p&gt;把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：&lt;br&gt;
&lt;code&gt;from modname import *&lt;/code&gt;&lt;br&gt;
例程：&lt;code&gt;from math import *&lt;/code&gt;math模块所有东西&lt;br&gt;
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。&lt;/p&gt;
&lt;h2 id=&#34;搜索路径&#34;&gt;搜索路径&lt;/h2&gt;
&lt;p&gt;当你导入一个模块，Python 解析器对模块位置的搜索顺序是：&lt;br&gt;
1、当前目录&lt;br&gt;
2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。&lt;br&gt;
3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。&lt;br&gt;
模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。&lt;/p&gt;
&lt;h2 id=&#34;pythonpath-变量&#34;&gt;PYTHONPATH 变量&lt;/h2&gt;
&lt;p&gt;作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。&lt;br&gt;
在 Windows 系统，典型的 PYTHONPATH 如下：&lt;br&gt;
&lt;code&gt;set PYTHONPATH=c:\python27\lib;&lt;/code&gt;&lt;br&gt;
在 UNIX 系统，典型的 PYTHONPATH 如下：&lt;br&gt;
&lt;code&gt;set PYTHONPATH=/usr/local/lib/python&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;命名空间和作用域&#34;&gt;命名空间和作用域&lt;/h2&gt;
&lt;p&gt;变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。&lt;br&gt;
一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。&lt;br&gt;
每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。&lt;br&gt;
Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。&lt;br&gt;
因此，如果要给函数内的全局变量赋值，必须使用 global 语句。&lt;br&gt;
&lt;code&gt;global VarName&lt;/code&gt; 的表达式会告诉 Python， &lt;strong&gt;VarName 是一个全局变量&lt;/strong&gt;，这样 Python 就不会在局部命名空间里寻找这个变量了。&lt;br&gt;
例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;dir函数&#34;&gt;dir()函数&lt;/h2&gt;
&lt;p&gt;dir() 函数一个排好序的字符串列表，内容是一个&lt;strong&gt;模块里定义过的名字&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;globals-和-locals-函数&#34;&gt;globals() 和 locals() 函数&lt;/h2&gt;
&lt;p&gt;根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。&lt;br&gt;
如果在&lt;strong&gt;函数内部调用 locals()&lt;/strong&gt;，返回的是所有能在该函数里访问的命名。&lt;br&gt;
如果在&lt;strong&gt;函数内部调用 globals()&lt;/strong&gt;，返回的是所有在该函数里能访问的全局名字。&lt;br&gt;
两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。&lt;/p&gt;
&lt;h2 id=&#34;reload-函数&#34;&gt;reload() 函数&lt;/h2&gt;
&lt;p&gt;当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。&lt;br&gt;
因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：&lt;br&gt;
&lt;code&gt;reload(module_name)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;python中的包&#34;&gt;Python中的包&lt;/h2&gt;
&lt;p&gt;包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。&lt;br&gt;
简单来说，包就是文件夹，但该文件夹下必须存在 &lt;strong&gt;init&lt;/strong&gt;.py 文件, 该文件的内容可以为空。&lt;strong&gt;init&lt;/strong&gt;.py 用于标识当前文件夹是一个包。&lt;br&gt;
考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、&lt;strong&gt;init&lt;/strong&gt;.py 文件，test.py 为测试调用包的代码，目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test.py #测试代码
package_runoob #文件夹
|-- __init__.py #子包
|-- runoob1.py
|-- runoob2.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python-文件io&#34;&gt;Python 文件I/O&lt;/h1&gt;
&lt;h2 id=&#34;打印到屏幕&#34;&gt;打印到屏幕&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;print &amp;quot;Python 是一个非常棒的语言，不是吗？&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;读取键盘输入&#34;&gt;读取键盘输入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;raw_input([prompt])&lt;/code&gt; 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：&lt;br&gt;
Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：&lt;br&gt;
&lt;code&gt;raw_input&lt;/code&gt;以及&lt;code&gt;input&lt;/code&gt;&lt;br&gt;
读取键盘输入：&lt;code&gt;str = raw_input(&amp;quot;请输入：&amp;quot;)&lt;/code&gt;，&lt;code&gt;str = input(&amp;quot;请输入：&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;打开和关闭文件&#34;&gt;打开和关闭文件&lt;/h2&gt;
&lt;h3 id=&#34;open-函数&#34;&gt;open 函数&lt;/h3&gt;
&lt;p&gt;你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。&lt;strong&gt;&lt;a href=&#34;https://www.runoob.com/python/python-files-io.html&#34;&gt;详细内容&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;file object = open(file_name [, access_mode][, buffering])&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;file_name&lt;/strong&gt;：file_name变量是一个包含了你要访问的文件名称的字符串值。&lt;br&gt;
&lt;strong&gt;access_mode&lt;/strong&gt;：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。&lt;br&gt;
&lt;strong&gt;buffering&lt;/strong&gt;:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;文本模式 (默认)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;写模式，新建一个文件，如果该文件已存在则会报错。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;二进制模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;打开一个文件进行更新(可读可写)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;通用换行模式（不推荐）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rb&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。文件指针将会放在文件的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rb+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wb&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wb+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ab&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ab+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;file对象的属性&#34;&gt;File对象的属性&lt;/h2&gt;
&lt;p&gt;一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。&lt;br&gt;
以下是和file对象相关的所有属性的列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;file.closed&lt;/td&gt;
&lt;td&gt;返回true如果文件已被关闭，否则返回false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.mode&lt;/td&gt;
&lt;td&gt;返回被打开文件的访问模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.name&lt;/td&gt;
&lt;td&gt;返回文件的名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.softspace&lt;/td&gt;
&lt;td&gt;如果用print输出后，必须跟一个空格符，则返回false。否则返回true。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;close方法&#34;&gt;close()方法&lt;/h2&gt;
&lt;p&gt;File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。&lt;br&gt;
当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。&lt;br&gt;
语法：&lt;code&gt;fileObject.close()&lt;/code&gt;即：文件名.close()&lt;/p&gt;
&lt;h2 id=&#34;write方法&#34;&gt;write()方法&lt;/h2&gt;
&lt;p&gt;write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。&lt;br&gt;
write()方法不会在字符串的结尾添加换行符(&#39;\n&#39;)：&lt;br&gt;
语法：&lt;code&gt;fileObject.write(string)&lt;/code&gt;&lt;br&gt;
例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 打开一个文件
fo = open(&amp;quot;foo.txt&amp;quot;, &amp;quot;w&amp;quot;)
fo.write( &amp;quot;www.runoob.com!\nVery good site!\n&amp;quot;)
# 关闭打开的文件
fo.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;read方法&#34;&gt;read()方法&lt;/h2&gt;
&lt;p&gt;read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。&lt;br&gt;
语法：&lt;code&gt;fileObject.read([count])&lt;/code&gt;&lt;br&gt;
例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fo = open(&amp;quot;foo.txt&amp;quot;, &amp;quot;r+&amp;quot;)#foo.ext内保存内容是www.runoob.com!
str = fo.read(10)
print &amp;quot;读取的字符串是 : &amp;quot;, str
# 关闭打开的文件
fo.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件定位&#34;&gt;文件定位&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tell()&lt;/code&gt;方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。&lt;br&gt;
&lt;code&gt;seek(offset [,from])&lt;/code&gt;方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。&lt;br&gt;
如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置&lt;br&gt;
例程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 打开一个文件
fo = open(&amp;quot;foo.txt&amp;quot;, &amp;quot;r+&amp;quot;)
str = fo.read(10)
print &amp;quot;读取的字符串是 : &amp;quot;, str #输出www.runoob

# 查找当前位置
position = fo.tell()
print &amp;quot;当前文件位置 : &amp;quot;, position   #输出10
 
# 把指针再次重新定位到文件开头
position = fo.seek(0, 0)
str = fo.read(10)
print &amp;quot;重新读取字符串 : &amp;quot;, str  #输出www.runoob
# 关闭打开的文件
fo.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重命名和删除文件&#34;&gt;重命名和删除文件&lt;/h2&gt;
&lt;p&gt;Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。&lt;br&gt;
要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。&lt;/p&gt;
&lt;h3 id=&#34;rename-和remove方法&#34;&gt;rename() 和remove()方法&lt;/h3&gt;
&lt;p&gt;rename() 方法需要两个参数，当前的文件名和新文件名。&lt;br&gt;
&lt;code&gt;os.rename(current_file_name, new_file_name)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os   #导入
 # 重命名文件test1.txt到test2.txt。
os.rename( &amp;quot;test1.txt&amp;quot;, &amp;quot;test2.txt&amp;quot; )
# 删除一个已经存在的文件test2.txt
os.remove(&amp;quot;test2.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python里的目录&#34;&gt;Python里的目录：&lt;/h2&gt;
&lt;p&gt;所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。&lt;br&gt;
&lt;code&gt;mkdir()&lt;/code&gt;、&lt;code&gt;chdir()&lt;/code&gt;和&lt;code&gt;rmdir()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
 # 创建目录test
os.mkdir(&amp;quot;test&amp;quot;)
# 将当前目录改为&amp;quot;/home/newdir&amp;quot;
os.chdir(&amp;quot;/home/newdir&amp;quot;)
# 给出当前的目录
print os.getcwd()
# 删除”/tmp/test”目录
os.rmdir( &amp;quot;/tmp/test&amp;quot;  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python-file-文件方法&#34;&gt;Python File (文件)方法&lt;/h1&gt;
&lt;h2 id=&#34;open方法&#34;&gt;open()方法&lt;/h2&gt;
&lt;p&gt;Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。&lt;br&gt;
注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。&lt;br&gt;
open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。&lt;br&gt;
&lt;code&gt;open(file, mode=&#39;r&#39;)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)&lt;/code&gt;&lt;br&gt;
参数说明:&lt;br&gt;
file: 必需，文件路径（相对或者绝对路径）。&lt;br&gt;
mode: 可选，文件打开模式&lt;br&gt;
buffering: 设置缓冲&lt;br&gt;
encoding: 一般使用utf8&lt;br&gt;
errors: 报错级别&lt;br&gt;
newline: 区分换行符&lt;br&gt;
closefd: 传入的file参数类型&lt;br&gt;
opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。&lt;br&gt;
mode 参数参考上述&lt;/p&gt;
&lt;h2 id=&#34;file-对象&#34;&gt;file 对象&lt;/h2&gt;
&lt;p&gt;file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;file.close()&lt;/td&gt;
&lt;td&gt;关闭文件。关闭后文件不能再进行读写操作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.flush()&lt;/td&gt;
&lt;td&gt;刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.fileno()&lt;/td&gt;
&lt;td&gt;返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.isatty()&lt;/td&gt;
&lt;td&gt;如果文件连接到一个终端设备返回 True，否则返回 False。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.next()&lt;/td&gt;
&lt;td&gt;返回文件下一行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.read([size])&lt;/td&gt;
&lt;td&gt;从文件读取指定的字节数，如果未给定或为负则读取所有。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.readline([size])&lt;/td&gt;
&lt;td&gt;读取整行，包括 &amp;quot;\n&amp;quot; 字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.readlines([sizeint])&lt;/td&gt;
&lt;td&gt;读取所有行并返回列表，若给定sizeint&amp;gt;0，则是设置一次读多少字节，这是为了减轻读取压力。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.seek(offset[, whence])&lt;/td&gt;
&lt;td&gt;设置文件当前位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.tell()&lt;/td&gt;
&lt;td&gt;返回文件当前位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.truncate([size])&lt;/td&gt;
&lt;td&gt;截取文件，截取的字节通过size指定，默认为当前文件位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.write(str)&lt;/td&gt;
&lt;td&gt;将字符串写入文件，返回的是写入的字符长度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;file.writelines(sequence)&lt;/td&gt;
&lt;td&gt;向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;python-os-文件目录方法&#34;&gt;Python OS 文件/目录方法&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os.access(path, mode)&lt;/td&gt;
&lt;td&gt;检验权限模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.chdir(path)&lt;/td&gt;
&lt;td&gt;改变当前工作目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.chflags(path, flags)&lt;/td&gt;
&lt;td&gt;设置路径的标记为数字标记。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.chmod(path, mode)&lt;/td&gt;
&lt;td&gt;更改权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.chown(path, uid, gid)&lt;/td&gt;
&lt;td&gt;更改文件所有者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.chroot(path)&lt;/td&gt;
&lt;td&gt;改变当前进程的根目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.close(fd)&lt;/td&gt;
&lt;td&gt;关闭文件描述符 fd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.closerange(fd_low, fd_high)&lt;/td&gt;
&lt;td&gt;关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.dup(fd)&lt;/td&gt;
&lt;td&gt;复制文件描述符 fd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.dup2(fd, fd2)&lt;/td&gt;
&lt;td&gt;将一个文件描述符 fd 复制到另一个 fd2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fchdir(fd)&lt;/td&gt;
&lt;td&gt;通过文件描述符改变当前工作目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fchmod(fd, mode)&lt;/td&gt;
&lt;td&gt;改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fchown(fd, uid, gid)&lt;/td&gt;
&lt;td&gt;修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fdatasync(fd)&lt;/td&gt;
&lt;td&gt;强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fdopen(fd[, mode[, bufsize]])&lt;/td&gt;
&lt;td&gt;通过文件描述符 fd 创建一个文件对象，并返回这个文件对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fpathconf(fd, name)&lt;/td&gt;
&lt;td&gt;返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fstat(fd)&lt;/td&gt;
&lt;td&gt;返回文件描述符fd的状态，像stat()。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fstatvfs(fd)&lt;/td&gt;
&lt;td&gt;返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.fsync(fd)&lt;/td&gt;
&lt;td&gt;强制将文件描述符为fd的文件写入硬盘。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.ftruncate(fd, length)&lt;/td&gt;
&lt;td&gt;裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.getcwd()&lt;/td&gt;
&lt;td&gt;返回当前工作目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.getcwdu()&lt;/td&gt;
&lt;td&gt;返回一个当前工作目录的Unicode对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.isatty(fd)&lt;/td&gt;
&lt;td&gt;如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.lchflags(path, flags)&lt;/td&gt;
&lt;td&gt;设置路径的标记为数字标记，类似 chflags()，但是没有软链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.lchmod(path, mode)&lt;/td&gt;
&lt;td&gt;修改连接文件权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.lchown(path, uid, gid)&lt;/td&gt;
&lt;td&gt;更改文件所有者，类似 chown，但是不追踪链接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.link(src, dst)&lt;/td&gt;
&lt;td&gt;创建硬链接，名为参数 dst，指向参数 src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.listdir(path)&lt;/td&gt;
&lt;td&gt;返回path指定的文件夹包含的文件或文件夹的名字的列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.lseek(fd, pos, how)&lt;/td&gt;
&lt;td&gt;设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos;SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.lstat(path)&lt;/td&gt;
&lt;td&gt;像stat(),但是没有软链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.major(device)&lt;/td&gt;
&lt;td&gt;从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.makedev(major, minor)&lt;/td&gt;
&lt;td&gt;以major和minor设备号组成一个原始设备号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.makedirs(path[, mode])&lt;/td&gt;
&lt;td&gt;递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.minor(device)&lt;/td&gt;
&lt;td&gt;从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.mkdir(path[, mode])&lt;/td&gt;
&lt;td&gt;以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.mkfifo(path[, mode])&lt;/td&gt;
&lt;td&gt;创建命名管道，mode 为数字，默认为 0666 (八进制)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.mknod(filename[, mode=0600, device])&lt;/td&gt;
&lt;td&gt;创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.open(file, flags[, mode])&lt;/td&gt;
&lt;td&gt;打开一个文件，并且设置需要的打开选项，mode参数是可选的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.openpty()&lt;/td&gt;
&lt;td&gt;打开一个新的伪终端对。返回 pty 和 tty的文件描述符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.pathconf(path, name)&lt;/td&gt;
&lt;td&gt;返回相关文件的系统配置信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.pipe()&lt;/td&gt;
&lt;td&gt;创建一个管道. 返回一对文件描述符(r, w) 分别为读和写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.popen(command[, mode[, bufsize]])&lt;/td&gt;
&lt;td&gt;从一个 command 打开一个管道&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.read(fd, n)&lt;/td&gt;
&lt;td&gt;从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.readlink(path)&lt;/td&gt;
&lt;td&gt;返回软链接所指向的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.remove(path)&lt;/td&gt;
&lt;td&gt;删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.removedirs(path)&lt;/td&gt;
&lt;td&gt;递归删除目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.rename(src, dst)&lt;/td&gt;
&lt;td&gt;重命名文件或目录，从 src 到 dst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.renames(old, new)&lt;/td&gt;
&lt;td&gt;递归地对目录进行更名，也可以对文件进行更名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.rmdir(path)&lt;/td&gt;
&lt;td&gt;删除path指定的空目录，如果目录非空，则抛出一个OSError异常。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.stat(path)&lt;/td&gt;
&lt;td&gt;获取path指定的路径的信息，功能等同于C API中的stat()系统调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.stat_float_times([newvalue])&lt;/td&gt;
&lt;td&gt;决定stat_result是否以float对象显示时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.statvfs(path)&lt;/td&gt;
&lt;td&gt;获取指定路径的文件系统统计信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.symlink(src, dst)&lt;/td&gt;
&lt;td&gt;创建一个软链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.tcgetpgrp(fd)&lt;/td&gt;
&lt;td&gt;返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.tcsetpgrp(fd, pg)&lt;/td&gt;
&lt;td&gt;设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.tempnam([dir[, prefix]])&lt;/td&gt;
&lt;td&gt;返回唯一的路径名用于创建临时文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.tmpfile()&lt;/td&gt;
&lt;td&gt;返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.tmpnam()&lt;/td&gt;
&lt;td&gt;为创建一个临时文件返回一个唯一的路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.ttyname(fd)&lt;/td&gt;
&lt;td&gt;返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.unlink(path)&lt;/td&gt;
&lt;td&gt;删除文件路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.utime(path, times)&lt;/td&gt;
&lt;td&gt;返回指定的path文件的访问和修改的时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])&lt;/td&gt;
&lt;td&gt;输出在文件夹中的文件名通过在树中游走，向上或者向下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.write(fd, str)&lt;/td&gt;
&lt;td&gt;写入字符串到文件描述符 fd中. 返回实际写入的字符串长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.path 模块&lt;/td&gt;
&lt;td&gt;获取文件的属性信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;python-异常&#34;&gt;Python 异常&lt;/h1&gt;
&lt;p&gt;python提供了两个非常重要的功能来处理python程序在运行中出现的&lt;strong&gt;异常&lt;/strong&gt;和&lt;strong&gt;错误&lt;/strong&gt;。你可以使用该功能来调试python程序。&lt;br&gt;
异常处理: 本站Python教程会具体介绍。&lt;br&gt;
断言(Assertions):本站Python教程会具体介绍。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BaseException&lt;/td&gt;
&lt;td&gt;所有异常的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SystemExit&lt;/td&gt;
&lt;td&gt;解释器请求退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KeyboardInterrupt&lt;/td&gt;
&lt;td&gt;用户中断执行(通常是输入^C)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;常规错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StopIteration&lt;/td&gt;
&lt;td&gt;迭代器没有更多的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeneratorExit&lt;/td&gt;
&lt;td&gt;生成器(generator)发生异常来通知退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StandardError&lt;/td&gt;
&lt;td&gt;所有的内建标准异常的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ArithmeticError&lt;/td&gt;
&lt;td&gt;所有数值计算错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FloatingPointError&lt;/td&gt;
&lt;td&gt;浮点计算错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OverflowError&lt;/td&gt;
&lt;td&gt;数值运算超出最大限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZeroDivisionError&lt;/td&gt;
&lt;td&gt;除(或取模)零 (所有数据类型)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AssertionError&lt;/td&gt;
&lt;td&gt;断言语句失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AttributeError&lt;/td&gt;
&lt;td&gt;对象没有这个属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EOFError&lt;/td&gt;
&lt;td&gt;没有内建输入,到达EOF 标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EnvironmentError&lt;/td&gt;
&lt;td&gt;操作系统错误的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IOError&lt;/td&gt;
&lt;td&gt;输入/输出操作失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OSError&lt;/td&gt;
&lt;td&gt;操作系统错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WindowsError&lt;/td&gt;
&lt;td&gt;系统调用失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ImportError&lt;/td&gt;
&lt;td&gt;导入模块/对象失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LookupError&lt;/td&gt;
&lt;td&gt;无效数据查询的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IndexError&lt;/td&gt;
&lt;td&gt;序列中没有此索引(index)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KeyError&lt;/td&gt;
&lt;td&gt;映射中没有这个键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MemoryError&lt;/td&gt;
&lt;td&gt;内存溢出错误(对于Python 解释器不是致命的)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NameError&lt;/td&gt;
&lt;td&gt;未声明/初始化对象 (没有属性)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnboundLocalError&lt;/td&gt;
&lt;td&gt;访问未初始化的本地变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ReferenceError&lt;/td&gt;
&lt;td&gt;弱引用(Weak reference)试图访问已经垃圾回收了的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RuntimeError&lt;/td&gt;
&lt;td&gt;一般的运行时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NotImplementedError&lt;/td&gt;
&lt;td&gt;尚未实现的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SyntaxError&lt;/td&gt;
&lt;td&gt;Python 语法错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IndentationError&lt;/td&gt;
&lt;td&gt;缩进错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TabError&lt;/td&gt;
&lt;td&gt;Tab 和空格混用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SystemError&lt;/td&gt;
&lt;td&gt;一般的解释器系统错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeError&lt;/td&gt;
&lt;td&gt;对类型无效的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ValueError&lt;/td&gt;
&lt;td&gt;传入无效的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeError&lt;/td&gt;
&lt;td&gt;Unicode 相关的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeDecodeError&lt;/td&gt;
&lt;td&gt;Unicode 解码时的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeEncodeError&lt;/td&gt;
&lt;td&gt;Unicode 编码时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UnicodeTranslateError&lt;/td&gt;
&lt;td&gt;Unicode 转换时错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;警告的基类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DeprecationWarning&lt;/td&gt;
&lt;td&gt;关于被弃用的特征的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FutureWarning&lt;/td&gt;
&lt;td&gt;关于构造将来语义会有改变的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OverflowWarning&lt;/td&gt;
&lt;td&gt;旧的关于自动提升为长整型(long)的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PendingDeprecationWarning&lt;/td&gt;
&lt;td&gt;关于特性将会被废弃的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RuntimeWarning&lt;/td&gt;
&lt;td&gt;可疑的运行时行为(runtime behavior)的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SyntaxWarning&lt;/td&gt;
&lt;td&gt;可疑的语法的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UserWarning&lt;/td&gt;
&lt;td&gt;用户代码生成的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;什么是异常&#34;&gt;什么是异常？&lt;/h2&gt;
&lt;p&gt;异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。&lt;br&gt;
一般情况下，在Python无法正常处理程序时就会发生一个异常。&lt;br&gt;
异常是Python对象，表示一个错误。&lt;br&gt;
当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。&lt;/p&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;捕捉异常可以使用try/except语句。&lt;br&gt;
try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。&lt;br&gt;
如果你不想在异常发生时结束你的程序，只需在try里捕获它。&lt;br&gt;
语法：以下为简单的try....except...else的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
&amp;lt;语句&amp;gt;        #运行别的代码
except &amp;lt;异常名字&amp;gt;：
&amp;lt;语句&amp;gt;        #如果在try部份引发了&#39;name&#39;异常
except &amp;lt;名字&amp;gt;，&amp;lt;数据&amp;gt;:
&amp;lt;语句&amp;gt;        #如果引发了&#39;name&#39;异常，获得附加的数据
else:
&amp;lt;语句&amp;gt;        #如果没有异常发生
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。&lt;br&gt;
1.如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常 处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。&lt;br&gt;
2.如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。&lt;br&gt;
3.如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    fh = open(&amp;quot;testfile&amp;quot;, &amp;quot;w&amp;quot;)
    fh.write(&amp;quot;这是一个测试文件，用于测试异常!!&amp;quot;)
except IOError:
    print &amp;quot;Error: 没有找到文件或读取文件失败&amp;quot;  #此行输出
else:
    print &amp;quot;内容写入文件成功&amp;quot; 
    fh.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用except而不带任何异常类型&#34;&gt;使用except而不带任何异常类型&lt;/h2&gt;
&lt;p&gt;try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。&lt;/p&gt;
&lt;h2 id=&#34;使用except而带多种异常类型&#34;&gt;使用except而带多种异常类型&lt;/h2&gt;
&lt;p&gt;你也可以使用相同的except语句来处理多个异常信息，如下所示：&lt;br&gt;
&lt;code&gt;except(Exception1[, Exception2[,...ExceptionN]]):&lt;/code&gt;发生异常1,2,3……执行&lt;/p&gt;
&lt;h2 id=&#34;try-finally-语句&#34;&gt;try-finally 语句&lt;/h2&gt;
&lt;p&gt;try-finally 语句无论是否发生异常都将执行最后的代码。可以嵌套。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
&amp;lt;语句&amp;gt;
finally:
&amp;lt;语句&amp;gt;    #退出try时总会执行
raise
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;异常的参数&#34;&gt;异常的参数&lt;/h2&gt;
&lt;p&gt;一个异常可以带上参数，可作为输出的异常信息参数。&lt;br&gt;
你可以通过except语句来捕获异常的参数，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    正常的操作
   ......................
except ExceptionType, Argument:
    你可以在这输出 Argument 的值...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;触发异常&#34;&gt;触发异常&lt;/h2&gt;
&lt;p&gt;我们可以使用raise语句自己触发异常&lt;br&gt;
raise语法格式如下：&lt;code&gt;raise [Exception [, args [, traceback]]]&lt;/code&gt;&lt;br&gt;
一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。&lt;br&gt;
定义一个异常非常简单，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def functionName( level ):
    if level &amp;lt; 1:
        raise Exception(&amp;quot;Invalid level!&amp;quot;, level)
        # 触发异常后，后面的代码就不会再执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用户自定义异常&#34;&gt;用户自定义异常&lt;/h2&gt;
&lt;p&gt;通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。&lt;br&gt;
以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。&lt;br&gt;
在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义后使用以下触发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    raise Networkerror(&amp;quot;Bad hostname&amp;quot;)
except Networkerror,e:
    print e.args
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;内置函数&#34;&gt;内置函数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;abs()	divmod()	input()	open()	staticmethod() all()	enumerate()	int()
ord()	str() any()	eval()	isinstance()	pow()	sum() basestring()	
execfile()	issubclass()	print()	super() bin()	file()	iter()	property()
tuple() bool()	filter()	len()	range()	type() bytearray()	float()	list()
raw_input()	unichr() callable()	format()	locals()	reduce()	unicode() 
chr()	frozenset()	long()	reload()	vars() classmethod()	getattr()	
map()	repr()	xrange() cmp()	globals()	max()	reverse()	zip() 
compile()	hasattr()	memoryview()	round()	 __import__() complex()	hash()
min()	set()	 delattr()	help()	next()	setattr()	 dict()	hex()	
object()	slice()	 dir()	id()	oct()	sorted()	exec 内置表达式
&lt;/code&gt;&lt;/pre&gt;
">Python 入门笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/proxifierclash/"" data-c="
          &lt;p&gt;Proxifier+clash代理电脑任意软件&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;proxifier&#34;&gt;Proxifier&lt;/h1&gt;
&lt;p&gt;下载并安装Proxifier软件，破解请自行解决。&lt;/p&gt;
&lt;h1 id=&#34;clash设置&#34;&gt;Clash设置&lt;/h1&gt;
&lt;p&gt;在General页面中将Allow LAN选项打开，默认端口为7890&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647921498262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;proxifier配置&#34;&gt;Proxifier配置&lt;/h1&gt;
&lt;p&gt;单击菜单栏按钮&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647920805798.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单击Add&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647920864050.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图设置（Clash默认端口为7890）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647920908538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加规则&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647921023780.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加需要代理的软件（1，命名（可以随意）2，需要代理的软件（通过Browse添加需要代理的软件路径）3，流量走软件Clash）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647921312572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置完成：使用需要代理的软件过程中Proxifier出现如下连接信息代理成功&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1647921420980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Proxifier+clash</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/gridea-jian-dan-jiao-cheng-freenomcloudflare/"" data-c="
          &lt;p&gt;静态博客+私人域名&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;git&#34;&gt;git&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;下载git（Gridea是基于git的所以需要先安装git）&lt;/li&gt;
&lt;li&gt;安装git（直接一直点击下一步就可以了）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;gridea&#34;&gt;Gridea&lt;/h1&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;下载Gridea&lt;/li&gt;
&lt;li&gt;安装Gridea（默认或者更换你喜欢的路径）&lt;/li&gt;
&lt;li&gt;创建 GitHub 账号，并创建一个仓库 Token。&lt;a href=&#34;https://gridea.dev/gridea-start/&#34;&gt;5-8步参考地址&lt;/a&gt;&lt;br&gt;
  点击GitHub，进行注册。登录 GitHub 之后，点击这里创建一个 Token，&lt;strong&gt;勾选上 repo 的相关权限即可&lt;/strong&gt;。生成之后记得把 Token 复制到你的本地，因为一旦关闭网页将不能再看到它。&lt;br&gt;
  小白之创建仓库方法：&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1593684426205.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;创建仓库，存放构建后的网站文件。创建一个公开仓库，名为&lt;strong&gt;用户名.github.io&lt;/strong&gt;。（将&lt;strong&gt;用户名&lt;/strong&gt;替换为你的 GitHub 用户名）&lt;/li&gt;
&lt;li&gt;进入 Gridea 进行远程设置。按照&lt;a href=&#34;https://gridea.dev/gridea-start/&#34;&gt;教程&lt;/a&gt;示例进行设置，然后点击「检测远程链接」，进行配置检查，邮箱为注册github时使用的邮箱。&lt;/li&gt;
&lt;li&gt;同步。点击 Gridea 中的 同步按钮即可。初次部署等待几分钟之后就可以去浏览器访问了，默认地址为你在第 7步所填写的域名（https://用户名.github.io）。到这里就完成一个静态博客的搭建了，可以写博客同步到你的域名了。以下为使用Freenom申请免费域名，Cloudflare域名解析；即可以使用你申请的免费域名（Freenom）访问你的Gridea博客。&lt;br&gt;
附录：修改主题，打开官网，点击主题，点击下载，在github界面点击下载zip，下载完成后解压，修改文件名称为主题名称，将该文件夹放入Gridea主题文件夹，默认路径为（C:\Users\Desktop\Documents\Gridea\themes）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;freenom&#34;&gt;Freenom&lt;/h1&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;打开并注册Freenom&lt;a href=&#34;https://www.jianshu.com/p/e02371079daa&#34;&gt;注册参考链接&lt;/a&gt;&lt;br&gt;
  打开&lt;a href=&#34;https://www.freenom.com/zu/index.html?lang=zu&#34;&gt;Freenom官网&lt;/a&gt;，在网站文本框输入你想要的域名（例如baidu.tk）然后点击“检查可用性”&lt;/li&gt;
&lt;li&gt;更改周期（period）选择最长的免费时长12个月&lt;/li&gt;
&lt;li&gt;输入邮箱，注册Freenom账号&lt;/li&gt;
&lt;li&gt;进入邮箱查看Freenom发来的确认邮件&lt;/li&gt;
&lt;li&gt;点击邮箱中的链接完成注册&lt;/li&gt;
&lt;li&gt;进入我的域名（My Domains）查看刚刚注册的域名，到此Freenom完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;https修改&#34;&gt;HTTPS修改&lt;/h1&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;打开github-点击注册的仓库名-点击设置-下拉找到Enforce HTTPS选中对话框（注：此步骤为）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;cloudflare&#34;&gt;Cloudflare&lt;/h1&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;Cloudflare域名解析，打开&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;官网&lt;/a&gt;，点击注册&lt;/li&gt;
&lt;li&gt;输入邮箱创建账号Cloudflare会发送邮件到注册邮箱，登陆邮箱点击确认邮箱&lt;/li&gt;
&lt;li&gt;点击添加节点（Add site），添加在Freenom中注册的免费域名，点击下一步&lt;/li&gt;
&lt;li&gt;还是选择免费DNS&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;类型&lt;/strong&gt;中选择CNAME；&lt;strong&gt;名称&lt;/strong&gt;中输入@；目标中输入你的github域名即（&lt;strong&gt;用户名&lt;/strong&gt;.github.io）&lt;/li&gt;
&lt;li&gt;TTL选项默认选择&amp;quot;Auto&amp;quot;即可。&amp;quot;Proxied&amp;quot;选项可根据需求选择是只进行域名解析&amp;quot;DNS only&amp;quot;还是需要通过Cloudflare进行代理&amp;quot;Proxied&amp;quot;，完成以上设置后，点击&amp;quot;Add Record&amp;quot;&lt;/li&gt;
&lt;li&gt;接着，在Cloudflare的Overview界面，有两个域名解析服务器的网址，复制这两个网址（复制cloudflare名称服务器NS值，打开&lt;strong&gt;Freenom&lt;/strong&gt;-登陆-点击&lt;strong&gt;services&lt;/strong&gt;,点击&lt;strong&gt;Management Tools&lt;/strong&gt;，点击&lt;strong&gt;Use custom nameservers (enter below)&lt;/strong&gt;，在Namesever 1中输入复制内容；以相同步骤复制第二个NS值填入Namesever 2）&lt;/li&gt;
&lt;li&gt;复制完成后点击Change Namesevers 完成对域名替换&lt;/li&gt;
&lt;li&gt;修改完成后，等待几分钟，会收到来自CloudFlare的邮件，提示更新成功，即完成Cloudflare域名解析的配置工作&lt;/li&gt;
&lt;li&gt;结束&lt;br&gt;
主要参考文献：&lt;a href=&#34;https://zhenhuizhang.tk/post/freenom-mian-fei-yu-ming-ji-cloudflare-yu-ming-jie-xi/&#34;&gt;渣渣晖のBlog&lt;/a&gt;&lt;br&gt;
       &lt;a href=&#34;https://gridea.dev/gridea-start/&#34;&gt;Gridea简明教程&lt;/a&gt;&lt;br&gt;
       &lt;a href=&#34;https://www.jianshu.com/p/e02371079daa&#34;&gt;Freenom教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Gridea简单教程+Freenom+Cloudflare</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/comsol-bian-jie-tiao-jian/"" data-c="
          &lt;p&gt;&lt;strong&gt;固体物理学&lt;/strong&gt;，&lt;strong&gt;传热&lt;/strong&gt;，&lt;strong&gt;压力声学&lt;/strong&gt;，&lt;strong&gt;电流&lt;/strong&gt;物理场下的&lt;strong&gt;狄氏&lt;/strong&gt;、&lt;strong&gt;纽曼&lt;/strong&gt;、&lt;strong&gt;洛平&lt;/strong&gt;这三类边界条件。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;狄氏条件&lt;/strong&gt;用于指定要求解的变量。&lt;br&gt;
&lt;strong&gt;纽曼条件&lt;/strong&gt;用于指定通量，也就是因变量的梯度。&lt;br&gt;
&lt;strong&gt;洛平条件&lt;/strong&gt;结合了前两类边界条件，用于指定变量及其梯度之间的关系。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;物理场&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;狄氏条件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;纽曼条件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;洛平条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;em&gt;&lt;strong&gt;固体力学&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位移&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;牵引力&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;弹簧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;em&gt;&lt;strong&gt;传热&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;温度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;热通量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;em&gt;&lt;strong&gt;压力声学&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;声压&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;法向加速度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;阻抗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;em&gt;&lt;strong&gt;电流&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定电势&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定电流&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;阻抗&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;纽曼条件&#34;&gt;纽曼条件&lt;/h1&gt;
&lt;p&gt;纽曼条件是“&lt;strong&gt;载荷&lt;/strong&gt;”，出现在方程组右侧。在 COMSOL Multiphysics 的方程视图中，这类边界条件显示为弱贡献。纽曼条件纯粹是方程组右侧附加的贡献，因此可以包含以下变量的任何函数：&lt;strong&gt;时间&lt;/strong&gt;、&lt;strong&gt;坐标&lt;/strong&gt;或&lt;strong&gt;参数值&lt;/strong&gt;。&lt;br&gt;
例如：我们来看一个传热问题，其中半径为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的圆形热源沿&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;轴方向以速度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;v&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;移动。其强度分布呈抛物线形，峰值为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。此载荷的数学描述可以是&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;/mfrac&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo fence=&#34;true&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q(x,y,t) = q_0 \left( (1- \left(r \over R \right)^2 \right)  ,  r=\sqrt{((x-vt)^2+y^2)} , r&amp;lt;R
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size2&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size2&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3540079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.6029em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.24em;vertical-align:-0.25612499999999994em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord sqrt&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.983875em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3.2em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;padding-left:1em;&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.9438750000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail&#34; style=&#34;min-width:1.02em;height:1.28em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.28em&#39; viewBox=&#39;0 0 400000 1296&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.25612499999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;狄氏条件&#34;&gt;狄氏条件&lt;/h1&gt;
&lt;p&gt;当给定狄氏条件时，因变量就指定了，所以无须对其求解。我们可以从问题中删除这一类自由度方程。因此狄氏条件会改变刚度矩阵的结构。在 COMSOL Multiphysics 的方程视图中，这类条件显示为约束。&lt;br&gt;
假定要将移动点的温度指定为刚好 450 K，这或许有点刻意，但是能表现出纽曼条件和狄氏条件之间的一个重要区别。假如要添加一个温度 节点并输入类似表达式&lt;code&gt;( if(r&amp;lt;R,450[K],0))&lt;/code&gt;，这意味着将热点不会覆盖的那部分边界的温度设定为绝对零度。&lt;br&gt;
不过，我们的目的是在&lt;strong&gt;热点之外停用狄氏条件&lt;/strong&gt;。为此可以使用一个小窍门：输入 &lt;code&gt;if(r &amp;lt; R,450[K],ht.Tvar) &lt;/code&gt;作为指定值，就能获得所期望的停用。&lt;/p&gt;
&lt;h2 id=&#34;弱约束&#34;&gt;弱约束&lt;/h2&gt;
&lt;p&gt;在 COMSOL Multiphysics 中，狄氏条件实际上有两种可能的实现方式：默认情况下为上文所提到的逐点约束，还可以使用弱约束。在弱约束中，我们要添加方程，而不是移除方程。热通量添加为额外的自由度（拉格朗日乘子），以强制指定温度值。&lt;br&gt;
只要对上面的温度表达式稍作更改，就可以使用本质上相同的窍门使弱约束含条件限制。要使用弱约束，须先启用高级物理场接口选项。&lt;br&gt;
在物理场接口内对某个节点选中弱约束后，拉格朗日乘子上就会添加额外的自由度。这个示例中，该自由度名为 &lt;code&gt;T_lm&lt;/code&gt;。&lt;br&gt;
如果应用了上文中的温度表达式，那么在停用狄氏条件的边界部分，此额外自由度不会得到任何刚度矩阵的贡献，刚度矩阵由此变为奇异矩阵。为了避免这种情形，我们将&lt;code&gt;if(r &amp;lt; R,450[K],ht.Tvar)&lt;/code&gt;更改为&lt;code&gt; if(r &amp;lt; R,450[K],ht.Tvar-T_lm*1e-2)&lt;/code&gt;。不同的模型和物理场，&lt;code&gt;T_lm &lt;/code&gt;所用的乘子也不同，因此可能需要进行一些调整。&lt;/p&gt;
&lt;h1 id=&#34;洛平条件&#34;&gt;洛平条件&lt;/h1&gt;
&lt;p&gt;洛平条件通常都会影响刚度矩阵和方程右侧。虽然刚度矩阵的结构不会受到影响，但现有位置上会添加值。在方程视图 中，洛平条件同样显示为&lt;em&gt;弱&lt;/em&gt;贡献。将这类条件转换为关于时间、空间和其他变量的函数，这与使用纽曼条件时的做法一致。&lt;br&gt;
不过有趣的是，选择合适的值确实可以转换洛平条件，使之近似为狄氏条件或纽曼条件。如果仿真期间你希望在这两类边界条件之间切换，那么这一点十分重要。&lt;br&gt;
要创建狄氏条件，需要对“刚度”指派一个高值，例如弹簧常数或传热系数。在数学术语中，这实质上是狄氏条件的&lt;em&gt;罚&lt;/em&gt;实现。刚度越高，自由度的指定值就越精确。但这里需要注意：刚度过高会影响刚度矩阵的数值稳定性。而在传热问题中，要选择“高”的传热系数 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，起始值可以是&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mfrac&gt;&lt;mi&gt;λ&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha=1000\frac {\lambda} {h}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.05744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.37144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;λ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;λ&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\lambda&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;λ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示导热系数，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示特征单元尺寸。&lt;br&gt;
用适当的材料属性（也就是固体力学中的杨氏模量）替换 ，即可以在其他物理场实现相同的计算。将因子设为 1000 只是一个建议，可以替换成 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;10^4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 或 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;br&gt;
当年刚刚开始使用有限元分析时，我有时无法在结构力学的有限元程序中指定非零位移。这一限制是由于编程越来越复杂造成的。遇到这种情况时，最佳方法是添加预变形的刚性弹簧来使用罚函数法。但是刚度不能过大；因为那时还在采用用单精度运算！&lt;br&gt;
下面，我们转而讨论近似为纽曼条件。我们希望热通量与表面温度无关。在传热这一示例中，洛平条件声明向内热通量 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q=\alpha(T_{ext}-T)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示传热系数，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示边界温度，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T_{ext}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示外部温度。&lt;br&gt;
所以如果 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T_{ext}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;比表面预期温度高很多，那么&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;≈&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q\approx \alpha T_{ext}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.6775599999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≈&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。则采用的策略可以是选择一个任意大的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T_{ext}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，然后计算一个合适的传热系数。&lt;br&gt;
在实际情况中，设计人员利用这一原理将以下固定力引入实际机械部件中：又长又软的预应力弹簧。如果弹簧的预变形远大于与弹簧连接的部件的位移，则弹簧的力几乎保持不变。&lt;br&gt;
参考地址：&lt;a href=&#34;https://cn.comsol.com/blogs/how-to-make-boundary-conditions-conditional-in-your-simulation/&#34;&gt;如何设置特殊边界条件&lt;/a&gt;&lt;/p&gt;
">Comsol边界条件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/yuan-liu-wen-mai-yu-gao-shan/"" data-c="
          &lt;p&gt;文化发展史上的源流和高山&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;源流&#34;&gt;源流&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;易&lt;/strong&gt;：&lt;strong&gt;《河图》《洛书》《易经》&lt;/strong&gt;，群经之首，华夏文明的总源头。&lt;br&gt;
&lt;strong&gt;道&lt;/strong&gt;：&lt;strong&gt;《道德经》&lt;/strong&gt;，三皇之学的集大成，是对易的总结和升华。后世儒法两家的思想根源。老子的思想，后来发展出了五个比较突出的流派。鬼谷子，杨朱，苏秦张仪，韩非子、申不害，庄子、列子，关尹子、尹文，被称之为老学五派。孔子，也是老子的思想传人。&lt;br&gt;
&lt;strong&gt;儒&lt;/strong&gt;：&lt;strong&gt;《礼记》《论语》《尚书》&lt;/strong&gt;。儒为周朝之学，奠基人是周公，由孔子发扬光大。道为儒之本，儒为道之末。&lt;br&gt;
&lt;strong&gt;法&lt;/strong&gt;：&lt;strong&gt;《管子》《商君书》《韩非》&lt;/strong&gt;。管仲、商君之书，源头为道家。韩非子，源头为道儒两家。&lt;br&gt;
&lt;strong&gt;医&lt;/strong&gt;：中医的思想源头，在易经。中医的四大名著为**《黄帝内经》《难经》《伤寒杂病论》《神农本草经》&lt;strong&gt;。有人把《温病条辩》列入中医四大名著，这不合适，温病学说，不是至道，它只是道的一个方面，这种只能叫方医。《难经》思想，承自《黄帝内经》。《黄帝内经》是中医的最高经典，世人不读内经，用伤寒的方剂思想来总括中医，甚至把中医等同于中药，这是非常非常堕落的，这是文盲中医。&lt;br&gt;
&lt;strong&gt;兵&lt;/strong&gt;：代表书籍是在宋朝编撰的&lt;/strong&gt;《武经七书》&lt;strong&gt;，兵家的思想总源头，是易和道。《武经七书》由&lt;/strong&gt;《孙子兵法》《吴子兵法》《六韬》《司马法》《三略》《尉缭子》《李卫公问对》**七部著名兵书汇编而成。世人喜欢把兵家思想，照搬到商战上去，不过，如果不懂道，又怎么用兵呢，瞎比划也没什么用。&lt;br&gt;
至道四经：《道德经》《庄子》《黄帝内经》《黄帝阴符经》👈&lt;/p&gt;
&lt;h1 id=&#34;文脉&#34;&gt;文脉&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;伏羲&lt;/strong&gt;：&lt;strong&gt;《河图》《洛书》《伏羲八卦》&lt;/strong&gt;，我们民族文化一切的总源头。伏羲之于华夏，如同太阳之于万物。&lt;br&gt;
&lt;strong&gt;神农&lt;/strong&gt;：&lt;strong&gt;《神农本草经》&lt;/strong&gt;。神农就是炎帝，炎黄子孙，黄帝占一半，神农占一半。炎黄部落融合，是中原统一的基础。这本书，讲的是医家至道。本草纲目那些乱七八糟的书，是对《神农本草经》在传承上的污染。&lt;br&gt;
&lt;strong&gt;黄帝&lt;/strong&gt;：&lt;strong&gt;《黄帝内经》《黄帝阴符经》《黄帝四经》&lt;/strong&gt;。内经讲治身奉生之道，而要治身，就得理解天地之道，所以内经里，多数讲的还是天地大道，它是中医之宗之源。离开内经讲中医，如同脚不连地去走路。阴符经，讲宇宙万物的一本书，语言极其凝练简洁。黄帝四经，是一本讲治国理政的书。&lt;br&gt;
&lt;strong&gt;伊尹&lt;/strong&gt;：&lt;strong&gt;《汤液经法》《汤誓》《伊训》&lt;/strong&gt;。商朝建国的奠基人，伟大的政治家，也是伟大的医学家。伊尹进一步发展了神农本草经。他是张仲景方剂理论的源头。&lt;br&gt;
&lt;strong&gt;文王&lt;/strong&gt;：统一天下，为八卦做卦辞。周朝八百年，奠定了华夏文明走向成熟的基础。&lt;br&gt;
&lt;strong&gt;姜尚&lt;/strong&gt;：&lt;strong&gt;《三韬》《六略》&lt;/strong&gt;。很多人认为，道家就是画符捉鬼修炼丹修仙的那些人，完全不是这样。真正代表道家思想和精神的，是伊尹，姜尚，管仲，黄石公，鬼谷子，张良这样的人。那些炼丹修仙画符捉鬼的，只是道家的一个旁门小术。道家的最高思想，就是治理天下的帝王之道。&lt;br&gt;
&lt;strong&gt;周公&lt;/strong&gt;：&lt;strong&gt;《礼记》&lt;/strong&gt;。孔子的精神导师，封建制的创立者，宗法制的创立者，影响中国几千年，塑造了后世几千年的中国文化面貌。&lt;br&gt;
&lt;strong&gt;老子&lt;/strong&gt;：&lt;strong&gt;《道德经》&lt;/strong&gt;。道德经是三皇之学，它所讲的道，和河图洛书，和易经里的思想和道理，都是相通的。伯阳立教，影响深远。所谓的百家争鸣，不过是道裂为百。所有的各家，总源头，都可以在这里找到。&lt;br&gt;
&lt;strong&gt;管仲&lt;/strong&gt;：&lt;strong&gt;《管子》&lt;/strong&gt;。这是一本神奇的伟大的书，里面不仅讲怎么治国，还讲经济，讲管理。现在所有的经济学著作，所有的管理学著作，加起来都比不上这一本书，因为它讲的是道。&lt;br&gt;
&lt;strong&gt;商鞅&lt;/strong&gt;：&lt;strong&gt;《商君书》&lt;/strong&gt;。三千年皆为秦政，这个秦政理论总源头，就在这本书里。商鞅塑造了秦政，秦政又塑造了中国后世几千年的国家样貌。可以认为，是商鞅影响并间接塑造了中国几千年的历史。&lt;br&gt;
&lt;strong&gt;鬼谷子&lt;/strong&gt;：&lt;strong&gt;《鬼谷子》《鬼谷子阴符本经七术》&lt;/strong&gt;。这两本书，深不可测。有人认为，只是权诈之术，并非如此。鬼谷子的思想，讲的不是术，而是圣人之道。&lt;br&gt;
&lt;strong&gt;孔子&lt;/strong&gt;：&lt;strong&gt;《论语》《易传》《春秋》《诗经》《尚书》&lt;/strong&gt;。根深蒂固的影响了中国几千年，中国人的伦理观念，大多都是由孔子塑造的。孔子的思想，已经融入了中国人的血液中。孔子之后，儒分为八，不过孟子荀子之后，大儒就少了。很多人，把贱儒们的帐，都算孔子头上，这显然不对。孔子的道，讲的是大道，是经世济国，开万世太平的大道。后来那些愚不可及的腐儒贱儒，并非孔子之道。体现孔子最高思想的书，是《易传》。&lt;br&gt;
&lt;strong&gt;庄子&lt;/strong&gt;：&lt;strong&gt;《庄子》&lt;/strong&gt;。有的人，思想可以突破一隅，有的人思想可以突破一方。有的人思想可以突破地球。有的人思想可以突破银河系。庄子的思想，突破了宇宙。很多时候，他是站在宇宙之外看宇宙，看累了，就撇两眼地球上的蓝星人。&lt;br&gt;
&lt;strong&gt;孟子&lt;/strong&gt;：&lt;strong&gt;《孟子》&lt;/strong&gt;。孟子思想的核心，讲的是义，有义的人，就是大丈夫。失道亡德，礼崩乐坏，仁已不存，那么义不可再失。孟子是一个守城人，以一个义来对抗整个崩坏的社会。他觉得，一个人如果不讲义，跟禽兽有什么区别呢。他特别喜欢说别人是禽兽。&lt;br&gt;
&lt;strong&gt;荀子&lt;/strong&gt;：&lt;strong&gt;《荀子》&lt;/strong&gt;。孟子失守之后，荀子开始以礼守道，主张性恶论。提倡化性起伪，对百姓进行自上而下主动规训式的的教化，而不能靠他们的自觉，因为他们本来都很坏，不可能自觉。荀子研究的是帝王之术，强调经世致用的大儒精神。在他看来，不能结束社会战乱，带来国家天平的思想，都是没有价值的弱智言论。他认为大多数思想家，都是弱智，因为他们的思想没有用。&lt;br&gt;
&lt;strong&gt;韩非&lt;/strong&gt;：&lt;strong&gt;《韩非子》&lt;/strong&gt;。荀子的学生，也是老子思想的学生。他升华了荀子的思想，主张以循名责实来控制百姓。他研究的是帝王之术，他对道德经的理解，比后世绝大多数人都深刻通透。秦始皇之所以能够统一中国，韩非子的思想，功不可没。&lt;br&gt;
&lt;strong&gt;屈原&lt;/strong&gt;：&lt;strong&gt;《离骚》《楚辞》&lt;/strong&gt;。和韩非子一样，也是一个极其聪明的人。他并不是一个单纯的爱国诗人和文学家，而是一个圣人和天才。他的治国思想，属于法家的那一套。有人把李白和屈原相并论，那个酒鬼，怎么能和屈原相比呢，差的太远了。诗歌只是屈原的副业，屈原的主业，是和韩非子一样，是要建立一个统一天下的大帝国。屈原说，我血统高贵，我名字高贵，我长的美，我一生下来就是个天才，我的思想也是天下最美的，可是楚王那个丑八怪癞蛤蟆不懂我，作为一个有精神洁癖和文化洁癖的人，跟楚王这个文盲癞蛤蟆周旋的没玩没了，跟一群脏兮兮的奸佞争来斗去，全是精神污染啊，恶心得我还不如死了算了，罢罢罢，于是便投河自尽。&lt;br&gt;
&lt;strong&gt;秦始皇&lt;/strong&gt;：结束战乱，统一天下。开三千年皆秦政的先河。塑造了后面几千年的中国政治基本模式。&lt;br&gt;
&lt;strong&gt;张良&lt;/strong&gt;：&lt;strong&gt;《素书》&lt;/strong&gt;。张良，是汉朝几百年江山的奠基之人，他之于汉朝，如同姜尚之于周朝。张良的思想，都来源自这本书。这是一本讲世间大道的书，读懂素书，行走人间，可以无往不利。👈&lt;br&gt;
&lt;strong&gt;陆贾&lt;/strong&gt;：&lt;strong&gt;《新语》&lt;/strong&gt;。汉朝文化建设的总设计师。他的思想，影响了汉朝几百年。&lt;br&gt;
&lt;strong&gt;刘彻&lt;/strong&gt;：在他之后，华夏族开始叫汉族。他为华夏人，铸就了汉魂。&lt;br&gt;
&lt;strong&gt;司马迁&lt;/strong&gt;：《史记》。读史可以知兴衰存亡之道，太史公对华夏文明的贡献，非常大。&lt;strong&gt;《史记》《汉书》《资治通鉴》&lt;strong&gt;最高的三本史学著作，又以《史记》最高。&lt;br&gt;
&lt;strong&gt;韩愈&lt;/strong&gt;：&lt;/strong&gt;《谏迎佛骨表》&lt;/strong&gt;，这是一篇千古檄文。韩愈提出了文化道统概念，主张复兴儒学，对中国文化进行清污与重建。他为宋朝理学家力辟奸邪，提供了一面精神旗帜。&lt;br&gt;
&lt;strong&gt;陈抟&lt;/strong&gt;：&lt;strong&gt;《太极图》《指玄篇》《无极图》&lt;/strong&gt;。开后世文化昌盛之先河，他深刻影响了北宋理学的鼻祖周敦颐。周敦颐又深刻影响了北宋五子中的其他几位和朱熹。他是一座高山。&lt;br&gt;
&lt;strong&gt;北宋五子和朱熹&lt;/strong&gt;：&lt;strong&gt;《周元公集》《张载集》《朱子语类》&lt;strong&gt;汉儒凋败之后，华夏文明的又一次文化昌盛时期。&lt;br&gt;
&lt;strong&gt;王夫之&lt;/strong&gt;：&lt;/strong&gt;《周易外传》、《黄书》、《尚书引义》、《永历实录》、《春秋世论》、《噩梦》、《读通鉴论》、《宋论》&lt;/strong&gt;。王夫之认为，宋朝亡国，和明朝亡国，都是因为程朱理学，与陆王心学，是亡国之学。他上承张载思想，重提经学的经世致用天职，以文载道，以道正天下。他对朱熹和王阳明尚清谈的无用学问，进行了大清算。&lt;br&gt;
王夫之对后世，极其重要，他把当时中国的文化中心，转移到了湖南。湖南在近代英杰辈出，就在于王夫之的思想辐射。他深刻影响了曾国藩，曾国藩又影响了谭嗣同，谭嗣同影响了杨昌济，杨昌济影响了毛泽东。王夫之说，一个人要是没有志向，跟禽兽没什么区别。他重新唤醒了士大夫们以天下为己任的那种大儒精神。&lt;br&gt;
&lt;strong&gt;辜鸿铭&lt;/strong&gt;：&lt;strong&gt;《中国人的精神》，也叫《春秋大义》&lt;/strong&gt;。他是过去的那个中国，最后一个精神贵族，他是清儒中的一个清流。清儒是几千年未有之异端邪说，是荀子所讲的那种贱儒，民国和共和国那些西学东渐的新儒家，则比清儒还贱。不过辜鸿铭是个例外，他是荀子说的那种大儒。他对儒家思想的理解，对中国文化的理解，非常深刻，同时对西方文化的理解和洞察，也非常的深刻。和他相比，鲁迅，林语堂，胡适之辈，都是文化盲流。&lt;br&gt;
&lt;strong&gt;毛泽东&lt;/strong&gt;：&lt;strong&gt;《毛泽东选集》&lt;/strong&gt;。王夫之一脉的思想，给毛泽东注入了精神动力，否则难以理解，为什么他小小年纪的时候，就以治国平天下为己任。毛泽东是新中国最有学问的一个人。他研究的是经世济国的大学问，他对历史，文化，政治，军事的洞察力，非常深刻，目光如炬的审视着一切。陈寅恪，郭沫若，冯友兰，钱钟书这样的，研究小学问的学者，自然无法和毛泽东相提并论。毛泽东对那些言必称古希腊古罗马的所谓的知识分子，内心里是很瞧不起的。&lt;br&gt;
有人说，钱钟书眼高过顶，是个谁都瞧不起的精神贵族，其实他并不是精神贵族，他并不懂天地之道，也不懂经世济国之道。他只是在学问的品味上格调上，比他所瞧不起的那些同行们高一些，但他和他的同行们所研究的这些学问本身，都不是什么大道，只是屑末小学。新中国成立以来，只有一个伟岸的大写的精神贵族，那就是毛泽东。&lt;/p&gt;
&lt;h1 id=&#34;高山&#34;&gt;高山&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;伏羲&lt;/strong&gt;：天根，道魂。&lt;br&gt;
华夏人的人文始祖，他把华夏人，从游牧文明，升级到农耕文明。他通过对天地万物的观察和理解，把华夏人的文明之根，深深的扎进了天道自然之中。如果没有伏羲，华夏人，可能跟现在那些对着空气瞎叨叨的奉妖事鬼的愚昧民族，没什么区别。因为有了伏羲，华夏人的文化和精神，和生活生产，都走上了一条理解世界，顺应自然，理解未来，趋吉避凶，成就大业的道路。&lt;br&gt;
&lt;strong&gt;黄帝&lt;/strong&gt;：祖根，祖魂。&lt;br&gt;
黄帝铸就了华夏人的祖根和祖魂。进一步发展了伏羲的思想，把华夏人的生存空间，从狭小的河洛平原，推进到了整个黄河流域，统一了整个中原地区。并且，在各个方面，都使得华夏文明大幅度进步。这个时期的人口大爆炸，奠定了华夏人的人口绝对优势，这个绝对优势太明显，以至于可以保证，即便后代出现了一些不肖子孙败家子，也不会使华夏人亡族亡种。&lt;br&gt;
&lt;strong&gt;秦始皇&lt;/strong&gt;：帝国根，帝国魂。&lt;br&gt;
继续把华夏人的生存空间，推进到了整个黄河，长江和珠江流域。秦帝国，是历代华夏人建立的帝国的标准版和母本。始皇帝，为华夏人的统一，做出了伟大的贡献。这次统一，比黄帝和大禹的统一，更为深刻，影响也更为深远。他不仅为帝国统治，创立了硬件的疆域标准，也为帝国统治，创立了郡县制和中央集权加文官体系，这个大帝国统治的政治系统。&lt;br&gt;
&lt;strong&gt;毛泽东&lt;/strong&gt;：世界根，世界魂。&lt;br&gt;
中国近代史的屈辱和磨难，比五胡乱华更甚，危亡形势也更凶险。为了不亡族亡种，无数的伟人英雄们，奋起救亡，图存图强。李鸿章没有立住，袁世凯没有立住，孙文没有立住，蒋介石没有立住，只有毛泽东立住了。他不仅立住了，而且还跟弓箭种、强盗种、野兽种、虫蛇种打了一圈，稳固住了中国的国防，牢牢守住了东北、新疆、西藏、朝鲜这些战略缓冲区，为华夏人的生存，创造了生存安全保险带。毛泽东为中国缔造了国魂，军魂，图强之魂，这就是现代中国自立于世界的根。&lt;br&gt;
摘自：&lt;a href=&#34;https://mp.weixin.qq.com/s/Tq2cQFBBYSj4LID2-lvxTw&#34;&gt;华夏文化谱系，中国人的根和魂&lt;/a&gt;&lt;/p&gt;
">源流，文脉与高山</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/zerotier-oneyuan-cheng-zhuo-mian-shi-xian-quan-ping-tai-yuan-cheng-lian-jie/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.zerotier.com/&#34;&gt;ZeroTier One&lt;/a&gt;可以实现将手机（安卓或iOS）、平板、电脑等平台建立在同一个局域网下，这样就可以使用微软自带的&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients&#34;&gt;远程桌面&lt;/a&gt;实现多平台远程控制。无缝实现在宿舍、实验室、户外、家中的远程桌面连接。ZeroTier One免费版可以实现100个客户端，对于个人应用完全可以满足，而且微软远程桌面也是完全免费的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1注册并登陆zerotier-one&#34;&gt;1.注册并登陆ZeroTier One&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://accounts.zerotier.com/auth/realms/zerotier/protocol/openid-connect/auth?client_id=zt-central&amp;amp;redirect_uri=https%3A%2F%2Fmy.zerotier.com%2Fapi%2F_auth%2Foidc%2Fcallback&amp;amp;response_type=code&amp;amp;scope=all&amp;amp;state=state&#34;&gt;点击注册&lt;/a&gt;，使用邮箱注册，需要你使用的邮箱进行注册确认。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1596081057849.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2在官网创建网络&#34;&gt;2.在官网创建网络&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1596081132012.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建一个新的网络之后，我们得到一个 Network ID，这个在后面的设备连接时需要用到，点击刚刚创建的网络我们可以设置更多选项；创建过程使用默认设置就可以。&lt;/p&gt;
&lt;h1 id=&#34;3电脑或者手机下载客户端&#34;&gt;3.电脑或者手机下载客户端&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zerotier.com/download/&#34;&gt;下载链接&lt;/a&gt;，电脑端点击加入网络（join network）输入刚才创建的 Network ID&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1596081366246.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4在官网允许客户端连接&#34;&gt;4.在官网允许客户端连接&lt;/h1&gt;
&lt;p&gt;官网设置如下&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1596081604082.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5测试检验&#34;&gt;5.测试检验&lt;/h1&gt;
&lt;p&gt;使用ipconfig查看到的：以太网适配器 ZeroTier One表示链接成功&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1596081753161.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
相同的方法建立另一个客户端可以使用pingIP地址进行检测。&lt;/p&gt;
&lt;h1 id=&#34;6远程桌面连接&#34;&gt;6.远程桌面连接&lt;/h1&gt;
&lt;p&gt;打开微软自带远程桌面，输入ip地址然后输入电脑名称和密码即可连接。&lt;br&gt;
这里win10家庭版没有远程桌面功能，电脑不设置密码也不能使用远程桌面连接。&lt;br&gt;
&lt;a href=&#34;https://support.microsoft.com/zh-cn/help/4028379/windows-10-how-to-use-remote-desktop&#34;&gt;Windows远程桌面打开方法&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients&#34;&gt;Windows远程桌面客户端&lt;/a&gt;&lt;/p&gt;
">ZeroTier One+远程桌面实现全平台远程连接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/zoterozotfilejian-guo-yun-wu-xian-liang-kong-jian-bei-fen-ni-de-lun-wen-ku/"" data-c="
          &lt;p&gt;  Zotero实现文献管理以及数据文件，zotfile为Zotero软件的文件管理插件可以自动提取pdf文件的论文名称、作者、年份、期刊等信息，坚果云作为pdf文献等的备份地址。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;zotero文献管理zotfile文献信息提取坚果云文献存储&#34;&gt;Zotero文献管理，zotfile文献信息提取，坚果云文献存储&lt;/h1&gt;
&lt;p&gt;  Zotero是一款开放性软件不用担心收费问题，其次该软件可以实现对论文添加自定义标签、总结等信息帮助你对文献进行总结和分类。但是Zotero云存储空间只有300M如果用来备份所有文件，只能备份很少量的论文。这里使用坚果云备份比较大的pdf文件使用Zotero只带云存储数据信息，这样将大大提高论文存储数量。配合zotfile软件插件使用，可以自动对文献内容提取，方便简洁快速对论文进行管理。&lt;br&gt;
  zotero下面有一个存储文件的文件夹就叫zotero，里面的storage文件夹是存储附件的（除了数据文件（包括网页、标签、笔记等）的就叫附件，比如pdf什么的），是和zotero云存储同步的。&lt;/p&gt;
&lt;p&gt;  本地文件夹是自己定义的，主要是为了解决zotero的云存储不足的问题，所以会把附件都存在这里，也就是storage 里面的pdf。之后这个文件夹会同步到坚果云里面去，怎么做我后面会讲。&lt;/p&gt;
&lt;p&gt;  还有一个就是坚果云的本地同步文件，这个是一个虚地址（我是这样理解的），如果你是从本地同步上去的话其实是不占用本地磁盘空间的，你会发现如果你点击坚果云下面的back-zotero，他会直接跳转到你的本地文件夹jianguoyun/back-zotero里面去。&lt;/p&gt;
&lt;p&gt;  好了，现在你们应该懂了我到底是怎么做的了吧，其实就是把zotero 里面的附件放到本地文件夹，然后再同步到坚果云，而不是通过zotero直接的云同步Webdav直接同步到坚果云，为什么？因为我发现同步上去的文章会乱码。&lt;/p&gt;
&lt;h1 id=&#34;zotero-zotfile-坚果云设置步骤&#34;&gt;Zotero-zotfile-坚果云设置步骤&lt;/h1&gt;
&lt;p&gt;  下载Zotero以及坚果云软件到本地计算机&lt;/p&gt;
&lt;h2 id=&#34;zotero设置&#34;&gt;Zotero设置&lt;/h2&gt;
&lt;h3 id=&#34;编辑首选项&#34;&gt;编辑/首选项&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136102516.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;同步&#34;&gt;同步&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;这里的数据同步是你的zotero账号信息。&lt;/strong&gt;&lt;br&gt;
  &lt;strong&gt;！！！注意文件同步全都不要勾！！！&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136095632.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;高级&#34;&gt;高级&lt;/h3&gt;
&lt;p&gt;  注意这里的数据存储位置：是你的zotero的数据存储位置，我这里是没有放在c盘放在了d盘。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136222519.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;zotfile设置&#34;&gt;zotfile设置：&lt;/h2&gt;
&lt;h3 id=&#34;图篇左上角设置&#34;&gt;图篇左上角设置&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136358546.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;常规设置&#34;&gt;常规设置&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136382050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;tablet-setting&#34;&gt;tablet Setting&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136486571.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
location of files 注意是你的本地文件夹的位置，比如我这里是D:\Application\jianguoyun\back-zotero，下面是你的本地文件夹的分类方式，这个可以在zotfile网站上查到相关分类标准。&lt;/p&gt;
&lt;h3 id=&#34;renaming-rules&#34;&gt;renaming rules&lt;/h3&gt;
&lt;p&gt;这个给主要是本地文件夹的命名规则。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136535832.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;advanced-setting&#34;&gt;advanced setting&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136575497.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;同步本地的文件夹到坚果云&#34;&gt;同步本地的文件夹到坚果云&lt;/h2&gt;
&lt;p&gt;  需要先下载坚果云客户端，不然右键单击不会有这个选项。这个网上很少有文章这样做，我也是挖了好久才挖到，这个步骤非常关键，不然就没办法在坚果云上看见了，之后你会发现坚果云上面就有了这个文件夹，而且在本地也有一个虚拟的坚果云文件夹。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1597136669519.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PS：关于如何使用zotero：网上有大量教程可以参考我就不再赘述了。&lt;br&gt;
参考地址：&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/93757626&#34;&gt;zotero、zotfile、坚果云之间的爱恨情长&lt;/a&gt;&lt;br&gt;
Zotero教程：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/misayaaaaa/article/details/53559689&#34;&gt;标准论文参考文献添加方法——Zotero入门使用教程&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/zhouchen1998/article/details/103298165&#34;&gt;Zotero使用教程&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.zotero.org/support/zh/quick_start_guide&#34;&gt;官方教程-quick_start_guide&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.ekexiu.com/shtml/a/20171025/102637.html&#34;&gt;“Zotfile插件” — 让Zotero插上翅膀！&lt;/a&gt;&lt;/p&gt;
">Zotero+zotfile+坚果云无限量空间备份你的论文库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/materials-studio-shi-yong-zong-jie/"" data-c="
          &lt;p&gt;材料计算软件Materials Studio常见操作说明&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;收敛性测试&#34;&gt;收敛性测试&lt;/h1&gt;
&lt;p&gt;先不选optimize cell优化一次，再选optimize cell优化；kpoints,ecut的收敛测试可以选取一系列不同的kpoints，ecut计算并比较单点能。能量差达到差不多1mev就算是收敛了&lt;br&gt;
结果除了检查能量变化之外，也最好检查一下原胞上的应力和原子间相互作用力是否已经收敛&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1615190433984.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1614776367109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1614776381086.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;optimize-cell&#34;&gt;optimize cell：&lt;/h1&gt;
&lt;p&gt;在优化晶胞时，需要选上；在计算界面时就不需要勾选。&lt;br&gt;
勾选上optimize cell后，晶格参数和原子占位都会发生变化，如果不选，晶格参数是不会发生变化的，但是，原子的位置还是会变化的。&lt;/p&gt;
&lt;h1 id=&#34;移动分子&#34;&gt;移动分子&lt;/h1&gt;
&lt;p&gt;按住键盘上的Shift+Alt键，再利用鼠标右键拖拽，就可以将选中的片段移动到合适的地方了&lt;br&gt;
如果要进行比较细致的位置调整，可以按下键盘上的Shift+Alt+上下左右方向键，从而在各个方向上进行调整，放大结构可以使得每次调整更加精细&lt;/p&gt;
&lt;h1 id=&#34;恢复初始设置&#34;&gt;恢复初始设置&lt;/h1&gt;
&lt;p&gt;Tools-Settings Organizer                        class-reset&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1615251770613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;job-control&#34;&gt;job control&lt;/h1&gt;
&lt;p&gt;核数选择以及&lt;br&gt;
勾选optimize number of cores of the fly。动态调节核心&lt;br&gt;
选择（speed）速度优化&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1615252059339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;转换为原胞提高计算速度&#34;&gt;转换为原胞提高计算速度&lt;/h1&gt;
&lt;p&gt;选择是；如果是对界面进行优化，固定了下层原子了，就不需要转换为原胞了&lt;/p&gt;
&lt;h1 id=&#34;转换为常规晶胞&#34;&gt;转换为常规晶胞&lt;/h1&gt;
&lt;p&gt;build-symmetry-conventional cell&lt;br&gt;
显示设置-defult&lt;/p&gt;
&lt;h1 id=&#34;表面切割&#34;&gt;表面切割&lt;/h1&gt;
&lt;p&gt;切割厚度为周期性晶胞切割多厚，也即切割后的Z轴的长度&lt;/p&gt;
&lt;h1 id=&#34;真空层厚度&#34;&gt;真空层厚度&lt;/h1&gt;
&lt;p&gt;选择8埃米，实际计算中选择1nm到2nm之间，也即10埃米-20埃米&lt;/p&gt;
&lt;h1 id=&#34;晶胞朝向更改&#34;&gt;晶胞朝向更改&lt;/h1&gt;
&lt;p&gt;lattice parameter-advanced-orientation standard朝向标准-C along Z，B in YZ plane C方向沿着Z轴，B方向在YZ平面内；keep fractional coordinates fixed during changes to the lattice （保持分数坐标固定）然后点击re-orient to standard&lt;/p&gt;
&lt;h1 id=&#34;显示设置&#34;&gt;显示设置&lt;/h1&gt;
&lt;p&gt;original-显示晶胞内有多少不同的原子&lt;/p&gt;
&lt;h1 id=&#34;表面几何优化&#34;&gt;表面几何优化&lt;/h1&gt;
&lt;p&gt;固定下层原子，仅对顶层原子进行优化modify-constraints-fix fractional position&lt;/p&gt;
&lt;h1 id=&#34;气体分子优化&#34;&gt;气体分子优化&lt;/h1&gt;
&lt;p&gt;由于气体分子不是晶胞，所以计算DOS时，DOS的k-point可以选择gamma点计算&lt;br&gt;
气体分子不是晶体所以优化时也选择no，不转换为原胞提高速度&lt;/p&gt;
&lt;h1 id=&#34;使用对称性简化模型提高计算&#34;&gt;使用对称性简化模型提高计算&lt;/h1&gt;
&lt;p&gt;find symmetry简化模型&lt;/p&gt;
&lt;h1 id=&#34;态密度dos&#34;&gt;态密度DOS&lt;/h1&gt;
&lt;p&gt;metal是否为金属，charge是否带电荷；固体材料晶体的晶胞进行优化，固定体积和固定形状以及全优化，块体材料一般为全优化。&lt;/p&gt;
&lt;h1 id=&#34;能带路径选择&#34;&gt;能带路径选择&lt;/h1&gt;
&lt;p&gt;band structural，能带扫描路径选择；以及取值点步进值的选取&lt;/p&gt;
&lt;h1 id=&#34;实验-计算&#34;&gt;实验-计算&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1615271985972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;不同表面的呈现&#34;&gt;不同表面的呈现&lt;/h1&gt;
&lt;p&gt;材料不同的表面的呈现：提前预览不同表面的原子tool-Miller planes&lt;/p&gt;
&lt;h1 id=&#34;表面结构的构建&#34;&gt;表面结构的构建&lt;/h1&gt;
&lt;p&gt;cleave surface：cleave plane（实验和文章说明那些晶面性质好）或者所有晶面的计算&lt;br&gt;
top不同，裸露原子不同，形成的性质之不同&lt;br&gt;
thickness，切面的厚度也即原子层数的不同（至少3-4层）&lt;br&gt;
添加真空层15-20埃米消除C方向的影响&lt;br&gt;
表面吸附计算：先进性超胞然后再放置小分子-消除周期结构的影响，两个小分子最小距离为8-10埃米&lt;br&gt;
作用位点-作用方式的改变&lt;br&gt;
创建拟合面：选中三个原子-绘制工具条best fit plane（第三个）然后测量距离（物理吸附化学吸附初步判断）一般放置初始距离为3.5-4埃米；或者2.0埃米加速优化等&lt;br&gt;
键锤子与下表面：选中键-工具栏拟合线（best fit line）；西东原子分子栏，选择垂直与下表面&lt;/p&gt;
&lt;h1 id=&#34;菱形晶胞改为矩形晶胞&#34;&gt;菱形晶胞改为矩形晶胞&lt;/h1&gt;
&lt;p&gt;Build---symmetry---redefine lattice 打开如下图所示对话框，然后再红色款选部分设置&lt;br&gt;
如下图，然后再点击 Redefine 即可。&lt;br&gt;
A：1 1 0&lt;br&gt;
B：-1 1 0&lt;br&gt;
C：0 0 1&lt;/p&gt;
&lt;h1 id=&#34;表面收敛性测试&#34;&gt;表面收敛性测试&lt;/h1&gt;
&lt;p&gt;问题 3：我想问一下，castep 模块对体胞模型进行收敛性测试之后，切面的还是需要收敛性测&lt;br&gt;
吗？还是说用体胞收敛后的参数也可以&lt;br&gt;
解答：对晶胞结构进行了收敛性测试后，可以不再对表面结构进行测试，但是切面的原子层数&lt;br&gt;
（即表面的厚度）还是要测试一下的。&lt;/p&gt;
&lt;h1 id=&#34;population-analysis&#34;&gt;population analysis&lt;/h1&gt;
&lt;p&gt;CASTEP中的population analysis指的是布居分析吧。&lt;br&gt;
1、这个是什么布居分析，好像有好多种，mulliken 什么的。&lt;br&gt;
2、通过布居分析貌似可以得到每个原子的电荷量，请问还能得到别的吗？&lt;br&gt;
3.mulliken布居分析就是CASTEP中的population analysis&lt;br&gt;
布局分布可以：1看到电荷的转移，2通过比较反应前后bond population可以看出健的变化。选energy，然后property中选population analysis就行，可以把bond population加上。&lt;/p&gt;
&lt;h1 id=&#34;表面优化-切面选择&#34;&gt;表面优化-切面选择&lt;/h1&gt;
&lt;p&gt;问题 2：请问我构建的 CuO 模型经过 VASP 优化之后变形特别厉害，固定 4 层，松弛 4 层，是&lt;br&gt;
什么原因啊&lt;br&gt;
解答：表面结构的终端面切的不对。&lt;/p&gt;
&lt;h1 id=&#34;dftu计算过渡金属&#34;&gt;DFT+U计算过渡金属&lt;/h1&gt;
&lt;p&gt;在使用+U model的过程中，我一直在思考这个U参数的本质，即U大一点意味着什么，小一点意味着什么？我们想，既然它是DFT能量能量对电荷密度变化的二阶导，那么有点类似与振动频率。在分子中，如果一根键的强度很高，那么振动频率就很高；如果键强度低，振动就弱，比如C=C双键就比C-C单键的振动频率高。类比的话，应该说U代表了d/f电荷密度随外部势（比如其它原子核对它的作用）的变化而变化的难易程度。如果U大，那么不容易变化；如果U小，则容易变化。在不使用+U模型时，那就是说U=0，这时d/f电子最容易受外部势的影响而左右摇摆，从宏观上来看，就是分布比较均匀，能带很宽。一旦+U以后，立即受到束缚，从而能带变窄。这和+U的实际作用正好一致。&lt;br&gt;
进一步，Hubbard原子上的U参数与材料的金属性-非金属性的有一种联系：材料的金属性越强，U越小；材料非金属性越强，U越大。这从Cococcioni博士论文中的数据可以看出来：在金属态中，铁Fe的U为2.2, 铁磁FeO中为4.29， 而绝缘体Fe&lt;sub&gt;2&lt;/sub&gt;SiO&lt;sub&gt;4&lt;/sub&gt;中为 4.9/4.6. 所以，如果你得到的U很小，很可能意味着你的体系的金属性很强。当然，这并不意味着你可以不使用U，U虽小仍然可能大大改善能带的分布。&lt;br&gt;
&amp;quot;在不使用+U模型时，那就是说U=0，这时d/f电子最容易受外部势的影响而左右摇摆，从宏观上来看，就是分布比较均匀，能带很宽。一旦+U以后，立即受到束缚，从而能带变窄。&amp;quot;&lt;br&gt;
这句话容易引起歧义，补充一下，U越大，能带越宽，对应带隙越小；U越小，能带变窄，对应带隙越大。不过这只是一个简单理论分析，是否真的对所有材料都是如此，由于本人研究过的体系有限，不敢下定结论。欢迎补充。&lt;/p&gt;
">Materials Studio使用总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/zoteroscihubzi-dong-xia-zai-bao-cun-wen-xian/"" data-c="
          &lt;p&gt;  Zotero论文管理，在网页上看到喜欢的论文直接保存到Zotero，然后自动在Scihub中搜索论文并下载到本地&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;目前（截止2021.05.12），可用的Sci-Hub域名有以下几个：&lt;br&gt;
&lt;a href=&#34;https://sci-hub.do&#34;&gt;https://sci-hub.do&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://sci-hub.ren&#34;&gt;https://sci-hub.ren&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://sci-hub.st&#34;&gt;https://sci-hub.st&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://sci-hub.se&#34;&gt;https://sci-hub.se&lt;/a&gt;&lt;br&gt;
如果你想及时获取Sci-Hub最新可用网址，可以到&lt;a href=&#34;https://tool.yovisun.com/scihub/&#34;&gt;SCI-HUB最新文献网址&lt;/a&gt;查看。&lt;br&gt;
理论上以上四个都可以使用，大家可以自行更换完整代码中内容(https://sci-hub.ren/)。&lt;br&gt;
顺便把我的完整代码贴出来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;:&amp;quot;Sci-Hub&amp;quot;,
    &amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,
    &amp;quot;url&amp;quot;:&amp;quot;https://sci-hub.ren/{doi}&amp;quot;,
    &amp;quot;mode&amp;quot;:&amp;quot;html&amp;quot;,
    &amp;quot;selector&amp;quot;:&amp;quot;#pdf&amp;quot;,
    &amp;quot;attribute&amp;quot;:&amp;quot;src&amp;quot;,
    &amp;quot;automatic&amp;quot;:true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;zotero自带的pdf搜索&#34;&gt;Zotero自带的PDF搜索&lt;/h1&gt;
&lt;p&gt;从Zotero 5.0.56版本开始，Zotero迎来了PDF retrieval功能。&lt;br&gt;
该功能会在你用Zotero Connector保存文献时，自动检查Unpaywall上是否有可供下载的免费文献。&lt;br&gt;
假如你在网页端保存的文献是&lt;strong&gt;Open Access&lt;/strong&gt;的，Zotero Connector就会将PDF同文献条目一起抓取。&lt;br&gt;
当然，对于已经在Zotero中却还没有PDF附件的文献条目，点击右键菜单中的Find Available PDF，即可下载文献，比如下面这样。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620824193032.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是，毕竟Unpaywall只支持OA文献，而OA文献又只是少数。也就是说，通过Unpaywall无法解决付费文献的下载问题。&lt;br&gt;
Zotero允许用户自定义PDF解析器（custom PDF resolvers），也就是说你可以将其他网站作为PDF解析器，来替代Unpaywall。&lt;br&gt;
这为我们将Sci-Hub作为PDF resolver带来可能！&lt;br&gt;
下面具体介绍如何将Sci-Hub作为PDF解析器！&lt;/p&gt;
&lt;h1 id=&#34;设置sci-hub作为zotero的pdf解析器&#34;&gt;设置Sci-Hub作为Zotero的PDF解析器&lt;/h1&gt;
&lt;p&gt;PDF resolvers的设置在Zotero的Config Editor中。&lt;br&gt;
我们打开Zotero的首选项，进入Advanced--&amp;gt;Config Editor。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620824334771.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
搜索&lt;code&gt;extensions.zotero.findPDFs.resolvers&lt;/code&gt;，如下&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620824382831.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击&lt;code&gt;extensions.zotero.findPDFs.resolvers&lt;/code&gt;，默认情况下是只有一对&lt;code&gt;[]&lt;/code&gt;。&lt;br&gt;
删除&lt;code&gt;[]&lt;/code&gt;，并将以下代码粘贴进去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;:&amp;quot;Sci-Hub&amp;quot;,
    &amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,
    &amp;quot;url&amp;quot;:&amp;quot;https://sci-hub.ren/{doi}&amp;quot;,
    &amp;quot;mode&amp;quot;:&amp;quot;html&amp;quot;,
    &amp;quot;selector&amp;quot;:&amp;quot;#pdf&amp;quot;,
    &amp;quot;attribute&amp;quot;:&amp;quot;src&amp;quot;,
    &amp;quot;automatic&amp;quot;:true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后点击OK。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620824514919.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到此就成功将Sci-Hub配置为PDF解析器了，也就是说替代了默认的Unpaywall。&lt;br&gt;
现在，无需重启Zotero，即可调用Sci-Hub免费下载文献了。&lt;/p&gt;
&lt;h1 id=&#34;附录&#34;&gt;附录&lt;/h1&gt;
&lt;p&gt;1.列出的Scihub的网址，理论上大家可以随意用一个。&lt;br&gt;
2.本方法是通过文章的doi号进行下载的，所以论文必须要有doi才可以&lt;br&gt;
3.&lt;code&gt;&amp;quot;automatic&amp;quot;:true&lt;/code&gt;，如果设置为true，Zotero会自动下载保存到Zotero中的文献的PDF。比如你用Zotero Connector保存了一些文献到Zotero，它便会自动帮你从Sci-Hub下载文献，并附在相应文献条目下。如果你不需要自动下载，可以设置为&lt;code&gt;&amp;quot;automatic&amp;quot;:false&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;论文添加方法&#34;&gt;论文添加方法&lt;/h2&gt;
&lt;p&gt;1.通过软件内doi号添加保存文献，自动下载PDF，，无需任何操作。（看不到进度条，下载速度取决于网速）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620825302501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.通过浏览器插件Zotero Connector保存的文献，会自动下载PDF，无需任何操作。（看不到进度条，下载速度取决于网速）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620825523102.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3.Find Available PDF：选中单篇或者多篇文献，手动点击右键菜单中的Find Available PDF，会弹出单独的窗口显示下载进度。同样，下载速度取决于网络速度。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1620825584086.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到此，本文就介绍完了！&lt;/p&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;参考链接：&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112141757&#34;&gt;知乎&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://tool.yovisun.com/scihub/&#34;&gt;SCI-Hub论文下载可用网址链接&lt;/a&gt;&lt;/p&gt;
">Zotero+Scihub:自动下载保存文献</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/vasp-xue-xi-zong-jie/"" data-c="
          &lt;p&gt;vasp学习常用参数设置以及纠错&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;incar&#34;&gt;INCAR&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;SYSTEM = O atom     ##元素符号（计算说明，可以随便写）
ISMEAR = 0          ##对于分子和原子使用0（不同的值对应的不同的展宽方法，分子原子用0 https://www.bigbrosci.com/2017/10/15/ex1_02_vasp_preparation_input_incar/）
SIGMA = 0.01        ##对于分子或原子使用0.01（与ismear息息相关，参考网址同上）标准是SIGMA取值要保证OUTCAR中的entropy T*S 这一项，平均到每个原子上小于0.001 eV也就是1meV
使用命令检查（grep &#39;entropy T&#39; OUTCAR）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;气相分子计算&lt;/strong&gt;，我们要用ISMEAR=0，SIGMA取值要小，&lt;strong&gt;SIGMA=0.02&lt;/strong&gt;；&lt;a href=&#34;https://www.bigbrosci.com/2017/12/14/ex22/?highlight=%E6%B0%94%E7%9B%B8%E5%88%86%E5%AD%90&#34;&gt;By Bigbrosci&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635771143608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.初始参数、2.自洽迭代（电子优化，SCF）、3.原子驰豫（离子驰豫、结构优化）、4.态密度积分和参数、5.其他&lt;/p&gt;
&lt;h2 id=&#34;1初始参数&#34;&gt;1.初始参数&lt;/h2&gt;
&lt;h3 id=&#34;system注释体系&#34;&gt;system注释体系&lt;/h3&gt;
&lt;h3 id=&#34;istsrt如果有wavecar文件默认值为1否则为0&#34;&gt;ISTSRT：如果有wavecar文件，默认值为1，否则为0。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;0：开始新的计算，按iniwav初始化波函数
1：接着计算，通常用在态密度、能带结构、光学性质等电子结构计算，读取已有的wavecar
2：接着计算，希望保持基矢不变的计算中
3：接着计算，读取上一次计算的到的电荷密度和波函数，不推荐用
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;icharg&#34;&gt;ICHARG&lt;/h3&gt;
&lt;p&gt;如果ISTART=0，则默认为2，否则为0。决定如何构造初始的电荷密度&lt;br&gt;
0：从初始的波函数构造&lt;br&gt;
1：从CHGCAR读入，并同原子密度进行线性插值&lt;br&gt;
&lt;strong&gt;2：构造原子电子密度线性组合（LCAO），初始的电子密度由赝势来决定&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;11：读入自洽的CHGCAR，并进行能带计算或者态密度的非自洽计算&lt;/strong&gt;&lt;br&gt;
12：非自洽的原子密度计算&lt;br&gt;
ISART和ICHARG这两个关键词分别定义了如何构建初始化的波函数和电荷密度、读入上一次的波函数和电荷密度。&lt;br&gt;
推荐的做法：&lt;br&gt;
在进行能带结构、电子态密度等的性质的计算时：设置ISTART=1，ICHARG=11。&lt;br&gt;
其他情况：一般设置ISTART=0，ICHARG=2。&lt;/p&gt;
&lt;h2 id=&#34;2自洽迭代&#34;&gt;2.自洽迭代&lt;/h2&gt;
&lt;p&gt;单点计算、静态计算、自洽机刷都代表不优化结构只进行能量计算。&lt;/p&gt;
&lt;h3 id=&#34;nelm允许电子自洽迭代的最大步数默认为60有的结构复杂可以适当增大-如果无法自洽收敛需要设置电荷电荷密度混合方法&#34;&gt;NELM：允许电子自洽迭代的最大步数，默认为60，有的结构复杂可以适当增大。如果无法自洽收敛，需要设置电荷电荷密度混合方法。&lt;/h3&gt;
&lt;h3 id=&#34;ediff它是电子自洽收敛的标准默认为1e-4-当两次差值小于ediff时停止循环-控制电子步自洽收敛标准使用1e-5得到的结构优化结果可信&#34;&gt;EDIFF：它是电子自洽收敛的标准，默认为1E-4。当两次差值小于EDIFF时停止循环。控制电子步（自洽）收敛标准，使用1E-5得到的结构优化结果可信。&lt;/h3&gt;
&lt;h3 id=&#34;encut平面波截断能默认值从potcar中读入所有元素取值的最大值&#34;&gt;ENCUT：平面波截断能，默认值从POTCAR中读入，所有元素取值的最大值&lt;/h3&gt;
&lt;p&gt;2.8.3）ENCUT的取值与体系中所有的元素有关；参考文献中的或者按照以下设置&lt;br&gt;
A）体系中含有不同元素的时候，查看这些元素POTCAR中的ENMAX值，找出最大的那个；&lt;br&gt;
B）ENCUT的最小值为所有元素中ENMAX的最大值！&lt;br&gt;
C）也就是说，找到最大的ENMAX（max）， ENCUT值大于等于ENMAX（max）。&lt;/p&gt;
&lt;h3 id=&#34;algo电子优化算法normalialgo-38blocked-davidson方法-veryfastialgo-48rmm-diis算法fast上面两个算法的混合&#34;&gt;ALGO：电子优化算法：Normal：IALGO =38(blocked Davidson方法) VeryFast：IALGO =48（RMM-DIIS算法）Fast：上面两个算法的混合。&lt;/h3&gt;
&lt;h2 id=&#34;3原子驰豫&#34;&gt;3.原子驰豫&lt;/h2&gt;
&lt;h3 id=&#34;1原子如何移动以及步长步数和驰豫收敛条件&#34;&gt;1.原子如何移动以及步长，步数和驰豫收敛条件：&lt;/h3&gt;
&lt;p&gt;IBRION,ISIF,POTIM,NSW,EDIFFG&lt;/p&gt;
&lt;h3 id=&#34;ibrion决定了原子如何移动或者驰豫&#34;&gt;IBRION：决定了原子如何移动或者驰豫。&lt;/h3&gt;
&lt;p&gt;3：初始结构很差时使用&lt;br&gt;
2：共轭梯度法比较可靠&lt;br&gt;
1：小范围结构优化&lt;br&gt;
当与实验值在5%内认为是可靠的。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769201550.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;isif决定了是否计算应力-以及如何对结构优化&#34;&gt;ISIF:决定了是否计算应力    以及如何对结构优化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769319193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
取值为3，在优化晶胞时使用。取值为2，优化分子时候，驰豫表面，重构表面计算&lt;/p&gt;
&lt;h3 id=&#34;potim-nsw-ediffg&#34;&gt;POTIM、NSW、EDIFFG ：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769500820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
NSW表示最大步数，最大为100000后者更大。EDIFFG表示离子步也就是几何优化的精度。EDIFFG=0.02；0.05或者0.01（高精度）在结构优化中使用（-0.01~-0.03）认可结果。&lt;br&gt;
POTIM控制的小了使得vasp每次调节小，但是加大计算时间。&lt;/p&gt;
&lt;p&gt;2.分子动力学相关参数：&lt;br&gt;
SMASS,TEBEG,TEEND,POMASS,NBLOC,KBLOCK,PSTRESS,NSW,POTIM&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769635740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4态密度积分&#34;&gt;4.态密度积分&lt;/h2&gt;
&lt;p&gt;1：smearing方法和参数：ISMEAR,SIGMA&lt;br&gt;
2：计算态密度时的能量范围和点数：EMIN,EMAX,NEDOS&lt;br&gt;
3：计算分波态密度的参数：LORBIT&lt;/p&gt;
&lt;h3 id=&#34;ismear&#34;&gt;ISMEAR：&lt;/h3&gt;
&lt;p&gt;ISMEAR这一项，目前需要记住的是：&lt;/p&gt;
&lt;p&gt;1）不同的值对应的是不同的展宽方法；&lt;br&gt;
2）对于分子，原子的计算用0。&lt;br&gt;
下面是VASP官网的一些解释，新手暂时看不懂不要紧，把需要记住的这两条死死记住就可以了。&lt;/p&gt;
&lt;p&gt;对于半导体和绝缘体体系，ISMEAR的值取绝对不能大于0， 一般用0；&lt;br&gt;
对所有体系，如果想获取更加精确能量的时候用-5：但使用-5的时候，K点数目小于3则程序会罢工；&lt;br&gt;
K 点少，半导体或者绝缘体，那么只能用 ISMEAR = 0；&lt;br&gt;
在DOS能带计算中，使用ISMEAR= -5 用于获取精确的信息。&lt;br&gt;
对于金属来说，ISMEAR的取值一般为0，1；&lt;br&gt;
保守地说，ISMEAR = 0 (Gaussian Smearing) 可以满足大部分的体系（金属，导体，半导体，分子）；&lt;br&gt;
如果不知道怎么取ISMEAR，1）直接用0；2）测试不同的值对计算的影响。&lt;/p&gt;
&lt;h3 id=&#34;smearing&#34;&gt;smearing&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769810181.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769830617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;eminemax输出文件中有-以及-nedos1000平滑度和lorbitdos的输出方式取值为10取值11是分轨道还有nbands能带数目&#34;&gt;EMIN/EMAX(输出文件中有) 以及 NEDOS（1000，平滑度）和LORBIT（DOS的输出方式取值为10，取值11是分轨道）还有NBANDS（能带数目）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635769992712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5其他&#34;&gt;5.其他&lt;/h2&gt;
&lt;h3 id=&#34;prec-isym&#34;&gt;PREC、ISYM&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635770227760.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;磁性体系计算co3o4-fe2o3-ispin-magmom磁矩-voskown&#34;&gt;磁性体系计算（Co3O4、Fe2O3）-ISPIN、MAGMOM（磁矩）、VOSKOWN&lt;/h3&gt;
&lt;p&gt;体系的磁矩在OSZICAR中的mag=XX可以看到磁矩大小。&lt;br&gt;
初始磁矩可以设置为实验值×1.5&lt;br&gt;
或者初始磁矩可以设置为未成对电子数×1.5&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635770343792.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;逻辑参数lreal-lwave非常大性质计算再打开-lcharg非常大性质计算再打开&#34;&gt;逻辑参数LREAL、LWAVE（非常大，性质计算再打开）、LCHARG（非常大，性质计算再打开）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635770482184.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
E）这里LREAL设置为Auto，是为了和后面表面能计算统一。计算时要根据原子数的多少，以及后续的计算选择LREAL的值。不能拿LREAL=.FALSE.和LREAL=ON/.TRUE.计算的结果进行能量比较。&lt;br&gt;
F) 注意：块体材料计算时，为了后续计算其他性质，常常要求整个计算中使用相同的&lt;strong&gt;ENCUT，ENAUG， PREC， LREAL， ROPT&lt;/strong&gt;，这部分大家可以看看手册 8.3 What kind of “technical” errors do exist， overview&lt;/p&gt;
&lt;h3 id=&#34;强关联体系氧化铈等lsdauldauldautypeldaul哪个轨道添加uldauu在位库伦ldauj交换相互&#34;&gt;强关联体系(氧化铈等)L(S)DA+U：LDAU,LDAUTYPE,LDAUL（哪个轨道添加U）,LDAUU（在位库伦）,LDAUJ（交换相互）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635770618512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;杂化泛函hse06lhfcalchfscreenlmaxfockprecfock&#34;&gt;杂化泛函（HSE06）LHFCALC,HFSCREEN,LMAXFOCK,PRECFOCK&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635771052948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;kpoints&#34;&gt;KPOINTS&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;K-POINTS           ##第一行随便写都可以，但是不能没有
0                  ##零，代表格子自动生成
Gamma              ##gamma点的centered（只认第一个字母而且大小写都可以，G代表以gamma点为中心生成网络。M为原始的Monkhorst-Pack网格，M在G的基础上在三个方向上平移了1/(2N)个单位）
1 1 1              ##1*1*1格子运算（在xyz方向上生成对应数目的K点，原子分子选择1，如果ISMEAR=-5计算能量那么就需要使用2 2 2 或者更高的3 3 3）
0 0 0              ##S1 S2 S3，一般保持0 0 0不变
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635766075450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;KPOINTS的建议，一直使用gamma来计算；M平移会导致网格对称性和晶胞对称性不匹配情况，从而计算出错。对于六角晶系的结构必须用gamma。对于非六角晶系，如果M可以计算就使用M&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;poscar&#34;&gt;POSCAR&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;O atom in a box    ##随便写，不可以不写            
1.0                ## universal sacling parameters(缩放系数这里是1)
8.0 0.0 0.0        ## lattice vector a(1)（坐标信息，xyz分别取8埃米）
0.0 8.0 0.0        ## lattice vector a(2)
0.0 0.0 8.0        ## lattice vector a(3)
O                  ## O element ，not zero（体系元素，需要顶格写不能有空格，）
1                  ## number of atoms
cartesian          ## positions in cartesian  coordinates（坐标系选择，这里是笛卡尔坐标，也可以是分数坐标。只认识第一个字母，C为笛卡尔坐标，D为分数坐标）
0 0 0              ## 氧原子的位置坐标PO
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;potcar&#34;&gt;POTCAR&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635752258063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
赝势的种类需要一致；赝势使用的泛函与incar中的泛函需要一致（PBE泛函选用PBE赝势）&lt;br&gt;
各类元素的赝势文件，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep TIT POTCAR可以查看使用了哪些赝势
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;某些元素，还有一些以 _h， _s 结尾的，应该是 hard和soft的缩写。带h的POTCAR中截断能比普通的要高出很多。带s的截断能要小很多。这里我们就可以通过grep 结合 ENMAX来查看一下：&lt;br&gt;
VRHFIN 用来看元素的价电子排布，如果你元素周期表倒背如流，可以忽略这个参数；&lt;br&gt;
LEXCH 表示这个POTCAR对应的是GGA-PBE泛函；如果INCAR中不设定泛函，则默认通过这个参数来设定。&lt;br&gt;
TITEL 就不用说了，指的是哪个元素，以及POTCAR发布的时间；&lt;br&gt;
ZVAL 指的是实际上POTCAR中价电子的数目，尤其是做Bader电荷分析的时候，极其重要。&lt;br&gt;
ENMAX 代表默认的截断能。与INCAR中的ENCUT这个参数相关。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;potpaw_LDA 和 potpaw_PBE。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;qe提交作业&#34;&gt;QE提交作业&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
#JSUB -n  10
##JSUB -R &amp;quot;span[ptile=10]&amp;quot;
#JSUB -q  normal
##JSUB -gpgpu 1
#JSUB -e error.%J
#JSUB -o output.%J
##JSUB -m node06
source /apps/software/intel/2017u2/compilers_and_libraries/linux/bin/compilervars.sh  intel64
module load gcc/9.4.0
module load mkl/latest
module load openmpi/intel/4.1.1
export PATH=$PATH:~/opt/qe67/bin
export OMP_NUM_THREADS=4

. /apps/software/tools/hostfile
mpirun -np $ncpu -ppn 1 -f  $nodelist  pw.x &amp;lt; pwscf.in |tee pwscf.out
rm   $nodelist
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;vasp电声耦合-gaas带隙随着温度的变化&#34;&gt;VASP电声耦合-GaAs带隙随着温度的变化&lt;/h1&gt;
&lt;h1 id=&#34;vasp计算性质&#34;&gt;VASP计算性质&lt;/h1&gt;
&lt;p&gt;几何性质（结构参数键长等）、电子性质（态密度等）、状态方程和力学性质（弹性模量）、表面性质（缺陷、吸附能等）、光学性质（折射率等）、分子动力学模拟（扩散系数等）、磁学性质（自旋轨道耦合等）、GW近似（激发态）VASP对材料、凝聚态、表面、催化展开研究。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635734489557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;vasp理论基础第一性原理&#34;&gt;VASP理论基础：第一性原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635737703739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635737842923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635737863727.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635737974726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738001583.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738028198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738071914.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DFT（LDA、GGA、meta-GGA、杂化泛函、范德华力-DFT）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738109320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
LDA&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738214229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
GGA&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738243102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
+U修正（对于d、f轨道电子处理）半经验方法，使用文献中的，或者进行测试&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738306431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
杂化泛函（带隙计算精确但是时间增加）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738382061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DFT研究基本量从波函数到电子密度的变化。&lt;br&gt;
赝势理论（内层电子进行了近似、考虑外层电子的简化处理）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738484735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738548560.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模守恒赝势（NCPP）-超软赝势（US-PP）-平面波赝势（PAW）&lt;br&gt;
模守恒赝势：全电子赝势，给出准确波函数&lt;br&gt;
超软赝势：完全非局域的赝势，平面波比较平滑。截断能降低。对某些比较合适&lt;br&gt;
平面波赝势：现在较常用&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635738779226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;vasp基本输出文件&#34;&gt;VASP基本输出文件&lt;/h1&gt;
&lt;h2 id=&#34;outcar计算结构输出文件&#34;&gt;OUTCAR：计算结构输出文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;grep POTCAR OUTCAT来查找OUTCAR中的POSCAR
grep E-fermi OUTCAR查找OUTCAR中的费米能级
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在bashrc中加入&lt;code&gt;alias gr=&amp;quot;grep &#39;reached required accuracy&#39; OUTCAR&amp;quot;&lt;/code&gt; 来快速输入gr判定是否达到收敛。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Band No&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;band energy&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;occupation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;第几条能带1……&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;能量值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;占据电子数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;oszicar每次迭代或原子驰豫或者md的能量信息&#34;&gt;OSZICAR：每次迭代或原子驰豫或者MD的能量信息&lt;/h2&gt;
&lt;p&gt;电子结构优化：固定几何结构，求解薛定谔方程求能量的最小值。&lt;br&gt;
几何结构优化：在电子结构的基础上根据受力情况调整原子位置。电子步1-离子步1-电子步2-离子步2&lt;br&gt;
N：电子步的步数；E：体系能量；dE：两步之间的差值……&lt;br&gt;
DAV、RMM、CG分别是一个电子步中的迭代求解的自洽算法。在INCAR中ALGO=Fast、Normal等来选择；Normal对应DAV算法。&lt;br&gt;
F前面的1代表几何结构优化次数（离子步）F=体系总能量，对应OUTCAR中的free energy toten；E0对应OUTCAR中的energy（sigma-&amp;gt;0）的能量。一般计算中使用E0就可以了。&lt;br&gt;
体系的磁矩在OSZICAR中的mag=XX可以看到磁矩大小。&lt;br&gt;
初始磁矩可以设置为实验值&lt;em&gt;1.5&lt;br&gt;
或者初始磁矩可以设置为未成对电子数&lt;/em&gt;1.5&lt;/p&gt;
&lt;h2 id=&#34;contcar原子驰豫或者md后的体系结构文件分数坐标用于续算&#34;&gt;CONTCAR：原子驰豫或者MD后的体系结构文件，分数坐标，用于续算&lt;/h2&gt;
&lt;h2 id=&#34;chg-和-chgcar电荷密度文件比较大在最后计算再保存&#34;&gt;CHG 和 CHGCAR：电荷密度文件，比较大，在最后计算再保存&lt;/h2&gt;
&lt;h2 id=&#34;wavecar波函数文件比较大最后计算性质再保存&#34;&gt;WAVECAR：波函数文件，比较大，最后计算性质再保存&lt;/h2&gt;
&lt;h2 id=&#34;doscar电子态密度文件&#34;&gt;DOSCAR：电子态密度文件&lt;/h2&gt;
&lt;h2 id=&#34;eigenval各k点本征值文件能带数目能量范围&#34;&gt;EIGENVAL：各k点本征值文件，能带数目，能量范围&lt;/h2&gt;
&lt;h2 id=&#34;edatcar每次原子驰豫后的每一步轨迹文件&#34;&gt;EDATCAR：每次原子驰豫后的每一步轨迹文件&lt;/h2&gt;
&lt;h2 id=&#34;ibzkpt布里渊区中的k点&#34;&gt;IBZKPT：布里渊区中的k点&lt;/h2&gt;
&lt;h2 id=&#34;pcdat对关联函数&#34;&gt;PCDAT：对关联函数&lt;/h2&gt;
&lt;h2 id=&#34;procar-和-proout波函数投影或者分解的文件&#34;&gt;PROCAR 和 PROOUT：波函数投影或者分解的文件&lt;/h2&gt;
&lt;h2 id=&#34;locpot总的局域势&#34;&gt;LOCPOT：总的局域势&lt;/h2&gt;
&lt;h2 id=&#34;elfcat电子局域函数&#34;&gt;ELFCAT：电子局域函数&lt;/h2&gt;
&lt;h1 id=&#34;晶胞优化&#34;&gt;晶胞优化&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635776322188.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实验得到的晶格常数，可以只对原子位置进行驰豫优化。&lt;/p&gt;
&lt;h2 id=&#34;优化方法直接优化-状态方程和实验对比哪个好用哪个&#34;&gt;优化方法（直接优化、状态方程）和实验对比哪个好用哪个&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635776395161.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Si晶胞优化（晶格参数变化值1%）&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635776524252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;表面吸附w表面吸附co注意isif&#34;&gt;表面吸附（W表面吸附CO）注意ISIF&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635779361287.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（1）W晶胞优化&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635779502676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635779903034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（4）优化CO&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635856433971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;态密度计算&#34;&gt;态密度计算&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635857214291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1636525257330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对INCAR进行修改专门计算态密度&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635857163161.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
KPOINTS(性质计算高于结构优化的k点)&lt;br&gt;
态密度的INCAR专用茶参数&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858255719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;能带结构&#34;&gt;能带结构&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858549774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858698003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858813233.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858773242.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858836574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
能带处理&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635858955763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
电子结构计算总结（scf静态计算、电子自洽迭代；dos态密度；bs能带结构）smyl生成能带路径&lt;br&gt;
通常是用Band对禁带宽度进行计算，态密度横坐标为能量，纵坐标为该能量的带的数量；费米能级处拖尾不好处理，禁带宽度定义就是倒易空间的，Band的横坐标为倒易空间的点，纵坐标为能量所以使用Band计算的禁带宽度更加准确。具体分析参照&lt;a href=&#34;https://www.bilibili.com/video/BV17q4y1X7rY/?spm_id_from=333.788&#34;&gt;计算老司机&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635859002805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;电荷密度&#34;&gt;电荷密度&lt;/h1&gt;
&lt;p&gt;先结构优化，然后电子自洽scf等电子结构性质计算&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635859301178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
电荷密度计算步骤&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635859538543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1635859951852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
态密度计算K点要求&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1638602322812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;结构优化完毕后：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一步计算DOS&lt;/strong&gt;必须的参数：&lt;br&gt;
1 ISMEAR = -5&lt;br&gt;
2 LORBIT = 11&lt;br&gt;
3 高密度的K点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两步计算DOS&lt;/strong&gt;必须的参数:&lt;br&gt;
&lt;strong&gt;第一步：&lt;/strong&gt;&lt;br&gt;
ISMEAR = -5&lt;br&gt;
LCHARG = .TRUE.&lt;br&gt;
&lt;strong&gt;稍微低密度的K点&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;第二步：&lt;/strong&gt;&lt;br&gt;
ISMEAR = -5&lt;br&gt;
ICHARGE = 11&lt;br&gt;
LORBIT = 11&lt;br&gt;
&lt;strong&gt;高密度的K点&lt;/strong&gt;&lt;br&gt;
如果结构优化的时候，存了WAVECAR，计算DOS的时候可以读取WAVECAR，直接一步计算搞定。&lt;/p&gt;
&lt;h1 id=&#34;bader电荷计算&#34;&gt;bader电荷计算&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;https://www.bigbrosci.com/2011/12/23/A07/&#34;&gt;大师兄LVASPTHW&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;bader电荷计算准备&#34;&gt;bader电荷计算准备&lt;/h2&gt;
&lt;p&gt;首先使用vasp获得稳定的结构&lt;br&gt;
1.将前面的CONTCAR复制为POSCAR&lt;br&gt;
2.设置INCAR必要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LAECHG=.TRUE. 
LCHARG = .TRUE.
NSW = 0
IBRION = -1 ## 前面有了NSW = 0， 这个也可以不设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.KPOINTS可以使用结构优化参数也可以使用大一些的参数&lt;br&gt;
4.WAVECAR，CHGCAR等有的话就读一下，没有可以适当增加电子步NELM=200&lt;/p&gt;
&lt;h2 id=&#34;bader计算环境配置&#34;&gt;bader计算环境配置&lt;/h2&gt;
&lt;p&gt;1.VTST脚本中的chgsum.pl&lt;a href=&#34;http://theory.cm.utexas.edu/vtsttools/download.html&#34;&gt;VTST·Tools-VTST Scripts&lt;/a&gt;&lt;br&gt;
2.bader处理的脚本&lt;a href=&#34;http://theory.cm.utexas.edu/henkelman/code/bader/&#34;&gt;bader&lt;/a&gt;&lt;br&gt;
下载解压两个文件夹到任意目录例如：~/bin/bader。&lt;br&gt;
通过如下方式获得脚本执行权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod u+x ~/bin/vtstscripts-978/chgsum.pl
chmod u+x ~/bin/bader
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bader计算处理&#34;&gt;bader计算处理&lt;/h2&gt;
&lt;p&gt;1.进入计算的scf目录&lt;br&gt;
2.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~/bin/vtstscripts-978/chgsum.pl AECCAR0 AECCAR2
chgsum.pl AECCAR0 AECCAR2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;~/bin/bader CHGCAR -ref CHGCAR_sum
bader CHGCAR -ref CHGCAR_sum
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;命令结束后，你会得到一些相应输出的文件：ACF.dat， BCF.dat， AVF.dat…&lt;/li&gt;
&lt;li&gt;本人一般查看的是ACF.dat文件&lt;/li&gt;
&lt;li&gt;ACF.dat文件中，第一列的数字对应的是POSCAR中的原子顺序。每个原子的电荷对应的是CHARGE那一列。注意，该列中的电荷是该原子价层电子中的电子总数。如果你想要知道这个原子是带正电或者负电荷，需要减去POTCAR中的电子数目。通过&lt;code&gt;grep ZVAL POTCAR&lt;/code&gt;查找POTCAR中原子的电子数目。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;能量换算&#34;&gt;能量换算&lt;/h1&gt;
&lt;p&gt;换算系数为： 1 eV/Å2 = 16.02 J/m2&lt;br&gt;
1 eV = 1.602176487e-19 J&lt;br&gt;
1 Å2 = (1e-10) (1e-10) m2&lt;/p&gt;
&lt;h1 id=&#34;吸附位置&#34;&gt;吸附位置&lt;/h1&gt;
&lt;p&gt;不同表面位点：&lt;br&gt;
观察不同位点的结构特征，在面心立方金属的(111)表面上有4种不同的位点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Top位，前面已经花了很多时间介绍了，本节就不再啰嗦&lt;/li&gt;
&lt;li&gt;Bridge位：从名字大家就可以推断这个位点的吸附为两个Top原子的中间。&lt;/li&gt;
&lt;li&gt;Fcc位和Hcp位：这两个吸附位点都是在三个原子的中心，为hollow位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么这两个位点怎么区分呢？&lt;/p&gt;
&lt;p&gt;如果表面的Hollow位正下方（即第二层，图中黄色的）有原子，为Hcp位，在第三层的话（图中红色的），则这个hollow为Fcc位。&lt;br&gt;
由于Fcc位点的原子在第三层，离表面最远（far），大家把英文单词的far 和 Fcc位的第一个字母关联起来即可。远的那个就是Fcc，近的是Hcp。&lt;br&gt;
注意： Fcc 和 Hcp 分别是 face centered cubic 和 hexagonal close-packed 的缩写。&lt;/p&gt;
&lt;h2 id=&#34;把slab的原子全部固定住然后用gamma点算一下它们的吸附能先大体上判断一下把那些吸附特别强的结构筛选出来用作下一步的计算&#34;&gt;把slab的原子全部固定住，然后用gamma点算一下它们的吸附能，先大体上判断一下，把那些吸附特别强的结构筛选出来，用作下一步的计算。&lt;/h2&gt;
&lt;h1 id=&#34;表面钝化&#34;&gt;表面钝化&lt;/h1&gt;
&lt;p&gt;考虑终端钝化即bulk termination。切出来的slab模型通常(注)在最上层和最下层存在悬挂键（dangling bonds, DB）。在表面或者界面处的悬挂键是真实存在的，对他们的不同处理可以反应表面界面的不同属性。但是最下层的悬挂键却不应该存在，因为这部分的原子层在模拟体相bulk properties，所以需要进行合理的钝化处理。最常见的方式是加氢（或者赝氢）钝化，具体方式为：计算出来&lt;strong&gt;悬挂键&lt;/strong&gt;的电子数目N，然后选择2-N个电子的赝氢即可。以III-V为例，可以参考我的文章[1-5]中均有提及：对于Ga，每一个DB有0.75e，所以需要1.25e的赝氢钝化；对于N，每一个DB有1.25e，所以需要0.75e的赝氢钝化。&lt;/p&gt;
&lt;h1 id=&#34;电荷密度差cdd&#34;&gt;电荷密度差（CDD）&lt;/h1&gt;
&lt;p&gt;电荷密度差分（charge density difference）是研究电子结构的重要手段之一。可以直观的得到两个片段相互作用后的电子流向，原子形成分子过程中电子密度的变化、探究化学键的本质。&lt;br&gt;
电荷密度差分有以下几种形式：&lt;br&gt;
（1）体系电荷密度减去两个或者其他几个片段的密度&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1669084854735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以 CO 分子吸附再 Ni(100) 表面为例：&lt;br&gt;
步骤一：优化 CO/Ni(100) 的结构，优化好的 CONTCAR 文件如下：&lt;br&gt;
步骤二：分别计算 Ni(100) 和 CO 的单点能&lt;br&gt;
CO 和 Ni(100) 片段的坐标从 CO/Ni(100) 的 CONTCAR 里直接截取，不要再结构优化！！计算时也要保证三次自洽计算所采用的 FFT mesh 一致（NGXF,NGYF,NGZF）&lt;br&gt;
步骤三：用 vaspkit 314 功能做电荷差分。依次输入三个片段的 CHGCAR 路径:&lt;br&gt;
步骤四：得到 CHGDIFF.vasp 文件，导入到 VESTA 里做图。&lt;br&gt;
（2）自洽计算收敛以后体系的电荷密度减去该原子构型下每个原子的球对称的电荷密度(即初猜电荷密度)，也称为变形电荷密度 (Deformation charge density)&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1669085081577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
步骤一：先自洽计算优化 CO 分子。&lt;br&gt;
步骤二：新键文件夹，在优化好的结构基础上用** ICHARG = 12 做非自洽计算**。&lt;br&gt;
步骤三：用 vaspkit 314 功能做电荷差分。依次输入二个 CHGCAR 路径。&lt;br&gt;
步骤四：得到 CHGDIFF.vasp 文件，导入到 VESTA 里做图。&lt;br&gt;
（3）在某个状态的密度减去这个体系在另外一个状态的密度。比如：外加电场作用下的电荷密度减去没有外势场的电荷密度。再比如：激发态的密度减去它在基态时的密度。&lt;br&gt;
&lt;img src=&#34;https://lisonglin-xidian.github.io/post-images/1669085091437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
外加电场作用下的电荷密度减去没有外势场的电荷密度。&lt;br&gt;
以 InSe 二维单层材料为例：(共用其中一个状态的几何构型。)&lt;br&gt;
步骤一：先优化没有外加电场的结构。&lt;br&gt;
步骤二：在同样结构下计算外加电场下做单点自洽计算。添加关键词，EFIELD 控制电场力的大小（eV/Angstrom）。F=qE 所以对应电场的单位是 E=F/q， 因而场强单位是 V/Angstrom&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EFIEDLD = 0.05
IDIPOL = 3
LDIPOL = .TRUE.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤三：运行 Vaspkit 314 功能做电荷差分。依次输入二个 CHGCAR 路径。&lt;br&gt;
步骤四：得到 CHGDIFF.vasp 文件，导入到 VESTA 里做图。&lt;br&gt;
CHGCAR 文件格式&lt;br&gt;
CHGCAR 是包含电子密度信息的格点文件，对于自旋非极化体系（ISPIN = 1）计算只包含电荷密度，对于自旋极化体系（ISPIN = 2）计算还包含自旋电子密度。可以用 VESTA，Jmol 等程序打开。&lt;br&gt;
CHGCAR 的第一部分和 POSCAR, CONTCAR 的格式是完全一样的，它包含了最终结构的晶格矢量，原子核坐标等信息。紧接着是三个数字，这三个数是实空间函数的网格密度，对应于 NGXF，NGYF，NGZF 三个变量。然后是电荷密度信息 ρ(r) * Vcell。一共有 NGXF * NGYF * NGZF 个数值。&lt;/p&gt;
&lt;h1 id=&#34;scf不收敛&#34;&gt;SCF不收敛&lt;/h1&gt;
&lt;p&gt;依次尝试以下方法：&lt;br&gt;
参考&lt;a href=&#34;http://bbs.keinsci.com/thread-11126-1-1.html&#34;&gt;啦啦黑还黑&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://blog.wangruixing.cn/2019/05/01/scf/&#34;&gt;世事如棋&lt;/a&gt;&lt;br&gt;
（1）先检查几何结构是不是合理，非常离谱的初始结构会导致SCF难收敛。&lt;br&gt;
（2）依次检查已经设置的参数，对照ppt的建议，是不是选择合理，对于+U和ICHARGE=11的任务，添加LMAXMIN=4 (对于d区体系)，添加LMAXMIN=6 (对于f区体系)。&lt;br&gt;
（3）检查是不是ISTART=1读取了不合理的波函数，如果是，rm WAVECAR CHGCAR重新跑。&lt;br&gt;
（4）如果ALGO=Fast或者VeryFast，换成Normal。&lt;br&gt;
（5）尝试使用更大的SIGMA值，先粗略收敛，再读取CHGCAR和WAVECAR用小的SIGMA计算。&lt;br&gt;
（5）对于非磁性体系（闭壳层ISPIN=1）添加：（注意AMIX和BMIX对收敛有很大影响，可以自己调试）&lt;br&gt;
AMIX = 0.2&lt;br&gt;
BMIX = 0.0001 #almost zero, but 0 will crash some versions&lt;br&gt;
（6）对于磁性体系（自旋极化，ISPIN=2）添加：&lt;br&gt;
AMIX = 0.2&lt;br&gt;
BMIX = 0.0001 #almost zero, but 0 will crash some versions&lt;br&gt;
AMIX MAG = 0.8&lt;br&gt;
BMIX MAG = 0.0001 #almost zero, but 0 will crash some versions&lt;br&gt;
(7)  尝试更换不同的ISMEAR。&lt;br&gt;
(8)  检查体系是不是特殊的磁性排列，即MAGMOM设置是否合理。&lt;br&gt;
(9)  提高积分精度，PREC=Accurate 。&lt;br&gt;
(10) 提高格点精度，ADDGRID = .TRUE. 。&lt;br&gt;
(11) 先用1 1 1 K点计算收敛，再读取CHGCAR，用高K点计算。&lt;br&gt;
(12) 尝试不同的ALGO 比如：ALGO=Conjugate。&lt;br&gt;
(13) 如果在结构优化或者MD过程中，某一步突然不收敛，使用MAXMIX = 50&lt;br&gt;
(14) 尝试用更小的ENCUT或者更大的ENCUT的预收敛。&lt;br&gt;
(15) 换更小的赝势或者更soft的赝势。&lt;br&gt;
(16) 最后给出一个VASP官方教程里解决的不收敛的方法：&lt;br&gt;
1.用ALGO=N （是否收敛N to 2，Y to 6）&lt;br&gt;
2. ICHARG=12 (no charge update，非自洽计算，N to5, Y to 3)&lt;br&gt;
3. ICHARG=2 AMIX=0.1 ; BMIX=0.01(N to 4, Y to 6)&lt;br&gt;
4. increase BMIXBMIX=3.0 ; AMIN=0.01(N to 5, Y to 6)&lt;br&gt;
5. Bug report&lt;br&gt;
6. Use this setting&lt;/p&gt;
&lt;h1 id=&#34;泛函选择&#34;&gt;泛函选择&lt;/h1&gt;
&lt;p&gt;选择不同的POTCAR就是用的不同的交换关联泛函，GGA-PBE，GGA-PW91，LDA等。&lt;br&gt;
另外一个常用的GGA是RPBE，在VASP版本中，并没有专门针对RPBE的赝势。如果需要用RPBE的交换关联势，只需直接用PBE的POTCAR，然后在INCAR文件里指定GGA=RP。&lt;/p&gt;
&lt;h1 id=&#34;吸附能单位换算&#34;&gt;吸附能单位换算&lt;/h1&gt;
&lt;p&gt;1 Hartree ( au ) ＝2625.5 kJ/mol = 627.51 kcal/mol = 27.2116 eV&lt;br&gt;
1 kcal/mol = 6.948×10-14 erg&lt;br&gt;
1 Hartree = 4.36×10-11 erg = 2 Rydberg&lt;br&gt;
1 eV = 1.602×10-12 erg&lt;br&gt;
1 erg = 1.439×1013 kcal/mol = 6.2415×1011 eV&lt;br&gt;
1 kcal/mol = 6.948×10-14 erg&lt;br&gt;
1 Hartree = 4.36×10-11 erg = 2 Rydberg&lt;br&gt;
1 eV = 1.602×10-12 erg&lt;br&gt;
1 erg = 1.439×1013 kcal/mol = 6.2415×1011 eV&lt;br&gt;
1 erg= 2.2937×1010 Hartree = 5.034×1015 cm-1&lt;br&gt;
1 kJ/mol = 0.239006 kcal/mol = 120.272 K&lt;br&gt;
1 kcal/mol = 4.184 kJ/mol = 503.217 K&lt;br&gt;
1 eV = 23.0605 kcal/mol = 96.4853 kJ/mol = 1.16045×104 K&lt;br&gt;
1 Hartree = 2625.500 kJ/mol = 627.510 kcal/mol = 3.15773 × 105 K&lt;/p&gt;
">vasp学习总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/ubuntu-chang-yong-ming-ling/"" data-c="
          &lt;p&gt;Ubuntu 16.04以及超算常用脚本总结&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;ubuntu&#34;&gt;Ubuntu&lt;/h1&gt;
&lt;p&gt;CPU利用率：&lt;code&gt;htop&lt;/code&gt;&lt;br&gt;
vim取消高亮：&lt;code&gt;:noh&lt;/code&gt;&lt;br&gt;
vim查找：&lt;code&gt;esc,/搜索内容&lt;/code&gt;(n搜索下一个，shift+n搜索上一个)&lt;br&gt;
vim查找替换：&lt;code&gt;esc, s/T/F/g&lt;/code&gt;&lt;br&gt;
vim显示行号: &lt;code&gt;:esc,set number&lt;/code&gt; 不显示行号 &lt;code&gt;esc,set nonumber&lt;/code&gt;&lt;br&gt;
设置别名并执行其他目录下的脚本文件：&lt;code&gt;alias rmv=&amp;quot;bash ~example/vasp/rmvasp.sh&amp;quot;&lt;/code&gt;&lt;br&gt;
vim启用鼠标：如果当前正处于编辑模式而要想使用鼠标，则需先按 esc 键，再键入&lt;code&gt;:set mouse=a&lt;/code&gt;&lt;br&gt;
命令使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed
echo
awk
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[dmtsai@study ~]$ sed [-nefr] [动作]
选项与参数：
-n ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。
但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。
-e ：直接在命令行界面上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；
-r ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法）
-i ：直接修改读取的文件内容，而不是由屏幕输出。
动作说明： [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作
是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”
function 有下面这些咚咚：
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！
例如 1,20s/old/new/g 就是啦！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将INCAR中的NCORE这一行中的数字4更换为数字8：&lt;code&gt;sed -i &#39;/NCORE/s/4/8/&#39; INCAR&lt;/code&gt;&lt;br&gt;
awk&lt;br&gt;
&lt;code&gt;awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename&lt;/code&gt;&lt;br&gt;
awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作。 awk 可以处理后&lt;br&gt;
续接的文件，也可以读取来自前个指令的 standard output 。 但如前面说的， awk 主要是处&lt;br&gt;
理“每一行的字段内的数据”，而默认的“字段的分隔符号为 &amp;quot;空白键&amp;quot; 或 &amp;quot;[tab]键&amp;quot; ”！举例来说，&lt;br&gt;
我们用 last 可以将登陆者的数据取出来，结果如下所示：&lt;/p&gt;
&lt;h1 id=&#34;高性能计算&#34;&gt;高性能计算&lt;/h1&gt;
&lt;p&gt;VASP常用~/.bashrc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# oneapi
source /opt/intel/oneapi/setvars.sh intel64

export PATH=/home/mccc/download/vaspkit.1.3.0/bin:${PATH}
export PATH=/home/mccc/ssh:$PATH
export PATH=/home/mccc/download/vasp.6.1.0/bin:$PATH
export PATH=/home/mccc/download/VESTA-gtk3:$PATH

alias ..=&amp;quot;cd ..&amp;quot;
alias gre=&amp;quot;grep &#39;reached required accuracy&#39; OUTCAR&amp;quot;
alias ge=&amp;quot;grep &#39;E0&#39; OSZICAR&amp;quot;
alias gen=&amp;quot;grep &#39;entropy T&#39; OUTCAR&amp;quot;
alias gt=&amp;quot;grep &#39;TIT&#39; POTCAR&amp;quot;
alias cp=&amp;quot;cp -r&amp;quot;
alias rmv=&amp;quot;rmvasp.sh&amp;quot;
alias vesta=&amp;quot;VESTA&amp;quot;
alias pospot=&amp;quot;potcar.sh $(head -n 6 POSCAR | tail -n 1)&amp;quot;
alias vb=&amp;quot;vim ~/.bashrc&amp;quot;
alias sb=&amp;quot;source ~/.bashrc&amp;quot;
alias mpi4v=&amp;quot;mpirun -np 4 vasp&amp;quot;
alias mpi8v=&amp;quot;mpirun -np 8 vasp&amp;quot;
alias mpi16v=&amp;quot;mpirun -np 16 vasp&amp;quot;
alias mpi24v=&amp;quot;mpirun -np 24 vasp&amp;quot;
alias force=&amp;quot;force.sh&amp;quot;
alias toten=&amp;quot;toten.sh&amp;quot;
alias tim=&amp;quot;grep &#39;Total CPU&#39; OUTCAR&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制超算例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp -a /apps/software/example ~/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vasp提交脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
#JSUB -n 80
#JSUB -R &amp;quot;span[ptile=80]&amp;quot;
#JSUB -q  normal
###JSUB -gpgpu 1
#JSUB -e error.%J
#JSUB -o output.%J
###JSUB -m node06
source /apps/software/intel/2017u2/compilers_and_libraries/linux/bin/compilervars.sh  intel64
module load mkl/latest 
module load mpi/2021.3.0 
module load cuda/9.2

. /apps/software/tools/hostfile
mpirun -np $ncpu -ppn 1 -f  $nodelist  ./vasp
rm   $nodelist
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;超算中vasp并行设置&#34;&gt;超算中VASP并行设置&lt;/h1&gt;
&lt;p&gt;答：并行是有用的，只不过我们需要调教这些不听话的马儿们，让他们服从我们的命令。这里我们就会需要一些其他的参数，NCORE和NPAR。&lt;/p&gt;
&lt;p&gt;NCORE：控制多少个核同时计算；&lt;br&gt;
NPAR：如何把计算任务分配到计算资源上面计算。&lt;/p&gt;
&lt;p&gt;它们之间的关系是：NCORE= 计算使用的核数 / NPAR&lt;/p&gt;
&lt;p&gt;注意：这两个参数只能选取一个来使用:&lt;br&gt;
1）使用NCORE以后，单节点运行也加快了；（单匹马儿被你调教的更听话了）&lt;/p&gt;
&lt;p&gt;2）加入NCORE和NPAR参数后，计算时间明显提高了。&lt;strong&gt;在20核以后的计算中尤为明显&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;如果你想用多个节点计算，NCORE或者NPAR，不要忘了加（二者选其一）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;４）可以肯定的是：NPAR和NCORE的乘积就是我们计算所用的核数，这一点大家要记在心里。&lt;br&gt;
个人使用经验是：NCORE = 单个节点核数 / 2 的时候，运行最省时间，设置也最方便。by bigbro&lt;/p&gt;
&lt;h1 id=&#34;指令的-help-求助说明&#34;&gt;指令的 --help 求助说明&lt;/h1&gt;
&lt;p&gt;man page&lt;br&gt;
info page&lt;br&gt;
nano常用快捷键:&lt;br&gt;
[ctrl]-G：取得线上说明（help），很有用的！&lt;br&gt;
[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！&lt;br&gt;
[ctrl]-O：储存盘案，若你有权限的话就能够储存盘案了；&lt;br&gt;
[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；&lt;br&gt;
[ctrl]-W：搜寻字串，这个也是很有帮助的指令喔！&lt;br&gt;
[ctrl]-C：说明目前光标所在处的行数与列数等信息；&lt;br&gt;
[ctrl]-_：可以直接输入行号，让光标快速移动到该行；&lt;br&gt;
[alt]-Y：校正语法功能打开或关闭（按一下开、再按一下关）&lt;br&gt;
[alt]-M：可以支持鼠标来移动光标的功能&lt;br&gt;
绝对路径：路径的写法“一定由根目录 / 写起”，例如： /usr/share/doc 这个目录。&lt;br&gt;
相对路径：路径的写法“不是由 / 写起”，例如由 /usr/share/doc 要到 /usr/share/man 下面&lt;br&gt;
时，可以写成： “cd ../man”这就是相对路径的写法啦！相对路径意指“相对于目前工作目&lt;br&gt;
录的路径！”&lt;br&gt;
万用字符：&lt;code&gt;*,?,[],[-],[^]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[dmtsai@study ~]$ LANG=C &amp;amp;lt;==由于与编码有关，先设置语系一下
范例一：找出 /etc/ 下面以 cron 为开头的文件名
[dmtsai@study ~]$ ll -d /etc/cron* &amp;amp;lt;==加上 -d 是为了仅显示目录而已
范例二：找出 /etc/ 下面文件名“刚好是五个字母”的文件名
[dmtsai@study ~]$ ll -d /etc/????? &amp;amp;lt;==由于 ? 一定有一个，所以五个 ? 就对了
范例三：找出 /etc/ 下面文件名含有数字的文件名
[dmtsai@study ~]$ ll -d /etc/*[0-9]* &amp;amp;lt;==记得中括号左右两边均需 *
范例四：找出 /etc/ 下面，文件名开头非为小写字母的文件名：
[dmtsai@study ~]$ ll -d /etc/[^a-z]* &amp;amp;lt;==注意中括号左边没有 *
范例五：将范例四找到的文件复制到 /tmp/upper 中
[dmtsai@study ~]$ mkdir /tmp/upper; cp -a /etc/[^a-z]* /tmp/upper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一句话在操作系统下关闭CPU超线程(root权限): &lt;code&gt;echo off &amp;gt; /sys/devices/system/cpu/smt/control&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;windows格式dos转linux的unix&#34;&gt;windows格式dos转linux的unix&lt;/h1&gt;
&lt;p&gt;故障现象：在终端直接cd /var正常，在shell脚本中执行则报错。原因是脚本是在windows平台下写的，换行符与linux不同，造成脚本不能正确执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;问题原因：
因为操作系统是windows，在windows下编辑的脚本，所以有可能有不可见字符。脚本文件是DOS格式的
即每一行的行尾以\r\n来标识, 其ASCII码分别是0x0D, 0x0A.
解决方法：
可以有很多种办法看这个文件是DOS格式的还是UNIX格式的, 还是MAC格式的
（1） vim filename
然后用命令 :set ff
可看到dos或unix的字样，如果的确是dos格式的, 那么用set ff=unix把它强制为unix格式的,，然后存盘退出后就可运行。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;误解压删除&#34;&gt;误解压删除&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;$ tar -tf big-bag.tar.gz | xargs rm -rf #这是删除解压后的文件的命令&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;kill命令&#34;&gt;kill命令&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ps -A|grep zerotier-one&lt;/code&gt;查看进程&lt;br&gt;
&lt;code&gt;ps -A&lt;/code&gt;查看所有进程&lt;br&gt;
&lt;code&gt;ps -ef&lt;/code&gt;查看所有进程，并查看是哪个软件&lt;br&gt;
&lt;code&gt;ps -aux&lt;/code&gt;更加详细的信息&lt;br&gt;
&lt;code&gt;kill -STOP PID&lt;/code&gt;停止一个进程但是不消灭&lt;br&gt;
&lt;code&gt;kill -CONT PID&lt;/code&gt;重新开始停止的进程&lt;br&gt;
&lt;code&gt;killall -9 zerotier-one&lt;/code&gt;通过程序名称杀死进程&lt;br&gt;
&lt;code&gt;pkill zerotier-one&lt;/code&gt;通过进程名称杀死进程&lt;br&gt;
killall和pkill是相似的，不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。&lt;/p&gt;
">Ubuntu 常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lisonglin-xidian.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/media/js/mouse/fireworks.js"></script>




  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>

</html>